{"posts":[{"title":"AJAX","text":"AJAX全称为Asynchronous JavaScript And XML，就是异步的 JS 和 XML。通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势: 无刷新获取数据。AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 XML简介XML 可扩展标记语言。 XML 被设计用来传输和存储数据。 XML 和 HTML类似，不同的是HTML中都是预定义标签，而XML中没有预定义标签，全都是自定义标签，用来表示一些数据。 123456789比如说我有一个学生数据: name = &quot;孙悟空&quot;,age = 18; gender = &quot;男&quot;;用XML表示: &lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;/student&gt; 现在已经被JSON取代了。 用JSON表示: 1{&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;} AJAX特点优点: 可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 缺点: 没有浏览历史，不能回退 存在跨域问题(同源) SEO不友好，(SEO意思: 是搜索引擎优化) HTTP协议请求与响应的结构参见:网络协议 - Hexo (mk310.github.io) express框架 使用express框架之前要安装node.js 123456789101112131415161718192021# npm init --yes 初始化# npm i express 安装express npm如何安装在5博客里面有写。# 1.引入express const express = require('express');# 2.创建应用对象 const app = express();# 3.创建路由规则# request 是对请求报文的封装# response 是对响应报文的封装 app.get('/',(request,response)=&gt;{ response.send(&quot;Hello,express!&quot;); });# 4.监听端口启动服务 app.listen(8080,()=&gt;{ console.log(&quot;服务已经启动，8080端口监听中.....&quot;); }) # node 文件名.js 启动测试 访问127.0.0.1:8080 GET请求(原生)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX GET 请求&lt;/title&gt; &lt;style&gt; #result{ width: 200px; height: 100px; border: solid 1px #90b; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取button元素 const btn = document.getElementsByTagName('button')[0]; const result = document.getElementById('result'); btn.onclick = function(){ //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化，设置请求方法和url xhr.open('GET','http://127.0.0.1:8080/server'); //3.发送 xhr.send(); //4.事件绑定 处理服务端返回的结果 // readystate 是xhr对象中的属性，表示状态0,1,2,3,4 /* 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 */ xhr.onreadystatechange = function(){ if(xhr.readyState === 4 &amp;&amp; (xhr.status &gt;=200 &amp;&amp; xhr.status&lt;300)){ // 处理 行 头 空行 体 //响应行 // console.log(xhr.status);//状态码 // console.log(xhr.statusText);//状态字符串 // console.log(xhr.getAllResponseHeaders());//所有响应头 // console.log(xhr.response);//响应体 //设置result的文本 result.innerHTML = xhr.response; } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //设置响应体 response.send('HELLO AJAX');});//4.监听端口启动服务app.listen(8080,()=&gt;{ console.log(&quot;服务已经启动，8080端口监听中.....&quot;);}) POST请求(原生)1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;AJAX 发送POST请求&lt;/title&gt; &lt;style&gt; #result{ width: 200px; height: 100px; border: solid 1px #903; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取元素对象 const result = document.getElementById(&quot;result&quot;); //绑定事件 result.addEventListener(&quot;mouseover&quot;,function(){ //1.创建对象 const xhr = new XMLHttpRequest(); //2.初始化 设置类型与URL xhr.open('POST',&quot;http://127.0.0.1:8000/server&quot;); //设置请求头信息 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); //3.发送 xhr.send(); //4.事件绑定 xhr.onreadystatechange = function(){ //判断 if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ //处理服务端返回的结果 result.innerHTML = xhr.response; } } } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装// app.get('/server',(request,response)=&gt;{// //设置响应头// response.setHeader('Access-Control-Allow-Origin','*');// //设置响应体// response.send('HELLO AJAX');// });app.post('/server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //设置响应体 response.send('HELLO AJAX');});//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);}) 服务器响应JSON数据(原生)12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;JSON响应&lt;/title&gt; &lt;style&gt; #result{ width:200px; height:100px; border:solid 1px #89b; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const result = document.getElementById('result'); //绑定键盘按下事件 window.onkeydown = function(){ //发送请求 const xhr = new XMLHttpRequest(); //设置响应体数据的类型 xhr.responseType = 'json'; //初始化 xhr.open('GET','http://127.0.0.1:8000/json-server'); //发送 xhr.send(); //事件绑定 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300){ result.innerHTML = xhr.response.name; } } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //设置响应体 response.send('HELLO AJAX');});// app.post('/server',(request,response)=&gt;{// //设置响应头// response.setHeader('Access-Control-Allow-Origin','*');// //设置响应体// response.send('HELLO AJAX');// });app.get('/json-server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //响应一个数据 const data = { name: 'atguigu' } //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(data);});//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);}) IE缓存问题(原生)123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;IE缓存问题&lt;/title&gt; &lt;style&gt; #result{ width:200px; height:100px; border:solid 1px #258; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const btn = document.getElementsByTagName('button')[0]; const result = document.querySelector('#result'); btn.addEventListener('click', function(){ const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,'http://127.0.0.1:8000/ie?time='+Date.now()); xhr.send(); xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300){ result.innerHTML = xhr.response; } } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //设置响应体 response.send('HELLO AJAX');});// app.post('/server',(request,response)=&gt;{// //设置响应头// response.setHeader('Access-Control-Allow-Origin','*');// //设置响应体// response.send('HELLO AJAX');// });app.get('/json-server',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //响应一个数据 const data = { name: 'atguigu' } //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体 response.send(data);});app.get('/ie',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //设置响应体 response.send('HELLO IE');});//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);}) 请求异常与网络超时(原生)123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;请求超时与异常处理&lt;/title&gt; &lt;style&gt; #result{ width:200px; height:100px; border:solid 1px #258; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const btn = document.getElementsByTagName('button')[0]; const result = document.querySelector('#result'); btn.addEventListener('click', function(){ const xhr = new XMLHttpRequest(); //超时设置2s设置 xhr.timeout = 2000; xhr.ontimeout = function(){ alert('网络异常,请稍后重试'); } //网络异常问题 xhr.onerror = function(){ alert('你的网络似乎出了一点问题'); } xhr.open(&quot;GET&quot;,'http://127.0.0.1:8000/delay'); xhr.send(); xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300){ result.innerHTML = xhr.response; } } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{});//jsonapp.get('/json-server',(request,response)=&gt;{});//ie缓存app.get('/ie',(request,response)=&gt;{});//延迟响应app.get('/delay',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //定时器 setTimeout(()=&gt;{ //设置响应体 response.send('延时响应'); },3000) });//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);}) 取消发送(原生)123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;取消请求&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送&lt;/button&gt; &lt;button&gt;点击取消&lt;/button&gt; &lt;script&gt; //获取元素对象 const btns = document.querySelectorAll('button'); let x = null; btns[0].onclick = function(){ x = new XMLHttpRequest(); x.open('GET','http://127.0.0.1:8000/delay'); x.send(); } btns[1].onclick = function(){ //abort 中止 x.abort(); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{});//jsonapp.get('/json-server',(request,response)=&gt;{});//ie缓存app.get('/ie',(request,response)=&gt;{});//延迟响应app.get('/delay',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //定时器 setTimeout(()=&gt;{ //设置响应体 response.send('延时响应'); },3000) });//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);}) 请求重复发送(原生)123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;重复请求问题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送&lt;/button&gt; &lt;script&gt; //获取元素对象 const btns = document.querySelectorAll('button'); let x = null; //标识变量 let isSending = false; // 是否正在发送AJAX请求 btns[0].onclick = function(){ //判断标识变量 if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求 x = new XMLHttpRequest(); //修改 标识变量的值 isSending = true; x.open(&quot;GET&quot;,'http://127.0.0.1:8000/delay'); x.send(); x.onreadystatechange = function(){ if(x.readyState === 4){ //修改标识变量 isSending = false; } } } // abort 中止 btns[1].onclick = function(){ x.abort(); } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031// 1.引入expressconst express = require('express');// 2.创建应用对象const app = express();// 3.创建路由规则//request 是对请求报文的封装//response 是对响应报文的封装app.get('/server',(request,response)=&gt;{});//jsonapp.get('/json-server',(request,response)=&gt;{});//ie缓存app.get('/ie',(request,response)=&gt;{});//延迟响应app.get('/delay',(request,response)=&gt;{ //设置响应头 response.setHeader('Access-Control-Allow-Origin','*'); //定时器 setTimeout(()=&gt;{ //设置响应体 response.send('延时响应'); },3000) });//4.监听端口启动服务app.listen(8000,()=&gt;{ console.log(&quot;服务已经启动，8000端口监听中.....&quot;);})","link":"/2024/06/26/AJAX/"},{"title":"4-BFC和高度塌缩","text":"BFC和高度塌缩 高度塌缩在浮动布局中，父元素的高度默认是被子元素撑开的 当子元素浮动后，脱离文档流，子元素从文档流中脱离将会无法撑起父元素的高度，导致父元素的高度丢失 父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱 子元素浮动后，父元素高度塌缩，父元素的兄弟元素上行，占据原来父元素的位置 BFCBFC（Block Formatting Context）块级格式化环境，为CSS的一个隐藏属性 元素开启 BFC 后的特点： 不会被浮动元素覆盖 父子元素外边距不会重叠 可以包含浮动的元素 打开BFC的方法： 设置为浮动（不推荐）：很明显下方元素被覆盖了，总不能让所有元素都浮动吧 设置为行内块元素（不推荐）：不再独占一行，宽度变了，同时与下方元素产生了一点空隙 设置overflow为非visible值：既没有覆盖元素，也保持了独占一方的特性（保持了宽度），与下方元素也保持了最初的间隙 clear如果我们不希望某个元素因为其他元素浮动的影响而改变位置，可以通过 clear属性来清除浮动元素对当前元素所产生的影响 clear作用：清除浮动元素对当前元素所产生的影响（本质是为元素添加一个margin-top属性，值由浏览器自动计算） 子元素和父元素相邻，外边距重合的情况： 子元素和父边距相邻且加上上边距后，边距传递到父元素，父元素和子元素一起下行 利用clear来解决高度塌缩子元素浮动后脱离文档流，父元素高度塌缩，解决方法： 可以增加一个子元素son2，让其撑开父元素的高度 son2使用clear清除son1浮动的带来的效果（即浏览器自动为son2加上一个son1高度的外边距） 同时为了避免son2和父元素的外边距相邻，把外边距传递给父元素，son2应该在son1之后 网页设计:结构(HTML)+表现(CSS)+行为(JS),上面使用HTML种son2完成了表现,为了更贴合网页设计概念,取消使用son2,利用CSS中伪元素::after 使用::after达成同样的效果 123456789101112131415161718192021222324252627282930313233343536 &lt;style&gt; .father { /* 父元素没有指定宽高 */ background-color: aquamarine; } .son1 { width: 50px; height: 50px; background-color: rgb(37, 177, 177); float: left; } /* 添加子元素 */ .father::after { /* .father::after默认是行内元素,不是独占一行,转为块元素 */ display: block; /* 添加内容为空 */ content: ''; /* 清除浮动影响 */ clear: both; } .box { width: 55px; height: 55px; background-color: rgb(207, 11, 11); } &lt;/style&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; clearfix使用clearfix同时解决父元素高度塌缩和子元素父元素外边距重合: 123456.clearfix::before,.clearfix::after { content: &quot;&quot;; display: table; clear: both;} 解决子元素父元素外边距重合: 1234.clearfix::before{ content: &quot;&quot;; display: table;} 解决父元素塌缩: 12345.clearfix::after { content: &quot;&quot;; display: table; clear: both;} 使用display: table是因为block有默认高度会影响布局,table没有默认高度 123456&lt;div class=&quot;father&quot;&gt; &lt;!-- ::before在这解决将子元素son1和father隔开,上边距不相邻后解决子元素父元素外边距重合 --&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;!-- ::after在这里解决父元素塌缩,不能是::before解决,因为.father::before会和父元素发生上边距重合 --&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;","link":"/2024/02/25/BFC%E5%92%8C%E9%AB%98%E5%BA%A6%E5%A1%8C%E7%BC%A9/"},{"title":"CSS基础","text":"css(Cascading Style Sheets)层叠样式表 准备常见的字符集： 【Web前端HTML5&amp;CSS3】01-前端简介 - VectorX - 博客园 (cnblogs.com) 网页基本知识: 【Web前端HTML5&amp;CSS3】03-字符实体与语义标签 - VectorX - 博客园 (cnblogs.com) CSS语法和选择器样式表内联样式(行内样式) 在标签内部通过style属性来设置元素的样式 1&lt;p style=&quot;color:red;font-size:60px;&quot;&gt;内联样式（行内样式）&lt;/p&gt; 开发时候尽量不要使用 内部样式表 将样式编写到head中的style标签里然后通过 css 的选择器来选中元素并为其设置各种样式可以同时为多个标签设置样式，并且修改时只需要修改一处即可。内部样式表更加方便对样式进行复用 123456&lt;style&gt;p{ color:green; font-size:50px;}&lt;/style&gt; 外部样式表 可以将 css 样式编写到一个外部的 CSS 文件中，然后通过link标签来引入外部的 CSS 文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; /&gt; 选择器css选择器通配选择器（Universal selector） 选择页面中所有的元素 123* { color: red;} 元素选择器（Type selector） 根据标签名选中指定的元素 1234567p { color: red;}h1 { color: green;} 类选择器（Class selector） 根据元素的class属性选中一组元素 123456.blue { color: blue;}.size { font-size: 20px;} class是一个标签的属性，它和id类似，不同的是class: 可以重复使用， 可以通过class属性来为元素分组， 可以同时为一个元素指定多个class属性 ID 选择器（ID selector） 根据元素id属性值选中元素 123#red { color: red;} 属性选择器（Attribute selector） 1234567891011121314151617181920#选择含有指定属性的元素p[title] { color: orange;}#选择含有指定属性和属性值的元素p[title=&quot;e&quot;] { color: orange;}#选择属性值以指定值开头的元素p[title^=&quot;e&quot;] { color: orange;}#选择属性值以指定值结尾的元素p[title$=&quot;e&quot;] { color: orange;}#选择属性值中含有某值的元素p[title*=&quot;e&quot;] { color: orange;} 复合选择器 交集选择器和并集选择器区别_笔记大全_设计学院 (python100.com) 交集选择器 选中同时符合多个条件的元素(同时符合多个选择器的元素) 1234#选中所有class为box并且p标签的元素.box p { font-size: 20px;} 并集选择器 选中同符合多个条件的元素() 1234#选中所有class为box和p标签的元素.box, p { font-size: 20px;} 复合选择器 选中同时复合多个条件的元素() 关系选择器子元素选择器（Child combinator） 选中指定父元素的指定子元素 123div.box &gt; p &gt; span { color: orange;} 后代元素选择器（Descendant combinator） 选中指定元素内的指定后代元素 123div span { color: skyblue;} 兄弟元素选择器（Sibling combinator） 选择下一个兄弟 123456789#选中第一个&lt;p&gt;元素紧跟着一个同级的&lt;span&gt;元素时p + span { color: red;}#选中&lt;p&gt;元素后面的所有同级&lt;span&gt;元素p ~ span { color: red;} 伪类选择器伪类（不存在的类，特殊的类） 用来描述一个元素的特殊状态，例如：第一个子元素，被点击的元素 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child() 选中第 n 个子元素 n：第 n 个，n 的范围 0 到正无穷 2n 或 even：选中偶数位的元素 2n+1 或 odd：选中奇数位的元素 123456789101112131415161718192021222324/* ul下所有li，黑色 */ul &gt; li { color: black;}/* ul下第偶数个li，黄色 */ul &gt; li:nth-child(2n) { color: yellow;}/* ul下第奇数个li，绿色 */ul &gt; li:nth-child(odd) { color: green;}/* ul下第一个li，红色 */ul &gt; li:first-child { color: red;}/* ul下最后一个li，黄色 */ul &gt; li:last-child { color: orange;} 123456789101112131415161718192021&lt;style&gt; /* 把没访问过的链接用特殊颜色标记出来 */ a:link { color: aqua; } /* 把已经访问过的链接用特殊颜色标记 */ a:visited { color: azure; } /* 鼠标经过时链接变色 */ a:hover { color: black; } /* 鼠标按下还未弹起的时候变换的特殊颜色 */ a:active { color: blue; }&lt;/style&gt; 伪元素选择器伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置） ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 元素的开始 ::after 元素的最后 ::before和::after 必须结合content属性来使用 1234567891011121314151617181920212223242526/* 段落首字母设置大小为30px */p::first-letter { font-size: 30px;}/* 段落第一行设置为黄色背景 */p::first-line { background-color: yellow;}/* 段落选中的部分变绿色 */p::selection { background-color: green；;}/* div前加上内容 */div::before { content: &quot;BEFORE&quot;; color: red;}/* div后加上内容 */div::after { content: &quot;AFTER&quot;; color: blue;} 选择器练习小游戏 三特性和其他css的三特性层叠性相同选择器设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。层叠性的主要解决冲突的问题 层叠性原则： 样式冲突，遵循就近原则，那个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 继承性css中子标签会继承父标签的某些样式，如文本颜色和字号。 优先级 相同选择器，遵循层叠原则 不同选择器，按照权重来 ​ 选择器 权重 继承 0，0，0，0 元素标签选择器 0，0，0，1 类/伪类选择器 0，0，1，0 id选择器 0，1，0，0 行内样式表 1，0，0，0 important ∞ 1background-color: rgba(0, 0, 0, 0.3) !important; 使用important声明的属性优先级最高 注意： 如果继承的优先级为0，如果标签定义有样式表，则优先级高于其继承父标签的样式表 1234567891011121314 &lt;style&gt; #father { color: aqua; } p { color: azure; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 权重的叠加：定义范围更小的优先级高，如li的权重低于 ul li px，em，rem px：像素点 em：参考是父元素的font-size，具有继承的特点。如果自身定义了font-size按照自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值 rem：css3新单位，相对于根元素html的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱 浮动浮动简介通过浮动可以使一个元素向其父元素的左侧或右侧移动 使用float属性来设置于元素的浮动 none 默认值，元素不浮动 left 元素向左浮动 right 元素向右浮动 浮动特点 浮动元素会完全脱离文档流，不再占据文档流中的位置 设置浮动以后，元素会向父元素的左侧或右侧移动 浮动元素默认不会从父元素中移出 1234567891011121314151617&lt;style&gt; .box1 { width: 100px; height: 100px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 浮动元素向左或向右移动时，不会超过前边的浮动元素（先来后到的顺序） 1234567891011121314151617181920212223242526&lt;style&gt; .box1 { width: 200px; height: 200px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; float: left; } .box3 { width: 200px; height: 200px; background-color: yellow; float: left; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 浮动元素不会超过上边的浮动的兄弟元素，最多就是和它一样高 1234567891011121314151617181920212223242526&lt;style&gt; .box1 { width: 300px; height: 300px; background-color: orange; float: left; } .box2 { width: 400px; height: 400px; background-color: red; float: left; } .box3 { width: 300px; height: 300px; background-color: yellow; float: right; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 12345678910111213141516171819202122232425262728 &lt;style&gt; /* 不浮动 */ .box1 { width: 200px; height: 200px; background-color: orange; }/* 向左浮动 */ .box2 { width: 200px; height: 200px; background-color: aqua; float: left; } /* 不浮动 */ .box3 { width: 300px; height: 300px; background-color: rgb(34, 31, 31); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/body&gt; 浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以利用浮动来设置文字环绕图片的效果 浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局 脱离文档流的特点块元素： 块元素不再独占页面的一行 脱离文档流以后，块元素的宽度和高度默认都被内容撑开 12345678&lt;style&gt; .box1{ background-color: aqua; /* 浮动后 hello从原本占一样 变为hello文本长度 */ float: left; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;hello&lt;/div&gt; 行内元素: 行内元素脱离文档流以后会，特点和块元素一样 脱离文档流之后的特点很像行内块元素，不过存在一些差异","link":"/2024/01/10/CSS%E5%9F%BA%E7%A1%80/"},{"title":"BOM","text":"BOM：浏览器对象模型 BOM 可以使我们通过 JS 来操作浏览器 在 BOM 中为我们提供了一组对象，用来完成对浏览器的操作 BOM 对象 BOMWindow代表的是整个 浏览器的窗口，同时 window 也是网页中的全局对象 Navigator代表的当前 浏览器的信息，通过该对象可以来识别不同的浏览器 Location代表当前 浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面 History代表 浏览器的历史记录，可以通过该对象来操作浏览器的历史记录由于隐私原因 该对象不能获取到具体的历史记录，只能操作 浏览器向前或向后翻页，而且该操作只在当次访问时有效 Screen代表用户的 屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 Navigator由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 在 IE11 中已经将微软和 IE 相关的标识都已经去除了，所以我们基本已经不能通过userAgent来识别一个浏览器是否是 IE 了 还有个ActiveXObject也是 IE 中所特有的，我们可以根据这个来做判断 123456// 利用`ActiveXObject`是 IE 中特有的属性，以及通过`window.属性 == undefined`特点来判断是否是 IEif(window.ActiveXObject){ alert(&quot;IE浏览器&quot;);} else{ alert(&quot;非IE浏览器&quot;);} ActiveXObject在ie11中是特殊对象,转为bool值后返回false,使用新方法判断: 1console.log(&quot;ActiveXObject&quot; in window); // true 浏览器信息判断: 123456789101112var ua = navigator.userAgent;if (/edg/i.test(ua)) { alert(&quot;Edge浏览器&quot;);} else if (/firefox/i.test(ua)) { alert(&quot;火狐浏览器&quot;);} else if (/chrome/i.test(ua)) { alert(&quot;谷歌浏览器&quot;);} else if (/msie/i.test(ua)) { alert(&quot;IE浏览器&quot;);} else if (&quot;ActiveXObject&quot; in window) { alert(&quot;IE11浏览器&quot;);} Historylengthlength属性，可以获取到当次访问的链接数量 1234alert(history.length);// 访问History页面：1// 访问Test02页面并跳转至History页面：2// 访问Test01页面并跳转至History页面：3 back()可以用来回退到上一个页面，作用和浏览器的回退按钮一样 1history.back(); forward()可以跳转下一个页面，作用和浏览器的前进按钮一样 1history.forward(); go()可以用来跳转到指定的页面，它需要一个整数作为参数 1：表示向前跳转一个页面，相当于forward() 2：表示向前跳转两个页面 -1：表示向后跳转一个页面，相当于back() -2：表示向后跳转两个页面 Location如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径） 1alert(location); // http://127.0.0.1:8848/Demo/17-04-Location.html 如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录 1location = &quot;http://www.baidu.com&quot;; assign()用来跳转到其他的页面，作用和直接修改location一样 会生成历史记录， 能使用回退按钮回退 1location.assign(&quot;http://www.baidu.com&quot;); replace()可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退 1location.replace(&quot;17-03-History.html&quot;); reload()用于重新加载当前页面，作用和刷新按钮（F5）一样 1location.reload(); 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面（Ctrl + F5）","link":"/2024/05/25/BOM/"},{"title":"DOM","text":"DOM，全称Document Object Model 文档对象模型。 JS中通过DOM来对HTML文档进行操作。只要理解了DOM就可以随心所欲的操作WEB页面。 DOM模型 节点节点Node，是构成我们网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点 比如：html标签、属性、文本、注释、整个文档等都是一个节点 虽然都是节点，但是实际上他们的具体类型是不同的。比如： 标签称为元素节点 属性称为属性节点 文本称为文本节点 文档称为文档节点 文档节点（Document）文档节点document，代表的是整个HTML文档，网页中的所有节点都是它的子节点 document对象作为window对象的属性存在的，我们不用获取可以直接使用 通过该对象我们可以在整个文档访问内查找节点对象，并可以通过该对象创建各种节点对象 元素节点（Element）HTML中的各种标签都是元素节点，这也是我们最常用的一个节点 浏览器会将页面中所有的标签都转换为一个元素节点，我们可以通过document的方法来获取元素节点 比如：document.getElementById() 根据id属性值获取一个元素节点对象。 文本节点（Text）文本节点表示的是HTML标签以外的文本内容，任意非HTML的文本都是文本节点 它包括可以字面解释的纯文本内容 文本节点一般是作为元素节点的子节点存在的 获取文本节点时，一般先要获取元素节点，再通过元素节点获取文本节点。例如：元素节点.firstChild; 获取元素节点的第一个子节点，一般为文本节点 属性节点（Attr）属性节点表示的是标签中的一个一个的属性，这里要注意的是属性节点并非是元素节点的子节点，而是元素节点的一部分 可以通过元素节点来获取指定的属性节点。例如：元素节点.getAttributeNode(&quot;属性名&quot;); 注意：我们一般不使用属性节点 浏览器已经为我们提供文档节点对象，这个对象是window 属性可以在页面中直接使用，文档节点代表的是整个网页 事件事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间 JavaScript与HTML之间的交互是通过事件实现的 文档的加载浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行，如果将script标签写到页面的上边，在代码执行时，页面还没有加载，DOM对象也没有加载，会导致无法获取到DOM对象 onload事件会在整个页面加载完成之后才触发，可以为window对象绑定一个onload事件 12345678window.onload = function(){ // 获取button对象 var btn = document.getElementById(&quot;btn&quot;); // 绑定一个单击事件 btn.onclick = function(){ alert(&quot;Don't touch me.&quot;); }} 该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了 DOM查询获取元素节点通过document对象调用 getElementById() 通过id属性获取一个元素节点对象 1234myClick(&quot;btn01&quot;, function () { // innerHTML 通过这个属性可以获取到元素内部的html代码 alert(document.getElementById(&quot;bj&quot;).innerHTML); // 北京}); getElementsByTagName() 通过标签名获取一组元素节点对象 12345678910111213myClick(&quot;btn02&quot;, function () { // getElementsByTagName()可以根据标签名来获取一组元素节点对象 // 这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中 // 即使查询到的元素只有一个，也会封装到数组中返回 var li_list = document.getElementsByTagName(&quot;li&quot;); alert(li_list.length); // 14 var arr = []; for(var i=0;i&lt;li_list.length;i++){ arr.push(li_list[i].innerHTML); } alert(arr); // 北京,上海,东京,首尔,红警,实况,极品飞车,魔兽,IOS,Android,Windows Phone,IOS,Android,Windows Phone}); getElementsByName() 通过name属性获取一组元素节点对象 123456789101112131415myClick(&quot;btn03&quot;, function () { var inputs = document.getElementsByName(&quot;gender&quot;); alert(inputs.length); // 2 var arr = []; for(var i=0;i&lt;inputs.length;i++){ // innerHTML用于获取元素内战的HTML代码的 // 如果需要读取元素节点属性，直接使用`元素.属性名` // 例子：`元素.id` `元素.name` `元素.value` arr.push(inputs[i].value); // 注意：class属性不能采用这种方式，读取class属性时需要使用`元素.className` arr.push(inputs[i].className); } alert(arr); // male,hello,female,hello}); 获取元素节点的子节点通过具体的元素节点调用 getElementsByTagName()方法，返回当前节点的指定标签名后代节点 123456789101112myClick(&quot;btn04&quot;, function () { var city = document.getElementById(&quot;city&quot;); // 获取city下1i节点 var list = city.getElementsByTagName(&quot;li&quot;); alert(list.length); // 4 var arr = []; for(var i=0;i&lt;list.length;i++){ arr.push(list[i].innerHTML); } alert(arr); // 北京,上海,东京,首尔}); childNodes属性，表示当前节点的所有子节点 1234567891011121314151617myClick(&quot;btn05&quot;, function () { var city = document.getElementById(&quot;city&quot;); // childNodes属性会获取包括文本节点在内的所有节点 // 根据DOM标签标签间空白也会当成文本节点 // 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点 // 所以该属性在IE8中会返回4个子元素，而其他浏览器是9个 var list = city.childNodes; alert(list.length); // 9 var arr = []; for(var i=0;i&lt;list.length;i++){ arr.push(list[i]); } alert(arr); // [object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text],[object HTMLLIElement],[object Text]});myClick(&quot;btn05&quot;, function () { children属性可以获取当前元素的所有子元素 1234567891011var city = document.getElementById(&quot;city&quot;); // children属性可以获取当前元素的所有子元素 var list = city.children; alert(list.length); // 4 var arr = []; for(var i=0;i&lt;list.length;i++){ arr.push(list[i].innerHTML); } alert(arr); // 北京,上海,东京,首尔}); firstChild属性，表示当前节点的第一个子节点 123456789101112131415161718192021myClick(&quot;btn06&quot;, function () { var phone = document.getElementById(&quot;phone&quot;); // firstChild可以获取到当前元素的第一个子节点（包括空白文本节点） var firstChild = phone.firstChild; alert(firstChild); // [object HTMLLIElement] alert(firstChild.innerHTML); // IOS});myClick(&quot;btn06&quot;, function () { var phone2 = document.getElementById(&quot;phone2&quot;); // firstChild可以获取到当前元素的第一个子节点（包括空白文本节点） var firstChild = phone2.firstChild; alert(firstChild); // [object Text] alert(firstChild.innerHTML); // undefined});myClick(&quot;btn06&quot;, function () { var phone2 = document.getElementById(&quot;phone2&quot;); // firstElementchild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用 var firstElementChild = phone2.firstElementChild; alert(firstElementChild); // [object HTMLLIElement] alert(firstElementChild.innerHTML); // IOS}); lastChild属性，表示当前节点的最后一个子节点 1234567document.getElementById(&quot;btn062&quot;).onclick = function () { var phone = document.getElementById(&quot;phone&quot;); // children属性可以获取当前元素的所有子元素 var lastChild = phone.lastChild; alert(lastChild); // [object HTMLLIElement] alert(lastChild.innerHTML); // Windows Phone}); DOM查询的剩余方法document.body在document中有一个属性body，它保存的是body的引用 123456// 注意：如果script标签是定义在head中的，则这里需要window.onload = function(){}包裹，否则会出现null的情况var body = document.getElementsByTagName(&quot;body&quot;);console.log(body); // HTMLCollection [body]body = document.body;console.log(body); // &lt;body&gt;&lt;/body&gt;console.log(typeof body); // object document.documentElementdocument.documentElement保存的是html根标签 12var html = document.documentElement;console.log(html); document.alldocument.all代表页面中所有的元素 document.all代表页面中所有的元素 12345678910var all = document.all;console.log(all); // HTMLAllCollection(11) [html, head, meta, title, script, script, script, body, script, script, script]console.log(all.length); // 11console.log(typeof all); // undefinedfor(var i=0;i&lt;all.length;i++){ console.log(all[i]);}var el = document.getElementsByTagName(&quot;*&quot;); document.getElementsByClassName()根据元素的class属性值查询一组元素节点对象 getElementsByClassName()可以根据class属性值获取一组元素节点对象，但是该方法不支持IE8及以下的浏览器 1234var boxs = document.getElementsByClassName(&quot;box&quot;);console.log(boxs); // HTMLCollection(3) [div.box, div.box, div.box]console.log(boxs.length); // 3console.log(typeof boxs); // object document.querySelector()需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象 虽然IE8中没有getElementsByClassName()但是可以使用querySelector()代替 使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个 1234567var div = document.querySelector(&quot;.box div&quot;);console.log(div.innerHTML); // I'm first div.boxs = document.querySelector(&quot;.box&quot;);console.log(boxs); // &lt;div class=&quot;box&quot;&gt;// &lt;div&gt;I'm first div.&lt;/div&gt;// &lt;/div&gt; document.querySelectorAll()该方法和querySelector()用法类似，不的是它会将符合条件的元素封装到一个数组中返回 即使符合条件的元素只有一个，它也会返回数组 123boxs = document.querySelectorAll(&quot;.box&quot;);console.log(boxs); // NodeList(3) [div.box, div.box, div.box]console.log(boxs.length); //3 DOM增删改document.createElement()可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回 document.createTextNode()可以用来创建一个文本节点对象，它需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回 appendChild()向一个父节点中添加一个新的子节点，用法：父节点.appendChild(子节点); insertBefore()可以在指定的子节点前插入新的子节点，语法：父节点.insertBefore(新节点, 旧节点); replaceChild()可以使用指定的子节点替换已有的子节点，语法：父节点.replaceChild(新节点, 旧节点); removeChild()可以删除一个子节点，语法：父节点.removeChild(子节点);、子节点.parentNode.removeChild(子节点); 操作内联样式修改元素内联样式通过JS修改元素的内联样式，语法：元素.style.样式名 = 样式值 12box1.style.height = &quot;200px&quot;;box1.style.width = &quot;200px&quot;; 注意：如果CSS的样式名中含有一，这种名称在JS中是不合法的，比如background-color 需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写 12// box1.style.background-color = &quot;red&quot;; // Uncaught SyntaxError: Invalid left-hand side in assignmentbox1.style.backgroundColor = &quot;red&quot; 通过 style 属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示 但是如果在样式中写了!important，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效，所以尽量不要为样式添加!important 读取元素内联样式通过 JS 读取元素的内联样式，语法：元素.style.样式名 通过style属性设置和读取的都是内联样式，无法读取样式表中的样式 读取元素样式获取元素的当前显示的样式，语法：元素.currentStyle.样式名 它可以用来读取当前元素正在显示的样式，如果当前元素没有设置该样式，则获取它的默认值 123alert(box1.currentStyle.height); // 100pxbox1.style.height = &quot;200px&quot;;alert(box1.currentStyle.height); // 200px 不过currentstyle只有IE浏览器支持，其他的浏览器都不支持。我们在 IE 中测试是可行的，在 Chrome 或 Edge 中报错的：UncaughtTypeError: Cannot read property 'height' of undefined 不过，在其他浏览器中可以使用getComputedStyle()，这个方法来获取元素当前的样式 这个方法是window的方法，可以直接使用，需要两个参数 第一个：要获取样式的元素 第二个：可以传递一个伪元素，一般都传null 该方法会返回一个对象，对象中封装了当前元素对应的样式 可以通过对象.样式名来读取样式，如果获取的样式没有设置，则会获取到真实的值，而不是默认值 比如：没有设置 width，它不会获取到 auto，而是一个长度 但是该方法不支持IE8及以下的浏览器 12345var obj = getComputedStyle(box1, null);alert(obj); // [object CSSStyleDeclaration]alert(obj.width); // 200pxalert(obj.height); // 200pxalert(obj.backgroundColor); // rgb(255, 0, 通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性 那么我就只能自己写个函数，来兼容所有浏览器 1234567891011// 自定义兼容所有浏览器获取元素样式的方法function getStyle(obj, name) { // 判断是否有getComputedStyle方法 if (window.getComputedStyle) { // 正常浏览器的方式 return getComputedStyle(obj, null)[name]; } else { // IE的方式 return obj.currentStyle[name]; }} 其他样式相关的属性clientwidth、clientHeight这两个属性可以获取元素的可见宽度和高度 这些属性都是不带px的，返回都是一个数字，可以直接进行计算 会获取元素宽度和高度，包括内容区和内边距 这些属性都是只读的，不能修改（改只有一种方式，就是通过元素.style.样式 = 样式值） offsetwidth、offsetHeight获取元素的整个的宽度和高度，包括内容区、内边距和边框 offsetParent可以用来获取当前元素的定位父元素 会获取到离当前元素最近的开启了定位（只要position不是sticky）的祖先元素 如果所有的祖先元素都没有开启定位，则返回body offsetLeft、offsetTop当前元素相对于其定位父元素的水平或垂直偏移量 scrollHeight、scrollWidth可以获取元素整个滚动区域的宽度和高度","link":"/2024/05/06/DOM/"},{"title":"Date和Math","text":"JS call，apply，arguments Date在JS中使用Date对象来表示一个时间 创建一个时间对象如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间 1234// 创建一个Date对象// 如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间var d = new Date();console.log(d); // Fri Jul 30 2021 21:51:37 GMT+0800 (中国标准时间) 创建一个指定的时间对象需要在构造函数中传递一个表示时间的字符串作为参数 日期的格式：月/日/年 时:分:秒 1234d = new Date(&quot;08/01/2021 12:34:56&quot;);console.log(d); // Sun Aug 01 2021 12:34:56 GMT+0800 (中国标准时间)d = new Date(&quot;08/01/21 12:34:56&quot;); // 为了避免在不同浏览器中产生歧义，尽量指定完整年份console.log(d); // IE：Mon Aug 01 1921 12:34:56 GMT+0800 (中国标准时间) Date方法好的，以下是整理后的生成MD表格： 方法 描述 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天（1 ～ 31）。 getDay() 从 Date 对象返回一星期中的某一天（0 ～ 6）。 getMonth() 从 Date 对象返回月份（0 ～ 11）。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时（0 ～ 23）。 getMinutes() 返回 Date 对象的分钟（0 ～ 59）。 getSeconds() 返回 Date 对象的秒数（0 ～ 59）。 getMilliseconds() 返回 Date 对象的毫秒数（0 ～ 999）。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间（GMT）的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的某一天（1 ～ 31）。 getUTCDay() 根据世界时从 Date 对象返回周中的某一天（0 ～ 6）。 getUTCMonth() 根据世界时从 Date 对象返回月份（0 ～ 11）。 getUTCFullYear() 根据世界时从 Date 对象返回四位的年份。 getUTCHours() 根据世界时返回 Date 对象的小时（0 ～ 23）。 getUTCMinutes() 根据世界时返回 Date 对象的分钟（0 ～ 59）。 getUTCSeconds() 根据世界时返回 Date 对象的秒数（0 ～ 59）。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒数（0 ～ 999）。 parse() 返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数。 parse() 返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数。 MathMath和其他的对象不同，不是一个构造函数 属于一个工具类，不用创建对象，里边封装了数学运算相关的属性和方法 属性： 属性 描述 Math.E 返回算术常量 e，即自然对数的底数（约等于2.718）。 Math.LN2 返回 2 的自然对数（约等于0.693）。 Math.LN10 返回 10 的自然对数（约等于2.302）。 Math.LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 Math.LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 Math.PI 返回圆周率（约等于3.14159）。 Math.SQRT1_2 返回 2 的平方根的倒数（约等于 0.707）。 Math.SQRT2 返回 2 的平方根（约等于 1.414）。 方法： 好的，以下是整理后的生成MD表格： 方法 描述 Math.abs(x) 返回数的绝对值。 Math.acos(x) 返回数的反余弦值。 Math.asin(x) 返回数的反正弦值。 Math.atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值返回 x 的反正切值。 Math.atan2(y, x) 返回从 x 轴到点 (y, x) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 Math.ceil(x) 对数进行上舍入。 Math.cos(x) 返回数的余弦。 Math.exp(x) 返回 e 的指数。 Math.floor(x) 对数进行下舍入。 Math.log(x) 返回数的自然对数（底为 e）。 Math.max(x, y, z, …) 返回 x 和 y 中的最大值。 Math.min(x, y, z, …) 返回 x 和 y 中的最小值。 Math.pow(x, y) 返回 x 的 y 次幂。 Math.random() 返回 0 到 1 之间的随机数。 Math.round(x) 把数四舍五入为最接近的整数。 Math.sin(x) 返回数的正弦。 Math.sqrt(x) 返回数的平方根。 Math.tan(x) 返回角的正切。 Math.toSource() 返回该对象的源代码。 Math.valueOf() 返回 Math 对象的原始值。","link":"/2024/04/26/Date%E5%92%8CMath/"},{"title":"ECMASript 6","text":"ECMASript 6 ES6简介ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制 造商协会, 这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该 组织改名为 Ecma 国际。 ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。 ECMA-262标准列表 ECMA-262历史版本列表 TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司（其中主要是浏览器厂商:有苹果、谷歌、微软、因特尔等）。TC39 定期 召开会议, 会议由会员公司的代表与特邀专家出席 兼容性ECMAScript 6 compatibility table (compat-table.github.io) ES6更新的内容概括： 表达式：声明、解构赋值 内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect 语句与运算：Class、Module、Iterator 异步编程：Promise、Generator、Async let,const和作用域 var命令会发生“变量提升”现象, 即变量可以在声明之前使用, 值为undefined。 为了纠正这种现象, let、const命令改变了语法行为, 它所声明的变量一定要在声明后使用, 否则报错 概括声明: const:声明常量 let:声明变量 作用域: 全局作用域 函数作用域：function() {} 块级作用域：{} 作用范围: var命令在全局代码中执行 const命令和let命令只能在代码块中执行 赋值使用: const命令声明常量后必须立马赋值 let命令声明变量后可立马赋值或使用时赋值 声明方法:var、const、let、function、class、import 注意: 不允许重复声明 未定义就使用会报错：const命令和let命令不存在变量提升 暂时性死区：在代码块内使用const命令和let命令声明变量之前, 该变量都不可用 letlet 关键字用来声明变量, 使用 let 声明的变量有几个特点： 不允许重复声明 块级作用域 不存在变量提升 应用场景：声明重复赋值的变量时可以用这个(基本替代var) constonst 关键字用来声明常量 , const 声明有以下特点: 不允许重复声明 值不允许修改 不存在变量提升 块级作用域 声明必须赋初始值 标识符一般为大写 注意: 对象属性修改和数组元素变化不会触发 const 错误 const实际上保证的, 并不是变量的值不得改动, 而是变量指向的那个内存地址所保存的数据不得改动。 对于简单类型的数据（数值、字符串、布尔值）, 值就保存在变量指向的那个内存地址, 因此等同于常量。但对于复合类型的数据（主要是对象和数组）, 变量指向的内存地址, 保存的只是一个指向实际数据的指针, const只能保证这个指针是固定的（即总是指向另一个固定的地址）, 至于它指向的数据结构是不是可变的, 就完全不能控制了。。 应用场景：声明对象类型、确定不会再次赋值的变量使用 const , 其他的可以用let 123456789101112131415161718+----------+ +----------+| | | || [1, 2, 3] | | {a: 1, b: 2} || | | ||__________| |__________| ^ ^ | | / / / /+-----+ +-----+| | | || arr | --+-&gt; | obj ||_______| |_______| | --+--&gt; | Modify (e.g., a = 3) ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令, 另外两种声明变量的方法：import命令和class命令。所以 , ES6 一共有 6 种声明变量的方法。 块级作用域为什么需要块级作用域没有块级作用域可能出现一些不合理的现象: 123456789var tmp = new Date();function f() { //var tmp = undefined; 函数定义提升 console.log(tmp); if (false) { var tmp = 'hello world'; }}f(); // undefined 没有块级作用域,if语句中的函数定提升,导致前面输出的tmp是undefined 123var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]);}console.log(i); // 5 没有块级作用域,控制语句结束后,其中的i还能被语句外调用 ES6块级作用域let实际为JS添加了块级作用域 12345function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5} 上面的函数有两个代码块, 都声明了变量n, 运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n, 最后输出的值才是 10。 块级作用域的出现, 匿名立即执行函数表达式（匿名 IIFE,详见js高级）显得没有必要了 块级作用域和函数声明ES5 规定, 函数只能在顶层作用域和函数作用域之中声明, 不能在块级作用域声明。 ES5非法定义: 1234567891011// 情况一if (true) { function f() {}}// 情况二try { function f() {}} catch(e) { // ...} 上面两种函数声明, 根据 ES5 的规定都是非法的。 但是, 浏览器没有遵守这个规定, 为了兼容以前的旧代码, 还是支持在块级作用域之中声明函数, 因此上面两种情况实际都能运行, 不会报错。 ES6 引入了块级作用域, 明确允许在块级作用域之中声明函数。ES6 规定, 块级作用域之中, 函数声明语句的行为类似于let, 在块级作用域之外不可引用。 123456function f() { console.log('I am outside!'); }(function () { // 重复声明一次函数f if (false) { function f() { console.log('I am inside!'); }} f();}()); 123456789// ES5 环境实际运行function f() { console.log('I am outside!'); }(function () { function f() { console.log('I am inside!'); } if (false) {} f();}());// 会得到“I am inside!”, 12345678// 浏览器的 ES6 环境function f() { console.log('I am outside!'); }(function () { // 重复声明一次函数f if (false) { function f() { console.log('I am inside!'); } } f();}());// Uncaught TypeError: f is not a function 理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let, 对作用域之外没有影响。但是, 如果真的在 ES6 浏览器中运行一下上面的代码, 是会报错的 如果改变了块级作用域内声明的函数的处理规则, 显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题 , ES6 在附录 B里面规定, 浏览器的实现可以不遵守上面的规定, 有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var, 即会提升到全局作用域或函数作用域的头部。 同时, 函数声明还会提升到所在的块级作用域的头部。 上面三条规则只对 ES6 的浏览器实现有效, 其他环境的实现不用遵守, 还是将块级作用域的函数声明当作let处理。 根据这三条规则, 浏览器的 ES6 环境中, 块级作用域内声明的函数, 行为类似于var声明的变量。上面的例子实际运行的代码如下。 12345678// 浏览器的 ES6 环境function f() { console.log('I am outside!'); }(function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); }} f();}());// Uncaught TypeError: f is not a function 避免在块级作用域内声明函数。如果确实需要, 也应该写成函数表达式, 而不是函数声明语句。 12345678910111213// 块级作用域内部的函数声明语句, 建议不要使用{ let a = 'secret'; function f() { return a; }}// 块级作用域内部, 优先使用函数表达式{ let a = 'secret'; let f = function () { return a; };} 另外, 还有一个需要注意的地方。ES6 的块级作用域必须有大括号, 如果没有大括号 , JavaScript 引擎就认为不存在块级作用域。 1234567891011121314151617181920212223// 第一种写法, 报错if (true) let x = 1;// 第二种写法, 不报错if (true) { let x = 1;}第一种写法没有大括号, 所以不存在块级作用域, 而let只能出现在当前作用域的顶层, 所以报错。第二种写法有大括号, 所以块级作用域成立。 严格模式下, 函数只能声明在当前作用域的顶层// 不报错'use strict';if (true) { function f() {}}// 报错'use strict';if (true) function f() {} 赋值解构 ES6 允许按照一定模式, 从数组和对象中提取值, 对变量进行赋值, 这被称为解构（Destructuring）。 本质上, 这种写法属于“模式匹配”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值 概括 字符串解构：const [a, b, c, d, e] = &quot;hello&quot; 数值解构：const { toString: s } = 123 布尔解构：const { toString: b } = true 对象解构 形式：const { x, y } = { x: 1, y: 2 } 默认：const { x, y = 2 } = { x: 1 } 改名：const { x, y: z } = { x: 1, y: 2 } 数组解构 规则：数据结构具有Iterator接口可采用数组形式的解构赋值 形式：const [x, y] = [1, 2] 默认：const [x, y = 2] = [1] 函数参数解构 数组解构：function Func([x = 0, y = 1]) {} 对象解构：function Func({ x = 0, y = 1 } = {}) {} 应用场景 交换变量值：[x, y] = [y, x] 返回函数多个值：const [x, y, z] = Func() 定义函数参数：Func([1, 2]) 提取JSON数据：const { name, version } = packageJson 定义函数参数默认值：function Func({ x = 1, y = 2 } = {}) {} 遍历Map结构：for (let [k, v] of Map) {} 输入模块指定属性和方法：const { readFile, writeFile } = require(&quot;fs&quot;) ** 重点难点 ** 匹配模式：只要等号两边的模式相同, 左边的变量就会被赋予对应的值 解构赋值规则：只要等号右边的值不是对象或数组, 就先将其转为对象 解构默认值生效条件：属性值严格等于undefined 解构遵循匹配模式 解构不成功时变量的值等于undefined undefined和null无法转为对象, 因此无法进行解构 基本用法基本用法例子常规赋值: 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 1234567891011let [foo, [[bar], baz]] = [1, [[2], 3]];//foo : 1 bar : 2 baz : 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];//third : &quot;baz&quot;let [x, , y] = [1, 2, 3];//x : 1 y : 3let [head, ...tail] = [1, 2, 3, 4];//head : 1 tail : [2, 3, 4]//...tail是扩展运算符,它会捕获数组中剩余的所有元素并将它们作为一个新数组赋值给taillet [x, y, ...z] = ['a'];//x : &quot;a&quot; y : undefined z : []//y没有匹配到字符,默认值为undefined 结构不成功: 12let [foo] = [];let [bar, foo] = [1]; 不完全结构: 1234let [x, y] = [1, 2, 3];//x : 1 y : 2 let [a, [b], d] = [1, [2, 3], 4];//a : 1 b : 2 d : 4//等号左边的模式, 只匹配一部分的等号右边的数组。这种情况下, 解构依然可以成功。 如果等号的右边不是数组（或者严格地说, 不是可遍历的结构）, 那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = {}; 上面的语句都会报错, 因为等号右边的值, 要么转为对象以后不具备 Iterator 接口（前五个表达式）, 要么本身就不具备 Iterator 接口（最后一个表达式）。 对于 Set 结构, 也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // &quot;a&quot; 事实上, 只要某种数据结构具有 Iterator 接口, 都可以采用数组形式的解构赋值。 1234567891011function* fibs() { let a = 0; let b = 1; while (true) { yield a; [a, b] = [b, a + b]; }}let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中, fibs是一个 Generator 函数, 原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 默认值1234//解构赋值允许指定默认值。let [foo = true] = [];//foo = true 此时空数组,严格等于undefinedlet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===）, 判断一个位置是否有值。所以, 只有当一个数组成员严格等于undefined, 默认值才会生效。 如果默认值是一个表达式, 那么这个表达式是惰性求值的, 即只有在用到的时候, 才会求值。 12function f() { console.log('aaa');}let [x = f()] = [1]; 上述代码实际运行: 123let x;if ([1] === undefined) { x = f()} else { x = [1]; } 默认值可以引用解构赋值的其他变量, 但该变量必须已经声明。 12let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 连续赋值解构+重命名有一个对象 person 包含多个属性，我们可以使用解构赋值同时给新的变量名： 123456789101112const person = { firstName: 'John', lastName: 'Doe', age: 30};// 进行解构赋值并重命名const { firstName: name, lastName: surname, age } = person;console.log(name); // 输出: Johnconsole.log(surname); // 输出: Doeconsole.log(age); // 输出: 30 对象的赋值结构基本用法解构不仅可以用于数组, 还可以用于对象。 1let { foo, bar } = { foo: 'aaa', bar: 'bbb' };//foo = &quot;aaa&quot;; bar = &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的, 变量的取值由它的位置决定；而对象的属性没有次序, 变量必须与属性同名, 才能取到正确的值 12let { bar, foo } = { foo: 'aaa', bar: 'bbb' };//foo = &quot;aaa&quot; ; bar = &quot;bbb&quot; 属性的次序，不影响取值let { baz } = { foo: 'aaa', bar: 'bbb' };//baz = undefined 如果解构失败, 变量的值等于undefined。 12345// 例一let { log, sin, cos } = Math;//将Math对象的对数、正弦、余弦三个方法, 赋值到对应的变量上// 例二const { log } = console;//将console.log赋值到log变量。log('hello') // hello 如果变量名与属性名不一致, 必须取别名 1234let { foo: baz } = { foo: 'aaa', bar: 'bbb' };//baz = &quot;aaa&quot;let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;//f = 'hello' ; l = 'world' 对象的解析实际是下面的简写: 1let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };//对象的解构赋值的内部机制, 是先找到同名属性, 然后再赋给对应的变量。真正被赋值的是后者, 而不是前者。 与数组一样, 解构也可以用于嵌套结构的对象 1234567let obj = { p: ['Hello', { y: 'World' }]};let { p: [x, { y }] } = obj;//x == &quot;Hello&quot;//y == &quot;World&quot; 这时p是模式, 不是变量, 因此不会被赋值。如果p也要作为变量赋值, 可以写成下面这样。 12345678let obj = { p: [ 'Hello', { y: 'World' }]};let { p, p: [x, { y }] } = obj;//x == &quot;Hello&quot;//y == &quot;World&quot;//p == [&quot;Hello&quot;, {y: &quot;World&quot;}] 另一个例子: 12345678910const node = { loc: { start: { line: 1, column: 5 } }};let { loc, loc: { start }, loc: { start: { line }} } = node;//line == 1//loc == Object {start: Object}//start == Object {line: 1, column: 5} 上面代码有三次解构赋值, 分别是对loc、start、line三个属性的解构赋值。注意, 最后一次对line属性的解构赋值之中, 只有line是变量, loc和start都是模式, 不是变量。 下面是嵌套赋值的例子。–&gt;注意:外部包着一层(): 123456let obj = {};let arr = [];({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });//因为 JavaScript 引擎会将`{x}`理解成一个代码块, 从而发生语法错误。`只有不将大括号写在行首`, 避免 JavaScript 将其解释为代码块, 才能解决这个问题。//obj == {prop:123}//arr == [true] 如果解构模式是嵌套的对象, 而且子对象所在的父属性不存在, 那么将会报错。 12// 报错let {foo: {bar}} = {baz: 'baz'}; 上面代码中, 等号左边对象的foo属性, 对应一个子对象。该子对象的bar属性, 解构时会报错。原因很简单, 因为foo这时等于undefined, 再取子属性就会报错。 对象的解构赋值可以取到继承的属性。 12345const obj1 = {};const obj2 = { foo: 'bar' };Object.setPrototypeOf(obj1, obj2);//Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 nullconst { foo } = obj1;foo // &quot;bar&quot; 上面代码中, 对象obj1的原型对象是obj2。foo属性不是obj1自身的属性, 而是继承自obj2的属性, 解构赋值可以取到这个属性。 默认值对象的解构也可以指定默认值。 1234567var {x = 3} = {};//x == 3var {x, y = 5} = {x: 1};//x == 1//y == 5var {x: y = 3} = {};//y == 3var {x: y = 3} = {x: 5};//y == 5var { message: msg = 'Something went wrong' } = {};//msg == &quot;Something went wrong&quot; 默认值生效的条件是, 对象的属性值严格等于undefined。 12var {x = 3} = {x: undefined};//x == 3var {x = 3} = {x: null};//x == null 上面代码中, 属性x等于null, 因为null与undefined不严格相等 注意点（1）如果要将一个已经声明的变量用于解构赋值, 必须非常小心。 1234// 错误的写法let x;{x} = {x: 1};// SyntaxError: syntax error JavaScript 引擎会将`{x}`理解成一个代码块, 从而发生语法错误。`只有不将大括号写在行首`, 避免 JavaScript 将其解释为代码块, 才能解决这个问题。 123// 正确的写法let x;({x} = {x: 1}); （2）解构赋值允许等号左边的模式之中, 不放置任何变量名。因此, 可以写出非常古怪的赋值表达式。 123({} = [true, false]);({} = 'abc');({} = []); 上面的表达式虽然毫无意义, 但是语法是合法的, 可以执行。 （3）由于数组本质是特殊的对象, 因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let {0 : first, [arr.length - 1] : last} = arr;//first == 1//last == 3 字符串的赋值解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true 上面代码中, 数值和布尔值的包装对象都有toString属性, 因此变量s都能取到值。 解构赋值的规则是, 只要等号右边的值不是对象或数组, 就先将其转为对象。由于undefined和null无法转为对象, 所以对它们进行解构赋值, 都会报错。 12let { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError","link":"/2024/08/20/ECMASript%206/"},{"title":"English","text":"define 简单句简单句的核心（主谓宾）简单句核心构成谓语分类 实义 不及物动词（动作能由主语独立完成）vi—主谓 及物动词（动作不能由主语独立完成）vt 主谓宾 主谓双宾语 主谓宾补 The spooks call it &quot;open source intelligence&quot; 无实义 主系（联系作用）表 系动词 解释 be动词 只有单独使用的时候才是 get become turn go grow 变得 look sound smell taste fell 感官动词 seem apppear/keep remain/prove 好像 保持 简单句核心变化谓语动词时态 一般时态 一般过去时：谓语动词–did 一般现在时：谓语动词-do/does 一般将来时：谓语动词-will do am/is/are going to do (现在的将来要发生的事情) 过去将来时：谓语动词-would do was/were going to do (过去的将来要发生的事情，一般前面有个过去时共同出现) 进行时态 过去进行时：谓语动词-was/were doing 现在进行时：谓语动词-am/is/are doing 将来进行时：谓语动词-will be doing 完成时态：一件事情完成的结果 - have done（1全部完成 可以和一般过去时互换 2部分完成） 过去完成时：谓语动词-had done （过去之前发生的事情） By 2020 they had finished 30% of the research. 现在完成时：谓语动词-have/has done(现在之前发生的事情) For the most part,the reponse has been favorable 将来完成时：谓语动词-will have done Relaxation will be in front of smell-television, and digital age will have arrived. 完成进行时 ：某个时间之前，强调一件事情进行的过程 现在完成进行时：谓语动词-have/has been doing 角度相同 表示之前 表示之前 两种时态 have/has done have/has been doing 强调不同 前调结果（做完与否都可以）We have not won the match 强调过程We have been working hard for several months 过去完成进行时：had been doing 将来完成进行时：will have been doing 谓语动词情态 情态动词+动词原型 谓语动词最多只有现在时，过去时两种时态 现在时 过去时 must — can could will would shall should may might 使用过去时可以使预期更加委婉 情态动词的人称变化无 情态动词变否定：直接加not，变疑问：谓语动词提前 情态动词表示情态 we must also act with caution. 情态动词表示推测 Such searchs can take years 三种时态 情态动词+do 情态动词+be doing 情态动词+have done 其他情态动词词组 have to ought to 谓语动词语态主动语态（主语是动作发出者） 被动语态（主语是动作接收者） 被动语态的构成：be（被动的时间）+ done（被动的动作） 被动语态和时态的结合： 意识 例子 这些评论家过去被遗忘 These critics were forgotten. 这些评论家现在被遗忘 These critics are forgotten. 这些评论家现在的将来被遗忘 These critics will be forgotten. 这些评论家过去的将来被遗忘 These critics would be forgotten. 这些评论家现过去正在被遗忘 These critics were being forgotten. 这些评论家现在正在被遗忘 These critics are being forgotten. 这些评论家过去已经被遗忘 These critics had been forgotten. 这些评论家现在已经被遗忘 These critics have been forgotten. 否定 实义动词变否定 do/does/did +not + 动词原形 助动词情态动词变否定 助动词和情态动词+not 如果同时有两个动词否定not放到第一个动词后面 each animal feels it is not being cheated. 强调do/does/did +动词原形 Although the figure may vary,analysts do agree on another matter 技巧（通过谓语动词切分句子） 抓住谓语动词，抓住句子最核心的表述动作和内容 通过定位谓语动词，找到复杂多变的主语 通过谓语动词的数量，判断长难句中包含几件事情 The same dramatic technological changes that have provided marketers with more(and more deverse) communications choices have also increased the risk that passionate consumers will voice their opinions in quicker,more visible,and much more damaging ways. 主语/宾语/表语的变化名词代词The process is nature selection. 非谓语动词doing(谓语动词只能一个，非谓语动词可以多个) 有动词后再加动词使用非谓语 Suffering is ineviteable.(作主语) Americans stopped takeing prosperity for granted.(做宾语) 非谓语动词 to doto decide is to kill off all possibilities but one(主语) It take sb. some to do sth.（it形式主语，to do主语） They may then decide to go elsewhere.(宾语) The decisions made it more difficult for states to collect sales tax on certain online puerchases. 使用it做形式宾语，句子放在末尾：句子后有补语或者句子过长 The trick is to direct these funds better.(表语) 并列多个从句Science and technology would cure all the ill of humanity. 并列连词 表达含义 and 和 both … and 和 not only but also 不但而且 选择连词 含义 or 或者（二选一） either or 或者（同上） neither nor 既不也不（两者都不选） 简单句扩展","link":"/2023/06/12/English/"},{"title":"Flask实战-QA平台","text":"Flask 基本平台搭建QA（项目名称） blueprint auth.py(作者蓝图,关于作者的视图) qa.py(问答蓝图) static(静态文件) template(网页模板) app.py(主程序) config.py(数据配置文件,防止相互引用) exts.py(扩展) models.py(模型文件) 1234567891011121314151617181920212223app.pyfrom flask import Flaskimport configfrom exts import dbfrom models import UserModelfrom blueprints.qa import bp as qa_bpfrom blueprints.auth import bp as auth_bpapp = Flask(__name__)# 绑定配置文件app.config.from_object(config)db.init_app(app)# 将引入的blueprint绑定app.register_blueprint(qa_bp)app.register_blueprint(auth_bp)@app.route(&quot;/&quot;)def hell(): return &quot;hello&quot;if __name__ == &quot;__main&quot;: app.run() 12345678910qa.pyfrom flask import Blueprint# 问答网页在首页,前缀只需要根路径bp = Blueprint(&quot;qa&quot;,__name__,url_prefix=&quot;/&quot;)@bp.route(&quot;/&quot;)def index(): pass 12345678910auth.pyfrom flask import Blueprint# /authbp = Blueprint(&quot;auth&quot;,__name__,url_prefix=&quot;/auth&quot;)@bp.route(&quot;/login&quot;)def login(): pass 1234567modeles.pyfrom exts import dbclass UserModel(db.model): pass 123456exts.py# 扩展插件from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() User模型创建现在models中设置好 123456789101112models.pyfrom exts import dbfrom datetime import datetimeclass UserModel(db.Model): __tablename__ = &quot;user&quot; id = db.Column(db.Integer,primary_key = True,autoincrement=True) username = db.Column(db.String(100),nullable = False) password = db.Column(db.String(100), nullable=False) email = db.Column(db.String(100), nullable=False,unique = True) # 账号加入时间 join_time = db.Column(db.DateTime,default = datetime.now) 在config.py中设置好数据库连接信息 12345678910111213# MySQl所在的主机名HOSTNAME = &quot;127.0.0.1&quot;#MySQl监听的端口号PORT = &quot;3306&quot;#连接MySQl的用户名是用户自己设置的USERNAME = &quot;root&quot;#连接数据库的密码PASSWORD = &quot;1111&quot;# 数据库中创建的数据库名称DATABASE = &quot;qa&quot;DB_URI = &quot;mysql+pymysql://{}:{}@{}:{}/{}?charset=utf8mb4&quot;.format(USERNAME,PASSWORD,HOSTNAME,PORT,DATABASE)SQLALCHEMY_DATABASE_URI = DB_URI 然后在app.py中操作flask_migrate连接和更新数据库 网页文件和静态文件准备注册功能邮箱验证功能安装flask邮箱支持 1pip install falsk-mail 表单验证","link":"/2023/11/15/Flask%E5%AE%9E%E6%88%98-QA%E5%B9%B3%E5%8F%B0/"},{"title":"Hexo博客搭建","text":"安装nodejs 官网下载 利用nodejs的包管理器npm安装国内镜像cnpm 1sudo npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm安装hexo 1sudo cnpm install -g hexo-cli 创建一个文件夹，然后进入文件夹中初始化hexo 1hexo init 安装hexo部署插件 1cnpm install --save hexo-deployer-git hexo基本命令 1234hexo new &quot;postname&quot; 创建新的博文hexo s 本地启动博客预览hexo clean 清除临时文件hexo g 生成网页文件 Hexo使用主题（例：cactus） 主题的样本网页网址：https://www.takuzen.me/hugo-theme-cactus/ 主题的github：GitHub - probberechts/hexo-theme-cactus. 主题的详细配置见文章 标准new post的开头 123456title: Hexo博客搭建tags:- hexo搭建配置categories:- Hexodate: 2022-01-02 13:08:14 md格式参见 Markdown 教程 | 菜鸟教程","link":"/2022/01/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"JSON","text":"JSON（JavaScript Object Notation，js对象表示法）就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JSON分类 对象{} 数组[] JSON中允许的值 字符串 数值 布尔值 null 对象 数组 1234// json对象可以包含json数组var obj1 = '{&quot;arr&quot;:[1,2,3]}';// json数组可以包含json对象var obj2 = '[{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 1000,&quot;gender&quot;: &quot;男&quot;},{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 1000,&quot;gender&quot;: &quot;男&quot;}]'; JSON和JS间转换在 JS 中，为我们提供了一个工具类，就叫JSON 这个对象可以帮助我们将一个JSON转换为 JS 对象，也可以将一个 JS 对象转换JSON JSON.parse()可以将JSON字符串转换为 JS 中的对象 需要一个JSON字符串作为参数，会将该字符串转换为 JS 对象并返回 12345678910111213var jsonObj = JSON.parse(jsonObjStr);console.log(typeof jsonObj); // objectconsole.log(jsonObj); // { name: &quot;孙悟空&quot;, age: 1000, gender: &quot;男&quot; }console.log(jsonObj.name); // 孙悟空console.log(jsonObj.age); // 1000console.log(jsonObj.gender); // 男var jsonArr = JSON.parse(jsonArrStr);console.log(typeof jsonArr); // objectconsole.log(jsonArr); // (5) [ 1, 2, 3, &quot;hello&quot;, true ]console.log(jsonArr[0]); // 1console.log(jsonArr[3]); // helloconsole.log(jsonArr[4]); // true JSON.stringify()可以将一个 JS 对象转换为JSON字符串 需要一个 JS 对象作为参数，会返回一个JSON字符串 12345678var obj2 = { name: &quot;猪八戒&quot;, age: 2000, gender: &quot;男&quot;};var obj2JSONStr = JSON.stringify(obj2);console.log(typeof obj2JSONStr); // stringconsole.log(obj2JSONStr); // {&quot;name&quot;:&quot;猪八戒&quot;,&quot;age&quot;:2000,&quot;gender&quot;:&quot;男&quot;} JSON对象在 IE7 及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 eval()这个函数可以用来执行一段字符串形式的 JS 代码，并将执行结果返回 12var str = 'alert(&quot;hello&quot;)';eval(str); 如果使用eval()执行的字符串中含有{}，它会将{}当成是代码块 12var jsonObjStr = '{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 1000,&quot;gender&quot;: &quot;男&quot;}';eval(jsonObjStr); 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() 123var jsonObjStr = '{&quot;name&quot;: &quot;孙悟空&quot;,&quot;age&quot;: 1000,&quot;gender&quot;: &quot;男&quot;}';var result = eval(&quot;(&quot; + jsonObjStr + &quot;)&quot;);console.log(result); // {age: 1000, gender: &quot;男&quot;, name: &quot;孙悟空&quot;} eval()这个函数的功能很强大，可以直接执行一个字符串中的 JS 代码 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 兼容IE7如果需要兼容 IE7 及以下的JSON操作，则可以通过引入一个外部的 JS 文件来处理 1&lt;script src=&quot;js/json2.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 然后在 IE7 浏览器中调用JSON相关方法就不会报错了 1console.log(JSON.parse(jsonObjStr)); // {age: 1000, gender: &quot;男&quot;, name: &quot;孙悟空&quot;}","link":"/2024/05/31/JSON/"},{"title":"JS作用域","text":"JS 作用域 全局作用域直接编写在script标签中的JS代码，都在全局作用域 全局作用域在页面打开时创建，在页面关闭时销毁 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，由浏览器创建，可以直接使用 在全局作用域中： 创建的变量都会作为window对象的属性保存 创建的函数都会作为window对象的方法保存 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到 123456var a = 3;console.log(window.a); //3console.log(a); //3b = 3;console.log(b); //3 变量的声明提前使用var关键字声明的变量，会在所有的代码执行之前被声明 但是如果声明变量时不适用var关键字，则变量不会被声明提前 1234567891011121314// 1、变量的声明提前console.log(&quot;a = &quot; + a); // a = undefinedvar a = &quot;abc&quot;;// ======相当于======var a;console.log(&quot;a = &quot; + a); // a = undefineda = &quot;abc&quot;;// 2、没有变量的声明提前，报错console.log(&quot;b = &quot; + b); // UncaughtReferenceError: b is not definedb = &quot;abc&quot;;// ======相当于======console.log(&quot;b = &quot; + b); // UncaughtReferenceError: b is not definedwindow.b = &quot;abc&quot;; 函数的声明提前使用函数声明形式创建的函数function 123函数(){ 语句...} 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数 12345678910fun1(); // fun1...fun2(); // UncaughtTypeError: fun2 is not a function// 函数声明，会被提前创建function fun1(){ console.log(&quot;fun1...&quot;);}// 函数表达式，不会被提前创建（变量会被提前声明，但函数不会被提前创建）var fun2 = function(){ console.log(&quot;fun2...&quot;);} 函数作用域调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的 在函数作用域中可以访问到全局作用域的变量 在全局作用域中无法访问到函数作用域的变量 当在函数作用域操作一个变量时，它会先在自身作用域中寻找， 如果有就直接使用 如果没有则向上一级作用域中寻找，直到找到全局作用域 如果全局作用域中依然没有找到，则会报错 在函数中要访问全局变量可以使用window对象 12345678910111213141516var a = 10;function fun2(){ var a = 20; function fun3(){ var a = 30; console.log(&quot;fun3 ==&gt; a = &quot; + a); // fun3 ==&gt; a = 30 } fun3(); console.log(&quot;fun2 ==&gt;a = &quot; + a); // fun2 ==&gt;a = 20 console.log(&quot;a = &quot; + window.a); // a = 10}fun2(); console.log(&quot;a = &quot; + a); // a = 10 在函数作用域也有声明提前的特性，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明 函数声明也会在函数中所有的代码执行之前执行 123456789101112// 在函数作用域也有声明提前的特性，使用`var`关键字声明的变量，会在函数中所有的代码执行之前被声明function func1(){ console.log(a); var a = &quot;func1&quot;; // 函数声明也会在函数中所有的代码执行之前执行 func2(); // fun2... function func2(){ console.log(&quot;fun2...&quot;); }}func1(); // undefined 在函数中，不适用var声明的变量都会成为全局变量 123456789101112131415// 函数声明且调用func3();function func3() { a = 4;}console.log(&quot;a = &quot; + window.a); // a = 4console.log(&quot;a = &quot; + window[&quot;a&quot;]); // a = 4console.log(&quot;a = &quot; + a); // a = 4// 函数声明不调用function func4() { b = 4;}console.log(&quot;b = &quot; + window.b); // b = 4console.log(&quot;b = &quot; + window[&quot;b&quot;]); // b = 4console.log(&quot;b = &quot; + b); // UncaughtReferenceError: b is not defined 定义形参就相当于在函数作用域中声明了变量 123456var e = 10;function fun5(e){ console.log(e);}fun5(); // undefinedfun5(55); // 55 this解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this this指向的是一个对象，这个对象我们称为函数执行的上下文对象 根据函数的调用方式的不同，this会指向不同的对象 以函数的形式调用时，this永远都是window 以方法的形式调用时，this就是调用方法的那个对象 123456789101112// - 以函数的形式调用时，`this`永远都是`window`function fun(){ console.log(this.name);}var name = &quot;ddd&quot;; // dddfun();// - 以方法的形式调用时，`this`就是调用方法的那个对象var obj = { name: &quot;孙悟空&quot;, sayName: fun}obj.sayName(); // 孙悟空","link":"/2024/03/28/JS%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"JS函数","text":"JS 函数 函数的简介使用函数声明来创建一个函数，函数也是一个对象 12345function 函数名([形参1, 形参2...形参N]) { 语句...}// 调用函数函数名(); 使用函数表达式（匿名函数）来创建一个函数 12345var 函数名 = function([形参1, 形参2...形参N]) { 语句...};// 调用函数函数名(); 函数的参数定义一个用来求两个数和的函数 可以在函数的()中来指定一个或多个形参（形式参数）多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量 在调用函数时，可以在()中指定实参（实际参数） 调用函数时解析器不会检查实参的类型。所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查 调用函数时，解析器也不会检查实参的数量，多余实参不会被赋值。如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined 1234567function sum(a,b,c){ document.write(a+b+c)}sum(1,2,3);//6sum(3,4);//Nan 函数的返回值可以使用return来设置函数的返回值语法：return 值 return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果 在函数中return后的语句都不会执行 如果return语句后不跟任何值，就相当于返回一个undefined；如果函数中不写return，则也会返回undefined return后可以跟任意类型的值 实参可以是任意的数据类型，也可以是一个对象。当我们的参数过多时，可以将参数封装到一个对象 12345678910111213function sayHello(o){ console.log(&quot;我是&quot; + o.name + &quot;，今年我&quot; + o.age + &quot;岁了，我是一个&quot; + o.gender + &quot;人，我住在&quot; + o.address);} var obj = { name: &quot;孙悟空&quot;, age: 1000, gender: &quot;男&quot;, address: &quot;花果山&quot;};sayHello(obj); // 我是孙悟空，今年我1000岁了，我是一个男人，我住在花果山 实参可以是一个对象，也可以是一个函数 1234567891011function calCirc(radius) { return Math.PI * Math.pow(radius, 2);}function fun(a){ console.log(&quot;a = &quot; + a);}fun(calCirc); // a = function calCirc(radius) {// return Math.PI * Math.pow(radius, 2);// }fun(calCirc(10)); // a = 314.1592653589793 函数也是一个对象，特殊在其具有功能 break、continue、return对比 break可以退出当前的循环 continue用于跳过当次循环 return可以结束整个函数 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数 立即执行函数往往只会执行一次 123(function(){ document.write('立即执行函数')})();","link":"/2024/03/27/JS%E5%87%BD%E6%95%B0/"},{"title":"JS基础","text":"JS编写位置，JS注释，字面量变量，标识符，数据类型，强制类型转换 JS编写位置可以将js代码编写到标签的onclick属性中当我们点击按钮时，js代码才会执行 1&lt;button onclick=&quot;alert('\\&quot;'Fuck! Do not touch me!')&quot;&gt;&lt;/button&gt; 可以将js代码Ⅰ写在超链接的href属性中，这样当点击超链接时，会执行js代码 1&lt;a href=&quot;javascript:alert(\\&quot;What's up, man?\\&quot;)&quot;&gt;Try to click me&lt;/a&gt; 虽然可以写在标签的属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用 可以将js代码编Ⅱ写到script标签 123&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;I'm inner script.&quot;);&lt;/script&gt; 可以将js代码Ⅲ写到外部js文件中&lt;/strong&gt;，然后通过script`标签引入 1&lt;script src=&quot;/js/script.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 如果需要则可以在创建一个新的script标签用于编写内部代码 JS注释多行注释: 12345/* 多行注释... 多行注释... 多行注释...*/ 单行注释: 1// 单行注释 注释中的内容不会被执行，但是可以在源代码中查看 注意点 JS中严格区分大小写 JS中每一条语句以分号;结尾 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 JS中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 字面量与变量#字面量字面量，都是一些不可改变的值 字面量都是可以直接使用，但是我们一般都不会直接使用字面量 #变量变量可以用来保存字面量，而且变量的值是可以任意改变的变量更加方便我们使用 所以在开发中都是通过变量去保存一个字面量，而很少直接使用字面量 可以通过变量对字面量进行描述 1234567891011// 声明变量: 在js中使用var关键字来声明一个变量var a;// 为变量赋值a = 123;a = 456;a = 123124223423424;// 声明和赋值同时进行var b = 789;var c = 0;var age = 80;console.log(age); 标识符在JS中所有的可以由我们自主命名的都可以称为是标识符 例如：变量名、函数名、属性名都属于标识符 命名一个标识符时需要遵守如下的规则： 标识符中可以含有字母、数字、_、$ 标识符不能以数字开头 标识符不能是ES中的关键字或保留字 标识符一般都采用驼峰命名法 首字母小写，每个单词的开头字母大写，其余字母小写(例子:helloWorld) 关键字 if else do while for break continue try catch finally throw true false function return switch case null typeof instanceof new var void in with default debugger delete this 保留字 class enum extends super const export import implements let private public yield interface package protected static 其他不建议使用的标识符 boolean byte short char int long float double String Boolean Number Object Date Array Math Error SyntaxError EvalError TypeError URIError RangeError ReferenceError encodeURI decodeURI parselnt parseFloat NaN isNaN undefined transient throws native goto eval JSON Infinity arguments isFinite volatile abstract RegExp Function synchronize final encodeURICOmponent decodeURIComponent JS底层保存标识符时实际上是采用的Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 数据类型数据类型指的就是字面量的类型，在JS中一共有六种数据类型 基本数据类型 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 引用类型 Object 对象：任意的对象 Array 数组：一种特殊的对象（可以执行） Function 函数：一种特殊的对象（数值下标，内部数据是有序的） 数据类型的判断方法： typeof(返回数据类型的字符串): 可以判断: undefined/数字/字符串/布尔值/function 不能判断: null和object ，array不能相互判断，返回的都是object 使用typeof(null)返回'object'的原因:csdn链接 instanceof: 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false,详见[js函数高级] 判断三个对象的是否对应具体类型 123funcArg instanceof Function //trueobjArg instanceof Object //truearrArg instanceof Array //true ===(数值和类型都相等，undefined和null只有一个值): 可以判断:undefined,null String字符串在JS中，字符串需要使用引号引起来，使用单引号或双引号都可以，但不要混合使用 同一种引号不能嵌套，双引号不能放双引号，单引号不能放单引号 在字符串中我们可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\进行转义 \\&quot;表示&quot; \\'表示' \\n表示换行 \\t制表符 \\\\表示\\ Number数值在JS中，所有的数值都是Number类型，包括整数和浮点数（小数） 可以使用一个运算符typeof，来检查一个变量的类型。语法：typeof 变量 检查字符串时，会返回string 检查数值时，会返回number MAX_VALUE JS中可以表示的数字的最大值 Number.MAX_VALUE=1.7976931348623157e+308 如果使用Number表示的数字超过了最大值，则会返回一个Infinity 12var a = Number.MAX_VALUE * Number.MAX_VALUE;console.log(a); // Infinity MIN_VALUE 大于0的最小值 Number.MIN_VALUE=5e-324 12var a = Number.MIN_VALUE * Number.MIN_VALUE;console.log(a); // 0 Infinity Infinity表示正无穷 -Infinity 表示负无穷 使用typeof检查，Infinity会返回Number 12var a = Number.MAX_VALUE * Number.MAX_VALUE;console.log(typeof a); // number NaN 123NaN是一个特殊的数字，表示'Not A Number'var a = 'abc' * 'def';console.log(a); // NaN 使用typeof检查一个NaN也会返回number 12var a = 'abc' * 'def';console.log(typeof a); // number 运算精度 在JS中整数的运算基本可以保证精确 如果使用JS进行浮点运算，可能得到一个不精确的结果 12var a = 0.1 + 0.2;console.log(a); // 0.30000000000000004 所以千万不要使用JS进行对精确度要求比较高的运算 Boolean布尔值布尔值只有两个，主要用来做逻辑判断 true表示真 false表示假 使用typeof检查一个布尔值时，会返回boolean NullNull类型的值只有一个，就是null null这个值专门用来表示一个为空的对象 使用typeof检查一个null值时，会返回object 123var a3 = null;console.log(a3); // nullconsole.log(typeof a3); // object 初始值赋值为null,表明赋值对象为对象;回收对象时候将对象赋值为null. UndefinedUndefined（未定义）类型的值只有一个，就是undefind 当声明一个变量，但是并不给变量赋值时，它的值就是undefined 使用typeof检查一个undefined时，也会返回undefined 123var a4;console.log(a4); // undefindconsole.log(typeof a4); // undefind 指将一个数据类型强制转换为其他的数据类型 类型转换主要指，将其他的数据类型，转换为String、Number、Boolean 其他数据类型转换为String方式一：调用被转换数据类型的toString()方法该方法不会影响到原变量，它会将转换的结果返回 12345// Number转换为Stringvar a1 = 123;var b1 = a1.toString();console.log(typeof a1); // numberconsole.log(typeof b1); // string 但是注意：null和undefined这两个值没有toString()，如果调用他们的方法，会报错 1234567// Null转换为Stringvar a3 = null;var b3 = a3.toString(); // UncaughtTypeError: Cannot read property 'toString' of null// Undefined转换为Stringvar a4 = undefined;var b4 = a4.toString(); // UncaughtTypeError: Cannot read property 'toString' of undefined 方式二：调用String()函数，并将被转换的数据作为参数传递给函数使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法 但是对于null和undefined，就不会调用toString()方法，而是将 null直接转换为&quot;null&quot; undefined 直接转换为&quot;undefined&quot; 1234567891011121314151617181920// Number转换为Stringvar a1 = 123;var b1 = String(a1);console.log(typeof a1); // numberconsole.log(typeof b1); // string// Boolean转换为Stringvar a2 = true;var b2 = String(a2);console.log(typeof a2); // booleanconsole.log(typeof b2); // string// Null转换为Stringvar a3 = null;var b3 = String(a3);console.log(typeof a3); // objectconsole.log(typeof b3); // string// Undefined转换为Stringvar a4 = undefined;var b4 = String(a4);console.log(typeof a4); // undefinedconsole.log(typeof b4); // string 其他数据类型转换为Number方式一：使用Number()函数 字符串 –&gt; 数字 如果是纯数字的字符串，则直接将其转换为数字 如果字符串中有非数字的内容，则转换为NaN 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0 123456789101112131415161718// **转换方式一：使用Number()函数**// 纯数字的字符串var a1 = '123'; a1 = Number(a1);console.log(typeof a1); // numberconsole.log(a1); // 123// 非数字的内容// var a2 = 'abc'; var a2 = undefined;a2 = Number(a2);console.log(typeof a2); // numberconsole.log(a2); // NaN // 空串// var a3 = ' '; var a3 = null; a3 = Number(a3); console.log(typeof a3); // numberconsole.log(a3); // 0 布尔 –&gt; 数字 true转成1 false转成0 12345678var a4 = true;a4 = Number(a4);console.log(typeof a4); // numberconsole.log(a4); // 1var a5 = false;a5 = Number(a5);console.log(typeof a5); // numberconsole.log(a5); // 0 方式二：专门用来对付字符串 parseInt()把一个字符串转换为一个整数：可以将一个字符串中的有效整数部分取出来，然后转换为Number parseFloat()把一个字符串转换为一个浮点数：可以将一个字符串中的有效小数部分取出来，然后转换为Number 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String，然后再操作 123456789101112131415161718192021var a1 = &quot;123&quot;;a1 = parseInt(a1);console.log(typeof a1); // numberconsole.log(a1); // 123var a2 = &quot;123.456&quot;;a2 = parseInt(a2);console.log(typeof a2); // numberconsole.log(a2); // 123var a3 = &quot;123px&quot;;a3 = parseInt(a3);console.log(typeof a3); // numberconsole.log(a3); // 123 // var a4 = null;// var a4 = undefined;// var a4 = '';// var a4 = 'abc';// var a4 = true;var a4 = false;a4 = parseInt(a4);console.log(typeof a4); // numberconsole.log(a4); // NaN 其他数据类型转换为Boolean方式一：使用Boolean()函数 数字-—-&gt;布尔 除了0和NaN，其余的都是true 字符串-—-&gt;布尔 除了空串，其余的都是true null和undefined都会转换为false 对象也会转换为true 12345678910111213141516171819202122232425// - 数字-—-&gt;布尔// - 除了`0`和`NaN`，其余的都是`true`// var a1 = 0;var a1 = NaN;a1 = Boolean(a1);console.log(a1); // falsevar a2 = 123;a2 = Boolean(a2);console.log(a2); // true// - 字符串-—-&gt;布尔// - 除了空串，其余的都是`true`var a3 = &quot;123&quot;;a3 = Boolean(a3);console.log(a3); // truevar a4 = &quot; &quot;;a4 = Boolean(a4);console.log(a4); // truevar a5 = &quot;&quot;;a5 = Boolean(a5);console.log(a5); // false// - `null`和`undefined`都会转换为`false`// var a6 = null;var a6 = undefined;a6 = Boolean(a6);console.log(a6); // false 方式二：隐式类型转换为任意的数据类型做两次非运算，即可将其转换为布尔值（下一节会介绍） 123var a = &quot;123&quot;;var b = !!a;console.log(&quot;a=&quot;+a+&quot;,b=&quot;+b); // a=true,b=true 补充在js中，如果需要表示16进制的数字，则需要以0x开头 如果需要表示8进制的数字，则需要以0开头 如果需要表示2进制的数字，则需要以0b开头，但是不是所有的浏览器都支持 12345678910111213141516171819// 十六进制数字var a = 0x10;console.log(a); // 16a = 0xff;console.log(a); // 255a = 0xCafe;console.log(a); // 51966a = &quot;0x70&quot;;a = parseInt(a,16);console.log(a); // 112// 八进制数字a = 070;console.log(a); // 56a = &quot;070&quot;;a = parseInt(a,8);console.log(a); // 56// 二进制数字a = 0b10;console.log(a); // 2","link":"/2024/03/26/JS%E5%9F%BA%E7%A1%80/"},{"title":"JS数组","text":"JS 数组 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据 1234// 创建数组对象var arr=new Array();// 使用typeof检查一个数组时，会返回objectconsole.log(typeof arr); // object 向数组中添加元素语法：数组[索引] = 值 123arr[0] = 10;arr[1] = 33;arr[2] = 22; 读取数组中的元素语法：数组[索引] 如果读取不存在的索引，不会报错而是返回undefined 12console.log(arr[2]); // 22console.log(arr[3]); // undefined 获取数组的长度可以使用length属性来获取数组的长度（元素的个数）语法：数组.length 对于连续的数组，使用length可以获取到数组的长度（元素的个数） 对于非连续的数组，使用length会获取到数组的最大的索引 + 1 12345console.log(arr.length); // 3console.log(arr); // {&quot;0&quot;:10,&quot;1&quot;:33,&quot;2&quot;:22,&quot;length&quot;:3}arr[10] = 33;console.log(arr.length); // 11console.log(arr); // {&quot;0&quot;:10,&quot;1&quot;:33,&quot;10&quot;:33,&quot;2&quot;:22,&quot;length&quot;:11} 尽量不要创建非连续的数组 修改数组的长度 如果修改的length大于原长度，则多出部分会空出来 如果修改的length小于原长度，则多出的元素会被删除 123456arr.length = 100;console.log(arr.length); // 100console.log(arr); // {&quot;0&quot;:10,&quot;1&quot;:33,&quot;10&quot;:33,&quot;2&quot;:22,&quot;length&quot;:100}arr.length = 2;console.log(arr.length); // 2console.log(arr); // {&quot;0&quot;:10,&quot;1&quot;:33,&quot;length&quot;:2} 创建数组的方式使用字面量创建数组语法：[] 1234var arr1 = [];console.log(arr1); // {&quot;length&quot;:0}console.log(typeof arr1); // objectconsole.log(arr1.length); // 0 使用字面量创建数组时，可以在创建时就指定数组中的元素 123var arr2 = [1,2,3,4,5,10];console.log(arr2); // {&quot;0&quot;:1,&quot;1&quot;:2,&quot;2&quot;:3,&quot;3&quot;:4,&quot;4&quot;:5,&quot;5&quot;:10,&quot;length&quot;:6} console.log(arr2.length); // 6 使用构造函数创建数组使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递 元素之间使用,隔开 123var arr3 = new Array(1,2,3,4,5);console.log(arr3); // {&quot;0&quot;:1,&quot;1&quot;:2,&quot;2&quot;:3,&quot;3&quot;:4,&quot;4&quot;:5,&quot;length&quot;:5} console.log(arr3.length); // 5 字面量和构造函数只有一个数字时的区别 123456// 创建一个数组数组中只有一个元素10var arr4 = [10];// 创建一个长度为10的数var arr5 = new Array(10);console.log(arr4.length); // 1console.log(arr5.length); // 10 数组元素类型数组中存储的可以是数字，字符串，布尔值，null，undefined，对象，数组 还可以是函数 12345678910fun = function(){ return('函数返回值')}arr = [function(){document.write(&quot;hello world&quot;)},function(){alert('this is truth')},fun()]message = arr[2]document.write(message) //函数返回值 数组的方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 toSource() 返回该对象的源代码。 toString() 把数组转换为字符串，并返回结果。 toLocaleString() 把数组转换为本地数组，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数对象的对象的原始值 添加和删除12345678910111213141516171819202122232425orArr = [1,2,3,4];// push()该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度message = orArr.push(5);document.write(message);//5document.write(orArr);//1,2,3,4,5document.write('----');// pop()方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回message2 = orArr.pop();document.write(message2);//5(被删除的元素为5)document.write(orArr);//1,2,3,4document.write('----');// unshift()向数组开头添加一个或多个元素，并返回新的数组长度向前边插入元素以后，其他的元素索引会依次调整message3 = orArr.unshift(0);document.write(message3);//5(添加元素后的数组长度为5)document.write(orArr);//0,1,2,3,4document.write('----');// shift()可以删除数组的第一个元素，并将被删除的元素作为返回值返回message4 = orArr.shift();document.write(message4);//0(被删除的元素为0)document.write(orArr);//1,2,3,4document.write('----'); 操作 添加 删除 末尾操作 push：末尾添加 pop：末尾删除 开头操作 unshift：开头添加 shift：开头删除 切片操作123456789101112131415161718192021222324252627// slice()从某个已有的数组返回选定的元素，可以用来从数组提取指定元素// 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回参数：// 截取开始的位置的索引，包含开始索引// 截取结束的位置的索引，不包含结束索引message5 = orArr.slice(0,2);document.write(message5);//1,2document.write(orArr);//1,2,3,4document.write('----');// splice()删除元素，并向数组添加新元素。可以用于删除数组中的指定元素// 使用splice()会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回// 参数：// 第一个，表示开始位置的索引// 第二个，表示删除的数量message6 = orArr.splice(0,2);document.write(message6);//1,2document.write(orArr);//3,4// 第三个及以后，可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边orArr.splice(0,0,1,2);// document.write(orArr);//1,23,4document.write('----'); slice可以提取数组中指定元素 splice可以删除元素、替换元素、插入元素（功能更强大） 合并，转为string，排序1234567891011121314151617181920212223242526272829// concat()可以连接两个或多个数组，并将新的数组返回// 该方法不会对原数组产生影响message7 = orArr.concat(0,2);document.write(message7);//1,2,3,4,0,2document.write(orArr);//1,2,3,4document.write('----');// join()该方法可以将数组转换为一个字符串// 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回// 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符// 如果不指定连接符，则默认使用,作为连接符var message8 = orArr.join('!');document.write(message8);//1!2!3!4document.write(typeof(message8));//stringdocument.write(typeof(orArr));//objectdocument.write('----');// reverse()该方法用来反转数组（前边的去后边，后边的去前边）// 该方法会直接修改原数组// 可以用来对数组中的元素进行排序// 也会影响原数组，默认会按照Unicode编码进行排序 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序,所以对数字进行排序时，可能会得到错误的结果 可以采用指正排序的现则我们可以在sort()添加一个回调函数，来指定排序规则 sort()： 如果需要升序排列，则返回a - b 如果需要降序排列，则返回b - a 1234567891011arr = ['2', '44', '9', '8', '2', '0'];arr.sort(function(a,b){ // 升序排列 return a - b;});console.log(arr); // [0, 2, 2, 6, 8, 9, 44]arr.sort(function(a,b){ // 降序排列 return b - a;});console.log(arr); // [44, 9, 8, 6, 2, 2, 0] 会对原数组产生影响的方法：push、pop、shift、unshift、splice、reverse、sort 不会对原数组产生影响的方法：slice、concat、join 添加元素的方法：push、unshift、splice 删除元素的方法：pop、shift、splice 替换元素的方法：splice 连接元素的方法：concat、join 排序方法：reverse、sort 数组遍历普通for循环所谓的遍历数组，就是将数组中所有的元素都取出来 12345var arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙悟净&quot;, &quot;白龙马&quot;];// 所谓的遍历数组，就是将数组中所有的元素都取出来for(var i=0;i&lt;arr.length;i++){ console.log(arr[i]);} forEach方法一般我们都是使用for循环去遍历数组，JS中还为我们提供了一个方法，用来遍历数组forEach() 兼容性 这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持该方法 所以如果需要兼容IE8，则不要使用forEach，还是使用for循环来遍历 使用 forEach() 方法需要一个函数作为参数 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数 数组中有几个元素，函数就会执行几次，每次执行时，浏览器会将遍历到的元素 以实参的形式传递进来，我们可以来定义形参，来读取这些内容 参数 浏览器会在回调函数中传递三个参数： 第一个参数，就是当前正在遍历的元素 第二个参数，就是当前正在遍历的元素的索引 第三个参数，就是正在遍历的数组 1234567891011121314151617181920arr.forEach(function(value, index, obj){ console.log(&quot;value = &quot; + value); console.log(&quot;index = &quot; + index); console.log(&quot;obj = &quot; + obj);});例子:var arr = [1,2,3,4]arr.forEach(function(value, index, obj){ document.write(&quot;value = &quot; + value); document.write(&quot;index = &quot; + index); document.write(&quot;obj = &quot; + obj);});/*value = 1 index = 0 obj = 1,2,3,4value = 2 index = 1 obj = 1,2,3,4value = 3 index = 2 obj = 1,2,3,4value = 4 index = 3 obj = 1,2,3,4*/","link":"/2024/03/31/JS%E6%95%B0%E7%BB%84/"},{"title":"JS构造函数和原型对象","text":"JS 作用域 使用工厂方法创建对象123456789101112131415161718192021function createPerson(name, age, gender){ // 创建一个新的对象 var obj=new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function(){ console.log(this.name); }; //将新的对象返回 return obj;}var obj1 = createPerson(&quot;孙悟空&quot;, 1000, &quot;男&quot;);var obj2 = createPerson(&quot;猪八戒&quot;, 3600, &quot;男&quot;);var obj3 = createPerson(&quot;沙悟净&quot;, 10000, &quot;男&quot;);obj1.sayName(); // 孙悟空obj2.sayName(); // 猪八戒obj3.sayName(); // 猪八戒 使用工厂方法创建的对象，使用的构造函数都是Object 所以创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象 构造函数创建一个构造函数，专门用来创建Person对象的构造函数就是一个普通的函数 创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写构造函数 和普通函数的区别就是调用方式的不同 普通函数是直接调用 构造函数需要使用new关键字来调用 123456789function Person(){ console.log(this); // Person{}}// 普通函数var fun = Person();console.log(fun); // undefined// 构造函数var person = new Person();console.log(person); // Person{} 构造函数的执行流程 立刻创建一个新的对象 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象 逐行执行函数中的代码 将新建的对象作为返回值返回 1234567891011121314151617181920212223242526272829function Dog(){}function Person(name, age, gender){ //向对象中添加属性 this.name = name; this.age = age; this.gender = gender; this.sayHello = function(){ console.log(&quot;My'name is &quot; + this.name + &quot;, &quot; + &quot;I'm &quot; + this.age + &quot; years old, &quot; + &quot;and I'm a &quot; + this.gender + &quot;.&quot;); };}var person1 = new Person(&quot;孙悟空&quot;, 1000, &quot;man&quot;);var person2 = new Person(&quot;猪八戒&quot;, 3600, &quot;man&quot;);var person3 = new Person(&quot;沙悟净&quot;, 10000, &quot;man&quot;);var dog = new Dog();person1.sayHello(); // My'name is 孙悟空, I'm 1000 years old, and I'm a man.person2.sayHello(); // My'name is 猪八戒, I'm 3600 years old, and I'm a man.person3.sayHello(); // My'name is 沙悟净, I'm 10000 years old, and I'm a man.console.log(person1); // Person {name: &quot;孙悟空&quot;, age: 1000, gender: &quot;man&quot;, sayHello: ƒ}console.log(person2); // Person {name: &quot;猪八戒&quot;, age: 3600, gender: &quot;man&quot;, sayHello: ƒ}console.log(person3); // Person {name: &quot;沙悟净&quot;, age: 10000, gender: &quot;man&quot;, sayHello: ƒ}console.log(typeof person1); // objectconsole.log(typeof person2); // objectconsole.log(typeof person3); // object 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。 我们将通过一个构造函数创建的对象，称为是该类的实例 使用instanceof可以检查一个对象是否是一个类的实例语法：对象 instanceof 构造函数 如果是则返回true，否则返回false 1234console.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Person); //trueconsole.log(person3 instanceof Person); //trueconsole.log(dog instanceof Person); //false 所有的对象都是Object的后代，所以任何对象和Object进行instanceof检查时都会返回true 1234console.log(person1 instanceof Object); //trueconsole.log(person2 instanceof Object); //trueconsole.log(person3 instanceof Object); //trueconsole.log(dog instanceof Object); //true this的情况： 当以函数的形式调用时，this是window 当以方法的形式调用时，谁调用方法this就是谁 当以构造函数的形式调用时，this就是新创建的那个对象 构造函数修改创建一个Person构造函数 在Person构造函数中，为每一个对象都添加了一个sayName方法，目前我们的方法是在构造函数内部创建的 也就是构造函数每执行一次就会创建一个新的sayName方法也是所有实例的sayName都是唯一的 12345678910function Person(name, age, gender){ this.name = name; this.age = age; this.gender = gender; this.sayHello = function(){ console.log(&quot;My'name is &quot; + this.name + &quot;, &quot; + &quot;I'm &quot; + this.age + &quot; years old, &quot; + &quot;and I'm a &quot; + this.gender + &quot;.&quot;); };} 这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的 这是完全没有必要，完全可以使所有的对象共享同一个方法 将函数定义在全局作用域，虽然节省了空间，但却污染了全局作用域的命名空间 而且定义在全局作用域中也很不安全 原型对象原型prototype我们所创建的每一个函数（不论是普通函数还是构造函数），解析器都会向函数中添加一个属性prototype 123456789101112131415161718192021function Person(){}function MyClass(){}console.log(Person.prototype);// {constructor: ƒ}// constructor: ƒ Person()// arguments: null// caller: null// length: 0// name: &quot;Person&quot;// prototype: {constructor: ƒ}// __proto__: ƒ ()// [[FunctionLocation]]: 09-原型对象.html:8// [[Scopes]]: Scopes[1]// __proto__: Objectconsole.log(Person.prototype == MyClass.prototype); // false 当函数以普通函数的形式调用prototype时，没有任何作用 当函数以构造函数的形式调用prototype时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性 123456var mc1 = new MyClass();var mc2 = new MyClass();var mc3 = new MyClass();console.log(mc1.__proto__ == MyClass.prototype); // trueconsole.log(mc2.__proto__ == MyClass.prototype); // trueconsole.log(mc3.__proto__ == MyClass.prototype); // true 原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象 我们可以将对象中共有的内容，统一设置到原型对象中 12345678// 向MyClass中添加属性aMyClass.prototype.a = &quot;123&quot;;console.log(mc1.a); // 123// 向MyClass中添加方法sayHelloMyClass.prototype.sayHello = function(){alert(&quot;hello&quot;);}mc3.sayHello(); 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用 123mc2.a = &quot;456&quot;;console.log(mc2.a); // 456JAVASCRIPT 复制 全屏 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中 这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 hasOwnProperty1234567891011121314function MyClass(){}MyClass.prototype.name = &quot;I'm prototype's name.&quot;;var mc = new MyClass();mc.age = 18;// 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回trueconsole.log(&quot;name&quot; in mc); // trueconsole.log(&quot;age&quot; in mc); // true// 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性// 使用该方法只有当对象自身中含有属性时，才会返回trueconsole.log(mc.hasOwnProperty(&quot;name&quot;)); // falseconsole.log(mc.hasOwnProperty(&quot;age&quot;)); // trueconsole.log(mc.hasOwnProperty(&quot;hasOwnProperty&quot;)); // false 那么，hasOwnProperty是原型对象中定义的方法吗？ 因为对象中没有定义hasOwnProperty方法，那应该就是在原型对象中定义的了，果真如此吗？ 我们用hasOwnProperty方法看下有没有hasOwnProperty它自己 1console.log(mc.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); // false 我们发现，原型对象中也没有hasOwnProperty方法，那hasOwnProperty来自原型的原型 原型的原型原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时 会先在自身中寻找，自身中如果有则直接使用 如果没有则去原型对象中寻找，有则使用 如果没有则去原型的原型中寻找，直到找到Object对象的原型 Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined 1console.log(mc.helloWorld); // undefined 那么，按照这个原理，我们在原型的原型中使用hasOwnProperty方法看看 1console.log(mc.__proto__.__proto__.hasOwnProperty(&quot;hasOwnProperty&quot;)); // true 那既然原型对象有原型，那原型的原型还有原型吗？ 1console.log(mc.__proto__.__proto__.__proto__); // null 根据上述原理，mc.__proto__.__proto__就是Object对象了 Object对象虽然没有原型，但也有__proto__，只是为null而已 toString如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 12345678910111213141516function Person(name, age, gender){ this.name = name; this.age = age; this.gender = gender;}var per1 = new Person(&quot;孙悟空&quot;, 1000, &quot;man&quot;);var per2 = new Person(&quot;猪八戒&quot;, 3600, &quot;man&quot;);// 当我们直接在页面中打印一个对象时，事件上是输出的对象的`toString()`方法的返回值console.log(per1); // Person {name: &quot;孙悟空&quot;, age: 1000, gender: &quot;man&quot;}console.log(per1.toString()); // [object Object]// 如果我们希望在输出对象时不输出`[object Object]`，可以为对象添加一个`toString()`方法per1.toString = function(){ return &quot;Person[name=&quot; + this.name + &quot;, age=&quot; + this.age + &quot;, gender=&quot; + this.gender + &quot;]&quot;;}console.log(per1); // Person {name: &quot;孙悟空&quot;, age: 1000, gender: &quot;man&quot;, toString: ƒ}console.log(per1.toString()); // Person[name=孙悟空, age=1000, gender=man] 上述只是修改per1对象的toString方法，不会对其他对象产生影响 如果想要所有对象都执行该方法，可以修改Person原型的toString 123456console.log(per2.toString()); // [object Object]// 修改Person原型的toStringPerson.prototype.toString = function(){ return &quot;Person[name=&quot; + this.name + &quot;, age=&quot; + this.age + &quot;, gender=&quot; + this.gender + &quot;]&quot;;}console.log(per2.toString()); // Person[name=猪八戒, age=3600, gender=man]","link":"/2024/03/28/JS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"},{"title":"JS流程控制","text":"JS条件判断，条件分支语句，循环语句 流程控制JS中的程序是从上到下一行一行执行的 通过流程控制语句可以控制程序执行流程，使程序可以根据一定的条件来选择执行 语句的分类： 条件判断语句 条件分支语句 循环语句 条件判断语句使用条件判断语句，可以在执行某个语句之前进行判断 如果条件成立才会执行语句，条件不成立则语句不执行。 if 语句语法一 123if(条件表达式) { 语句} if语句在执行时，会先对条件表达式进行求值判断 如果条件表达式的值为true，则执行if后的语句 如果条件表达式的值为false，则不执行if后的语句 语法二 12345if(条件表达式) { 语句1...} else { 语句2...} 语法三 123456789if(条件表达式) { 语句1...} else if(条件表达式) { 语句2...} else if(条件表达式) { 语句3...} else{ 语句4...} switch 语句1234567891011switch(条件表达式) { case 表达式1: 语句1...; break; case 表达式2: 语句2...; break; default: 语句...; break;} 在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较 while 语句循环语句：通过循环语句可以反复的执行一段代码多次 while循环语法： 123while(条件表达式) { 语句...} while语句在执行时，先对条件表达式进行求值判断 如果值为true，则执行循环体，循环体执行完毕以后，继续对表达式进行判断 如果为true，则继续执行循环体，以此类推 如果值为false，则终止循环 do-while 语句do...while循环语法： 123do{ 语句...}while(条件表达式) do...while语句在执行时，会先执行循环体，循环体执行完毕以后，在对 for 语句for语句，也是一个循环语句，也称为for循环 在for循环中，为我们提供了专门的位置用来放三个表达式： 初始化表达式 条件表达式 更新表达式 for循环的语法： 123for(①初始化表达式;②条件表达式;③更新表达式) { ④语句...} for循环的执行流程： ①执行初始化表达式，初始化变量（初始化表达式只会执行一次） ②执行条件表达式，判断是否执行循环。 如果为true，则执行④语句 如果为false，则终止循环 ③执行更新表达式，更新表达式执行完毕，继续重复② 如果在for循环中不写任何的表达式，只写两个;，此时循环是一个死循环会一直执行下去，慎用 123for(;;){ alert(&quot;hello&quot;);} break和continue不能在if语句中使用break和continue break break关键字可以用来退出switch或循环语句 break关键字，会立即终止离他最近的那个循环语句 可以为循环语句创建一个label，来标识当前的循环label： 循环语句使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的 continue continue关键字可以用来跳过当次循环 continue也是默认只会对离他最近的循环循环起作用","link":"/2024/03/27/JS%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"JS简介","text":"JS的基本简介 JavaScript的组成 ECMAScript（European Computer Manufacturers Association），JS的一个标准 DOM（Document Object Model），文档对象模型 BOM（BrowserObjectModel），浏览器对象模型 JavaScript是一种广泛使用的脚本语言，它最初是为了在网页中实现交互性而设计的。以下是关于JavaScript的一些关键点： 历史 起源：由网景公司的布兰登·艾奇（Brendan Eich）在1995年创建。 标准：ECMAScript是JavaScript的标准规范，由ECMA国际组织维护。 特点 解释型：通常不需要编译，代码可以直接由浏览器或其他JavaScript引擎执行。 弱类型：变量不需要声明类型，可以随时改变其类型。 动态：运行时可以创建和修改对象。 面向对象：支持原型继承和类继承（ES6 引入了类的概念）。 函数式编程：函数是一等公民，可以作为参数传递给其他函数，也可以作为返回值从函数中返回。 事件驱动：通过事件处理机制来响应用户的操作和其他系统事件。 应用领域 Web开发：前端开发中最主要的语言，用于创建动态网页和用户界面。 服务器端开发：Node.js允许使用JavaScript进行服务器端编程。 移动应用开发：通过React Native、Ionic等框架开发跨平台移动应用。 桌面应用开发：Electron框架使开发者能够构建跨平台的桌面应用。 游戏开发：虽然不是主流游戏开发语言，但可以用于简单的网页游戏或游戏中的UI元素。 核心概念 DOM操作：文档对象模型（Document Object Model），用于操作HTML页面结构。 AJAX：异步JavaScript和XML技术，用于后台数据交互。 Promise和Async/Await：用于处理异步操作的新方法，简化了回调地狱的问题。 模块化：ES6引入了模块系统，使得代码组织更加清晰。 ECMAScript新特性：每年都会发布新的ECMAScript版本，引入新特性和改进。 开发工具 编辑器/IDE：如Visual Studio Code, WebStorm等。 调试工具：现代浏览器内置的开发者工具。 构建工具：Webpack, Gulp, Grunt等。 HelloWorld控制浏览器弹出一个警告框 1alert(&quot;Hello World!&quot;); 让计算机在页面中输出一个内容 1document.write(&quot;Hello World!&quot;); 向控制台输出一个内容 1console.log(&quot;Hello World!&quot;);","link":"/2024/03/23/JS%E7%AE%80%E4%BB%8B/"},{"title":"JS运算","text":"JS运算符，算数运算符，自增自减，逻辑运算符，一元运算符，赋值运算符，关系运算符，相等运算符，条件运算符，运算符优先级 运算符运算符也叫操作符，通过运算符可以对一个或多个值进行运算，并获取运算结果 比如：typeof就是运算符，可以来获得一个值的类型 算数运算符 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算 任何值和NaN做运算都得NaN 算数运算符 + 可以对两个值进行加法运算，并将结果返回 如果对两个字符串进行加法运算，则会将两个字符串拼接为一个字符串，并返回 任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作 12345678var a1 = 123 + 456;console.log(a1); // 579var a2 = &quot;123&quot; + &quot;456&quot;;console.log(a2); // 123456var a3 = &quot;123&quot; + 456;console.log(a3); // 123456var a8 = 123 + undefined;console.log(a8); // NaN -可以对两个值进行减法运算（效果同上） * 可以对两个值进行乘法运算 / 可以对两个值进行除法运算 % 可以对两个值进行取模运算 可以利用+&quot;&quot;将Number转为String，利用-0、*1、/1将String转为Number 123456var b= 33;var x = b+'';document.write(typeof(x))//stringvar w = '123'; var k = w-0; document.write(typeof(k))//number 一元运算符一元运算符，只需要一个操作数 + 正号：正号不会对数字产生任何影响 - 负号：负号可以对数字进行负号的取反 对于非Number类型的值，它会将先转换为Number，然后再运算 可以对一个其他的数据类型使用+，来将其转换为Number，它的原理和Number()函数一样 123456789101112131415161718192021var a = &quot;10&quot;;var result = +a;console.log(typeof result); // numberconsole.log(&quot;result=&quot;+result); // result=10result = -a;console.log(&quot;result=&quot;+result); // result=-10a = true;result = +a;console.log(&quot;result=&quot;+result); // result=1a = &quot;&quot;;result = +a;console.log(&quot;result=&quot;+result); // result=0a = null;result = +a;console.log(&quot;result=&quot;+result); // result=0a = undefined;result = +a;console.log(&quot;result=&quot;+result); // result=NaNa = NaN;result = +a;console.log(&quot;result=&quot;+result); // result=NaN 自增和自减自增++通过自增可以使变量在自身的基础上增加1 自增分成两种：后++（a++）和前++（++a） 无论是a++还是++a，都会立即使原变量的值自增1 不同的是a++和++a的值不同 a++是变量的原值（自增前的值） ++a是变量的新值（自增后的值） 1234567var a,b;a = 1;b = a++;console.log(&quot;a++ = &quot; + b + &quot;, a = &quot; + a); // a++ = 1, a = 2a = 1;b = ++a;console.log(&quot;++a = &quot; + b + &quot;, a = &quot; + a); // ++a = 2, a = 2 自减–通过自减可以使变量在自身的基础上减少1 自减分成两种：后–（a--）和前–（--a） 无论是a--还是--a，都会立即使原变量的值自减1 不同的是a--和--a的值不同 a--是变量的原值（自减前的值） --a是变量的新值（自减后的值） 1234567var a,b;a = 1;b = a--;console.log(&quot;a-- = &quot; + b + &quot;, a = &quot; + a); // a-- = 1, a = 0a = 1;b = --a;console.log(&quot;--a = &quot; + b + &quot;, a = &quot; + a); // --a = 0, a = 0 逻辑运算符JS中为我们提供了三种逻辑运算符 ! 非 &amp;&amp; 与 || 或 非运算!可以用来对一个值进行非运算 所谓非运算就是值对一个布尔值进行取反操作，true变false，false变true 如果对一个值进行两次取反，它不会变化 如果对非布尔值进行运算，则会将其转换为布尔值，然后再取反 所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值 可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和Boolean()函数一样 123456var a,b;a = true;b = !a;console.log(&quot;a=&quot;+a+&quot;,b=&quot;+b); // a=true,b=falseb = !!a;console.log(&quot;a=&quot;+a+&quot;,b=&quot;+b); // a=true,b=true 与运算&amp;&amp;可以对符号两侧的值进行与运算并返回结果 运算规则 两个值中只要有一个值的false就返回false；只有两个值都为true时，才会返回true JS中的“与”属于短路的与，如果第一个值为false，则不会检查第二个值 123456789var a;a = true &amp;&amp; true; // trueconsole.log(a);a = true &amp;&amp; false; // falseconsole.log(a);a = false &amp;&amp; true; // falseconsole.log(a);a = false &amp;&amp; false; // falseconsole.log(a); 或运算||可以对符号两侧的值进行或运算并返回结果 运算规则： 两个值中只要有一个true，就返回true；如果两个值都为false，才返回false JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值 123456789var a;a = true || true; // trueconsole.log(a);a = true || false; // trueconsole.log(a);a = false || true; // trueconsole.log(a);a = false || false; // falseconsole.log(a); &amp;&amp;、|| 非布尔值的情况对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值 与运算 如果第一个值为true，则必然返回第二个值 如果第一个值为false，则直接返回第一个值 123456789101112131415161718192021var result;result = 1 &amp;&amp; 2;console.log(result); // 2result = 2 &amp;&amp; 1;console.log(result); // 1result = 1 &amp;&amp; 0;console.log(result); // 0result = 0 &amp;&amp; 1;console.log(result); // 0result = &quot;&quot; &amp;&amp; 1;console.log(result); //result = 1 &amp;&amp; &quot;&quot;;console.log(result); //result = null &amp;&amp; 1;console.log(result); // nullresult = 1 &amp;&amp; null;console.log(result); // nullresult = undefined &amp;&amp; 1;console.log(result); // undefined result = 1 &amp;&amp; undefined;console.log(result); // undefined 或运算 如果第一个值为true，则直接返回第一个值 如果第一个值为false，则返回第二个值 123456789101112131415161718192021var result;result = 1 || 2;console.log(result); // 1result = 2 || 1;console.log(result); // 2result = 1 || 0;console.log(result); // 1result = 0 || 1;console.log(result); // 1result = &quot;&quot; || 1;console.log(result); // 1result = 1 || &quot;&quot;;console.log(result); // 1result = null || 1;console.log(result); // 1result = 1 || null;console.log(result); // 1result = undefined || 1;console.log(result); // 1 result = 1 || undefined;console.log(result); // 1 赋值运算符= 可以将符号右侧的值赋值给符号左侧的变量 += a+=5等价于a=a+5 -= a-=5等价于a=a-5 *= a*=5等价于a=a*5 /= a/=5等价于a=a/5 %= a%=5等价于a=a%5 关系运算符通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false &gt;：大于号，判断符号左侧的值是否大于右侧的 &gt;=：大于等于号，判断符号左侧的值是否大于等于右侧的 &lt;：小于号，判断符号左侧的值是否小于右侧的 &lt;=：小于等于号，判断符号左侧的值是否小于等于右侧的 任何值和NaN做任何比较都是false 非数值的情况 对于非数值进行比较时，会将其转换为数字然后再比较 如果符号两侧的值都是字符串时，不会将其转换为数字进行比较，而是分别比较字符串中字符的Unicode编码 相等运算符== 相等相等运算符用来比较两个值是否相等，如果相等会返回true，否则返回false 使用==来做相等运算：当使用==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型然后在比较 1234567// undefined 衍生自null，所以这两个值做相等判断时，会返回trueconsole.log(null == undefined); // true// NaN不和任何值相等，包括他本身console.log(NaN == NaN); // false// 可以通过isNaN()函数来判断一个值是否是NaN// 如果该值是NaN则返回true，否则返回falseconsole.log(isNaN(NaN)); // true != 不想等不相等运算符用来判断两个值是否不相等，如果不相等返回true，否则返回false 使用!=来做不相等运算：不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false === 全等用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回false !==不全等用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回false 12console.log(&quot;123&quot; === 123); // falseconsole.log(&quot;123&quot; !== 123); // true 条件运算符条件运算符也叫三元运算符 条件表达式 ? 语句1: 语句2; 执行的流程：条件运算符在执行时，首先对条件表达式进行求值 如果该值为true，则执行语句1，并返回执行结果 如果该值为false，则执行语句2，并返回执行结果 123456789var a = 30;var b = 40;var c = 90;// 两数中取MAXvar max = a &gt; b ? a : b;console.log(&quot;max=&quot;+max);// 三数中取MAXmax = a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c);console.log(&quot;max=&quot;+max); 如果条件的表达式的求值结果是一个非布尔值，则会将其转换为布尔值，然后再运算 1&quot;hello&quot; ? alert(&quot;111111&quot;) : alert(&quot;2222222&quot;); 运算符优先级就和数学中一样，在JS中运算符也有优先级，比如：先乘除后加减 在JS中有一个运算符优先级的表，在表中越靠上优先级越高，优先级越高越优先计算，如果优先级一样，则从左往右计算 但是这个表我们并不需要记忆，如果遇到优先级不清楚可以使用()来改变优先级 .、[]、new () ++、-- !、～、+（单目）、-（单目）、typeof、void、delete %、\\*、/ +（双目）、-（双目） &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; &lt;、&lt;=、&gt;、&gt;= ==、!==、=== &amp; ^ **` &amp;&amp; **` ?: **=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、` , Unicode编码表Unicode官网：https://home.unicode.org/","link":"/2024/03/27/JS%E8%BF%90%E7%AE%97/"},{"title":"JS高级基础回顾","text":"JS基础回顾 数据类型相关知识JS基础 - Hexo (mk310.github.io) 数据变量内存什么是数据 存储在内存中代表特定信息的’东西’, 本质上是0101… 数据的特点: 可传递, 可运算 –&gt;let a=0;b=a 🔜体现可传递 一切皆数据 内存中所有操作的目标: 数据 算术运算 逻辑运算 赋值 运行函数 什么是内存? 内存条通电后产生的可储存数据的空间(临时的) 内存产生和死亡: 内存条(电路版)==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 全局变量/局部变量 堆: 对象 什么是变量? 可变化的量, 由变量名和变量值组成 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据 ps:变量obj.xx–&gt;.相当于拿着地址找到后面对应的内存,所以只有当我变量中存的是地址,才可以用. 内存是用来存储数据的空间,变量是内存的标识 相关问题赋值和内存的问题:var a = xxx,a内存中保存的是什么 xxx是基本数据,保存的就是这个数据 xxx是对象,保存就是对象的地址值 xxx是一个变量,保存是可能是基本数据也可能是地址值 变量赋值问题: 两个引用变量指向同一个对象,通过一个变量修改对象内部数据,另一个变量得到也是修改后数据 值传递还是引用传递:调用函数传递变量参数时候: 理解1:都是值传递(基本数据和地址值都是值) 理解2:基本数据是值传递,引用数据是引用传递 JS管理内存: 内存生命周期 分配小内存空间,得到使用权 存储数据,反复使用 释放小内存 释放内存 局部变量:函数执行完自动释放 对象:成为垃圾对象后=&gt;垃圾回收器回收 12345678var a = 3var obj = {name:'test'}obj = undefined||null //此时obj没有被释放,之前创建的{name:'test'},没有地址指向它,成为垃圾对象,在之后某个时刻会被垃圾回回收function fn() {var b={}}fn() //在函数执行后,b无法访问成为垃圾对象,程序完成后的某个时间被垃圾回收 对象对象的概念 什么是对象 多个数据封装体 用来保存多个数据的容器 一个对象代表现实世界中的一个食物 为什么使用对象 统一管理多个数据 对象组成 属性构成:属性名(字符串),属性值(任意) 方法:一种特殊的属性:(属性值是函数) 如何访问对象内部数据 .属性名:编码简单,特殊时候不能用 ['属性名'];编码麻烦,通用 什么时候使用['属性名']: 属性名含有特殊字符-``空格 属性名不确定时候 12345678910111213141516示例代码:var p = []p.content type = 'test' //报错p.content-type = 'test' //报错p['content-type'] = 'test' //成功//属性名不确定var proName = 'myAge' //proName存储变化的变量名称var value = 18// p.proName = value //ReferenceError: proname is not definedp[proName] = valueconsole.log(p[proName]) 函数函数的概念什么是函数： 实现特定功能的n条语句的封装体 只有函数是可以执行的，其他的数据类型不可以 为什么要用函数： 提高代码复用 便于阅读交流 如何定义函数： 函数声明 表达式 //TODO: 12function fn1(){fonsole.log('fn1')} //函数声明const fn2 = () =&gt;console.log('fn2') //表达式 调用(执行)函数 functionName()直接调用 obj.functionName()通过对象调用 new functionName()new调用 functionName.call/apply(obj)临时让functionName()成为obj的方法 12345678910111213141516171819202122232425// 定义一个函数 function functionName(){ console.log('函数已经执行') } // 调用 // 1.直接调用 functionName() // 2.通过对象调用 var obj = { functionName : function (){ console.log('函数已经执行') } } obj.functionName() // 3.new调用 new functionName(); // 4.call调用 functionName.call(obj) 回调函数什么函数是回调函数 自己定义的 自己没有调用 最终程序执行的 常见的回调函数 dom时间回调函数==&gt;发生事件的dom元素 定时器回调函数==&gt;window ajax请求回调函数//TODO 生命周期回调函数//TODO 1234// dom事件回调函数document.getElementById('btn').onclick = function(){alert('hell')}// 定时器回调函数setTimeout(function(){alert('定时器'+this)},2000) IIFE(自调用函数)Immediately-Invoked Function Expression(IIFE) 作用: 隐藏实现的细节 不会污染全局命名空间 用来编码js模块 123456789101112131415 (function () { //匿名函数自调用 var a = 3 console.log(a + 3) })() console.log(a) // a is not defined //此处前方为何要一个`;`--&gt;因为自调用函数外部有一个()包裹,可能与前方以()结尾的代码被一起认为是函数调用 //不加分号可能会被认为这样 console.log(a)(IIFE) ;(function () {//不会污染外部(全局)命名空间--&gt;举例 let a = 1; function test () { console.log(++a) } //声明一个局部函数test window.$ = function () { return {test: test} }// 向外暴露一个全局函数 })()test () //test is not defined $().test() // 1. $是一个函数 2. $执行后返回的是一个对象 函数中的thisthis是什么 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有的函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值 test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj 12345678910111213141516171819202122232425262728293031 function Person(color) { console.log(this) this.color = color; this.getColor = function () { console.log(this) return this.color; }; this.setColor = function (color) { console.log(this) this.color = color; }; } Person(&quot;red&quot;); //this是谁? window const p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p const obj = {}; //调用call会改变this指向--&gt;让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, &quot;black&quot;); //this是谁? obj const test = p.setColor; test(); //this是谁? window --&gt;因为直接调用了 function fun1() { function fun2() { console.log(this); } fun2(); //this是谁? window }fun1();//调用fun1 关于语句分号 js一条语句的后面可以不加分号 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢 在下面2种情况下不加分号会有问题 小括号开头的前一条语句 中方括号开头的前一条语句 解决办法: 在行首加分号 强有力的例子: vue.js库 知乎热议: https://www.zhihu.com/question/20298345","link":"/2024/07/16/JS%E9%AB%98%E7%BA%A7/"},{"title":"JS高级函数","text":"JS高级函数 原型和原型链原型[prototype]函数的prototype属性 每个函数都有一个prototype属性,它默认指向一个Object空对象(即为:原型对象) 原型对象中有一个属性constructor指向函数对象 给原型对象添加属性 作用:函数的所有实例对象都自动拥有原型中的属性(方法) 12345678910111213// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun() { }console.log(Fun.prototype) // 默认指向一个Object空对象(没有自定义的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor === Date) //trueconsole.log(Fun.prototype.constructor === Fun) //true//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () { console.log('test()') }var fun = new Fun()fun.test() 显式原型与隐式原型 每个函数function都有一个prototype，即显式原型(属性) 每个实例对象都有一个[__ proto __]，可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 内存结构: 123456789101112131415161718//定义构造函数 function Fn() { // 内部默认执行语句: this.prototype = {} } // 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象 console.log(Fn.prototype) // 2. 每个实例对象都有一个__proto__，可称为隐式原型 //创建实例对象 var fn = new Fn() // 内部默认执行语句: this.__proto__ = Fn.prototype console.log(fn.__proto__) // 3. 对象的隐式原型的值为其对应构造函数的显式原型的值 console.log(Fn.prototype===fn.__proto__) // true //给原型添加方法 Fn.prototype.test = function () { console.log('test()') } //通过实例调用原型的方法 fn.test() 总结: 函数的[prototype]属性: 在定义函数时自动添加的, 默认值是一个空Object对象 对象的[__ proto __]属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前) 原型链原型链概念访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 123456789101112131415function Fn(){ this.test1 = function(){ console.log('this is test1') }}Fn.prototype.test2 = function(){}var fn = new Fn()fn.test3 = function(){ console.log('this is test3')}console.log(fn.__proto__) //{test2: ƒ}console.log(Fn.prototype) //{test2: ƒ}console.log(fn) //Fn {test1: ƒ, test3: ƒ} 别名: 隐式原型链 作用: 查找对象的属性(方法) Object的原型对象的_porto_指向的是null 构造函数/原型/实例对象之间的关系12var o1 = new Object();var o2 = {}; 1function Foo(){ } 12345678910// 1.函数的显式原型指向的对象默认是空Object实例对象(Object不满足)console.log(Fn.prototype instanceof Object) //trueconsole.log(Object.prototype instanceof Object) //false 指向是nullconsole.log(Function.prototype instanceof Object) //true Function是Object实例对象// 2.所有函数都是Function的实例(包括Function本身)console.log(Function.__proto__ === Function.prototype) //true // 3.Object的原型对象是原型链的尽头console.log(Object.prototype.__proto__) //null 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上(一般不同实例属性不同方法相同) 123456789101112131415161718192021222324function Fn() { }Fn.prototype.a = 'xxx'var fn1 = new Fn()console.log(fn1.a, fn1) //xxx Fn{}var fn2 = new Fn()fn2.a = 'yyy'console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn{a: &quot;yyy&quot;}function Person(name, age) { this.name = name this.age = age}Person.prototype.setName = function (name) { this.name = name}var p1 = new Person('Tom', 12)p1.setName('Bob')console.log(p1) //Person {name: &quot;Bob&quot;, age: 12}var p2 = new Person('Jack', 12)p2.setName('Cat')console.log(p2) //Person {name: &quot;Cat&quot;, age: 12}console.log(p1.__proto__===p2.__proto__) // true --&gt;所以方法一般定义在原型中 instanceof instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() { }var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() {}console.log(Object instanceof Foo) // false 面试题题目1： 123456function A () {}A.prototype.n = 1let b = new A()A.prototype = { n: 2, m: 3}let c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 题目二： 1234567891011121314151617function F (){}Object.prototype.a = function(){ console.log('a()')}Function.prototype.b = function(){ console.log('b()')}let f = new F()f.a() //a()f.b() //f.b is not a function --&gt;找不到F.a() //a()F.b() //b()console.log(f)console.log(Object.prototype)console.log(Function.prototype) 执行上下文和执行上下文栈变量提升和函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象) 变量和函数的提升是把变量或者函数提升到其作用域的最前面 引出一个问题: 变量提升和函数提升是如何产生的? 12345678910111213 var a = 3 function fn () { console.log(a) var a = 4 //变量提升 } fn() //undefined'--------------------------------------------' console.log(b) //undefined 变量提升 fn2() //可调用 函数提升 // fn3() //不能 fn3的定义方式首先是变量提升，不是函数提升 var b = 3 function fn2() { console.log('fn2()') } var fn3 = function () { console.log('fn3()') } 执行上下文 代码分类(按照代码位置划分) 全局代码 函数(局部)代码 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)–&gt;所以栈底百分百是[window] 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 上下文栈数==函数调用数+1 ` 1234567891011//1. 进入全局执行上下文var a = 10var bar = function (x) { var b = 5 foo(x + b) //3. 进入foo执行上下文 }var foo = function (y) { var c = 5 console.log(a + c + y)}bar(10) //2. 进入bar函数执行上下文 面试题 函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖 123456789101112131415161718192021222324252627/*测试题1: 先执行变量提升, 再执行函数提升,*/function a() {}var aconsole.log(typeof a) // 'function' 函数的优先级高于变量,不会被变量声明覆盖/*测试题2:*/if (!(b in window)) {var b = 1}console.log(b) // undefined/*测试题3:*/var c = 1function c(c) {console.log(c)var c = 3 //与此行无关}//变量和函数提升后相当于把变量赋值 c=1放在此处,函数声明被变量赋值覆盖c(2) // 报错 c is not a function 作用域与作用域链作用域 理解 一串代码所在的区域 作用域是静态的（相对于上下文对象），在代码编写时候就已经确定 分类 全局作用域 函数作用域 没有块作用域（ES6 中:作用域块） 作用 隔离变量，不用作用域下同名变量不会有冲突 1234567891011121314151617/* //没块作用域 if(true) { var c = 3 } console.log(c) */ var a = 10, b = 20 function fn(x) { var a = 100, c = 300; console.log('fn()', a, b, c, x) //100 20 300 10 function bar(x) { var a = 1000, d = 400 console.log('bar()', a, b, c, d, x) } bar(100)//1000 20 300 400 100 bar(200)//1000 20 300 400 200 } fn(10) 作用域与执行上下文的区别与联系 区别1: 创建的时间 全局作用域之外,每个函数都会创建自己的作用域作用域在函数定义时就已经确定了,而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 函数执行上下文是在调用函数时, 函数体代码执行之前创建 区别2: 是否动态的变化 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放 联系: 执行上下文(对象)是从属于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 作用域链 理解 多个上下级关系的作用域形成的链,方向是从内到外 查找变量的时候就是顺着作用域链来的 查找一个变量的原则 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 面试题作用域在函数定义时候已经确定了,而不是在函数调用时候: 12345678910var x = 10;function fn() { console.log(x); }function show(f) { var x = 20; f();}show(fn); //输出10 在这个JavaScript代码中，有一个全局变量 x 被赋值为 10，然后定义了两个函数 fn 和 show。fn 函数简单地打印变量 x 的值，而 show 函数接收一个函数 f 作为参数，并在其内部定义了一个局部变量 x（值为 20），然后调用传入的函数 f。 当 show(fn) 被调用时，尽管 show 函数内部有一个局部变量 x（值为 20），但 fn 函数在调用时并没有访问这个局部变量。相反，fn 函数访问的是全局作用域中的 x 变量，因为在其定义的作用域中没有找到名为 x 的局部变量。 因此，这段代码的输出将是 10，这是全局变量 x 的值。 总结一下，JavaScript 中的变量查找遵循所谓的“词法作用域”（也称为静态作用域或声明时作用域）。这意味着函数会记住它们是在哪里被定义的，并且当它们被调用时，会基于这个定义位置来查找变量。在这个例子中，fn 函数记住它是在全局作用域中定义的，因此在执行时它会查找并打印全局作用域中的 x 变量的值。 对象变量不能产生局部作用域: 12345678910111213var fn = function () {console.log(fn)}fn()var obj = { fn2: function () { console.log(fn2) //console.log(this.fn2) }}obj.fn2() 执行 obj.fn2() 时，会遇到一个 ReferenceError，因为 fn2 在 fn2 函数的作用域中并没有被声明或定义为一个局部变量。在 JavaScript 中，函数体内部的作用域会首先查找局部变量，如果没有找到，则会继续向外层作用域查找，直到全局作用域。但是，在这个例子中，fn2 是作为 obj 对象的一个属性（方法）存在的，而不是作为任何函数内部的局部变量或全局变量。 当在 fn2 函数内部尝试访问 fn2 时，JavaScript 会认为您是在尝试访问一个名为 fn2 的局部变量，但实际上并没有这样的局部变量存在。因此，它会继续向外层作用域查找，但同样找不到，因为 fn2 不是外层作用域（在这个例子中是全局作用域）的一部分。 闭包知识预备例子分析执行上下文12345671: let a = 32: function addTwo(x) {3: let ret = x + 24: return ret5: }6: let b = addTwo(a)7: console.log(b) 上述代码在js引擎里具体工作流程： 第一行，全局上下文声明了一个新变量a，赋值为3 第2行到第5行： 在全局执行上下文中声明了一个addTwo的新变量,给它分配了一个函数定义 两个{}内的所有内容分配个addTwo,函数内部的代码没有被求值,没有执行,只是储存在一个变量中以备将来使用. 在第6行: 在全局执行上下文中声明一个新变量,将其标记为b,变量一声明值为undefined 遇到赋值操作符,准备给b赋值,看到一个函数被调用(每个函数都会返回一些东西:值,对象,undefined)无论函数返回什么,都将其赋值给b 调用标记为addTwo的函数,JS将在全局执行上下文内存中查找addTwo,返现它在第2到第5行中定义,包含一个函数定义 变量a作为参数传递给函数,JS在全局执行上下文中搜索变量a,找到发现值为3,将3作为参数传递给函数,准备执行函数 执行上下文切换,创建一个本地执行上下文addTwo执行上下文,执行上下文被推送到调用堆栈上,开始函数执行: 值3是作为一个参数传递的,第一步要在addTwo执行上下文中创建一个变量x,将3赋值给x 执行第三行,声明一个新变量ret,设置为undefined 执行相加操作,得到的值赋值给ret 执行第四行,返回ret内容,函数执行完毕 addTwo 执行上下文被销毁，变量x和ret被消去了，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数addTwo 是从全局执行上下文调用的。第6行执行完毕 第 7 行，b的值 5 被打印到控制台了。 例子分析词法作用域上文中:一个函数可以访问在它的调用上下文中定义的变量，这个就是词法作用域（Lexical scope）**** 返回函数的函数[高阶函数]12345678910111: let val = 72: function createAdder() {3: function addNumbers(a, b) {4: let ret = a + b5: return ret6: }7: return addNumbers8: }9: let adder = createAdder()10: let sum = adder(val, 8)11: console.log('example of function returning a function: ', sum) 闭包 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 引出闭包错误场景: 需求: 点击某个按钮, 提示&quot;点击的是第n个按钮&quot; 123456789101112131415161718&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;!--需求: 点击某个按钮, 提示&quot;点击的是第n个按钮&quot;--&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btns = document.getElementsByTagName('button') //注意[btns]不是一个数组,它是一个伪数组 //每次获取[btns.length]其实都是需要进行计算的(因为它是伪数组) //所以为了性能更好,在此处赋值,就只需要计算一次 for (var i = 0,length=btns.length; i &lt; length; i++) { var btn = btns[i] btn.onclick = function () { //遍历加监听 alert('第'+(i+1)+'个') //结果 全是[4] } }&lt;/script&gt; 上述代码实际是给每个button添加一个点击事件,当点击事件实际执行的时候,循环已经结束,执行循环时候引用的全局变量[i]值已经变为3 解决的方法是,给每个button添加属性存储在循环添加事件时候的i的值,让其记住当时的i 利用闭包解决: ​ 利用闭包知识点解决 123456789101112131415161718&lt;body&gt;&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; //利用闭包 for (var i = 0,length=btns.length; i &lt; length; i++) { //此处的j是局部的,它将传入的[i]存入局部的[j]中,这样就能实现效果 (function (j) { var btn = btns[j] btn.onclick = function () { alert('第'+(j+1)+'个') } })(i) }&lt;/script&gt; &lt;/body&gt; 例子闭包分析123456789101112131: function createCounter() {2: let counter = 03: const myFunction = function() {4: counter = counter + 15: return counter6: }7: return myFunction8: }9: const increment = createCounter()10: const c1 = increment()11: const c2 = increment()12: const c3 = increment()13: console.log('example increment', c1, c2, c3) 初步分析: 行 1 - 8。在全局执行上下文中创建了一个新的变量createCounter，并赋值了一个的函数定义。 第 9 行。 在全局执行上下文中声明了一个名为increment的新变量。 需要调用createCounter函数并将其返回值赋给increment变量。 返回执行 行 1 - 8。调用函数，创建新的本地执行上下文。 第 2 行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0; 行 3 - 6。声明一个名为myFunction的新变量，变量在本地执行上下文中声明,变量的内容是为第 4 行和第 5 行所定义。 第 7 行。返回myFunction变量的内容，删除本地执行上下文。变量myFunction和counter不再存在。此时控制权回到了调用上下文。 再次回到 第 9 行 在调用上下文(全局执行上下文)中，createCounter返回的值赋给了increment，变量increment现在包含一个函数定义内容为createCounter返回的函数。 它不再标记为myFunction，但它的定义是相同的。在全局上下文中，它是的标记为 labeledincrement。 第 10 行。声明一个新变量(c1)。 继续第 10 行。查找increment变量，它是一个函数并调用它。它包含前面返回的函数定义，如第 4-5 行所定义的。 创建一个新的执行上下文。没有参数。开始执行函数。 回到 第 4 行。 counter=counter + 1。在本地执行上下文中查找counter变量。 只是创建了那个上下文，从来没有声明任何局部变量。看看全局执行上下文。这里也没有counter变量。 Javascript 会将其计算为 counter = undefined + 1，声明一个标记为counter的新局部变量，并将其赋值为 number 1，因为 undefined 被当作值为 0。 –&gt;此处是错误的哦,别钻牛角尖,正确的理解在下方,此处是做错误对比 第 5 行。变量counter的值(1)，销毁本地执行上下文和counter变量。 回到第 10 行。返回值(1)被赋给 c1。 第 11 行。重复步骤 10-14，c2 也被赋值为 1。 第 12 行。重复步骤 10-14，c3 也被赋值为 1。 第 13 行。打印变量 c1 c2 和 c3 的内容。 它并不像从我上面的解释中所期望的那样记录 1,1,1。而是记录 1,2,3,函数记住的counter的变化 理解: **无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变 ** 第二次分析(9~12行): 行 1 - 8。在全局执行上下文中创建了一个新的变量createCounter，并赋值了一个的函数定义。 第 9 行。 在全局执行上下文中声明了一个名为increment的新变量。 需要调用createCounter函数并将其返回值赋给increment变量。 返回执行 行 1 - 8。调用函数，创建新的本地执行上下文。 第 2 行。在本地执行上下文中，声明一个名为counter的新变量并赋值为 0; 行 3 - 6。声明一个名为myFunction的新变量， 第5行.现在还创建了一个闭包，并将其作为函数定义的一部分。闭包包含作用域中的变量，在本例中是变量counter(值为0)。 第7行,返回函数定义和它的闭包，闭包中包含了创建它时在作用域内的变量。 再次回到 第 9 行 在调用上下文(全局执行上下文)中，createCounter返回的值赋给了increment，变量increment现在包含一个函数定义内容为createCounter返回的函数。 它不再标记为myFunction，但它的定义是相同的。在全局上下文中，它是的标记为 labeledincrement。 第 10 行。声明一个新变量(c1)。 继续第 10 行。查找变量increment，它是一个函数，调用它。它包含前面返回的函数定义,如第4-5行所定义的。(它还有一个带有变量的闭包)。 创建一个新的执行上下文。没有参数。开始执行函数。 回到 第 4 行。 第4行。[counter = counter + 1]，寻找变量 [counter]，在查找本地或全局执行上下文之前，检查一下闭包，闭包包含一个名为[counter]的变量，其值为0。在第4行表达式之后，它的值被设置为1。它再次被储存在闭包里，闭包现在包含值为1的变量 [counter]。 第5行。返回counter的值，销毁本地执行上下文。 回到第 10 行。返回值(1)被赋给 c1。 第 11 行。重复步骤10-14。这一次，在闭包中此时变量counter的值是1。它在第12行设置的，它的值被递增并以2的形式存储在递增函数的闭包中,c2被赋值为2。 第 12 行。重复步骤 10-14，c3 被赋值为 3。 第 13 行。打印变量 c1 c2 和 c3 的内容。 是否有任何函数具有闭包，甚至是在全局范围内创建的函数? 答案是肯定的。在全局作用域中创建的函数创建闭包，但是由于这些函数是在全局作用域中创建的，所以它们可以访问全局作用域中的所有变量，闭包的概念并不重要。 但当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，但它们仅存在于其闭包中。 ⭐闭包定义在JavaScript中，闭包是一种特殊的对象，它允许一个函数访问并操作其外部作用域内的变量，即使该外部函数已经完成执行。简而言之，闭包是由函数及其相关的引用环境组合而成的实体。 闭包的形成需要满足以下条件： 内部函数：一个函数定义在另一个函数内部。 外部变量：内部函数需要访问外部函数的作用域中的变量。 持久引用：内部函数必须以某种方式被外部作用域中的变量所引用，以便在外部函数执行完毕后仍然可以访问内部函数。 组成: 函数：这是闭包的主体，是一个可以被调用的对象。 引用环境：这是一个保存了函数外部变量的环境记录，这些变量可以在函数内部被访问。 工作原理: 当一个函数被定义在一个外部函数内部时，这个内部函数可以访问外部函数的所有局部变量、参数以及内部定义的其他函数。当内部函数被返回或者以某种方式保存时，它就会形成一个闭包，因为它仍然能够访问其外部函数的作用域，即使外部函数已经执行完毕。 闭包作用 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 问题: 函数执行完后, 函数内部声明的局部变量是否还存在? 一般是不存在, 存在于闭中的变量才可能存在 在函数外部能直接访问函数内部的局部变量吗? 不能, 但是可以通过闭包让外部操作它 闭包的生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 即没有人指向它时死亡,通常置为[null],当然指向其他也行,但不安全(容易污染变量) 1234567891011121314//闭包的生命周期function fn1() { //此时闭包就已经产生了(函数提升,实际上[fn2]提升到了第一行, 内部函数对象已经创建了) var a = 2 function fn2 () { //如果时[let fn2=function(){}],那么在这行才会产生闭包 a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 闭包的应用闭包的应用 : 定义JS模块 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包信n个方法的对象或函数 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能 模块定义: 123456789101112131415161718192021222324252627282930313233343536373839//myModule.jsfunction myModule() { //私有数据 var msg = 'My atguigu' //操作数据的函数 function doSomething() { console.log('doSomething() '+msg.toUpperCase()) } function doOtherthing () { console.log('doOtherthing() '+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) return { doSomething: doSomething, doOtherthing: doOtherthing }} -----------------------------------------------------------------// myModule2.js (function () { //私有数据 var msg = 'My atguigu' //操作数据的函数 function doSomething() { console.log('doSomething() '+msg.toUpperCase()) } function doOtherthing () { console.log('doOtherthing() '+msg.toLowerCase()) } //向外暴露对象(给外部使用的方法) window.myModule2 = { doSomething: doSomething, doOtherthing: doOtherthing }})() 模块调用 1234567891011121314//调用示例------------ 模块调用1 --------------------------------------------&lt;script type=&quot;text/javascript&quot; src=&quot;myModule.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var module = myModule() module.doSomething() module.doOtherthing()&lt;/script&gt;------------ 模块调用2 --------------------------------------------&lt;script type=&quot;text/javascript&quot; src=&quot;myModule2.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; myModule2.doSomething() myModule2.doOtherthing()&lt;/script&gt; 常见的闭包将函数作为另一个函数的返回值 123456789101112// 1. 将函数作为另一个函数的返回值 function fn1() { var a = 2 function fn2() { a++ console.log(a) } return fn2 } var f = fn1() f() // 3 f() // 4 将函数作为实参传递给另一个函数调用 1234567// 2. 将函数作为实参传递给另一个函数调用 function showDelay(msg, time) { setTimeout(function () { alert(msg) }, time) } showDelay('atguigu', 2000 高阶函数与柯里化 从 ES6 高阶箭头函数理解函数柯里化(运用到闭包) 例子： 1let add = a =&gt; b =&gt; a + b 以上是一个很简单的相加函数，把它转化成 ES5 的写法如下 1234567function add(a) { return function(b) { return a + b }}var add3 = add(3) //add3表示一个指向函数的变量 可以当成函数调用名来用add3(4) === 3 + 4 //true 再简化一下，可以写成如下形式： 1234567let add = function(a) { var param = a; var innerFun = function(b) { return param + b; } return innerFun;} 该函数的返回值是一个函数。这就是高阶函数的定义：以函数为参数或者返回值是函数的函数。 柯里化 图例: 关键就是理解柯里化，其实可以把它理解成，柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用，比如 123456789101112let add = x =&gt; y =&gt; x + ylet add2 = add(2)-*----------------------------------本来完成 add 这个操作，应该是这样调用let add = (x, y) =&gt; x + yadd(2,3)----------------------------------1. 而现在 add2 函数完成同样操作只需要一个参数，这在函数式编程中广泛应用。let add = x =&gt; y =&gt; x + ylet add2 = add(2)2.详细解释一下，就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数,并且此时 x = 2，所以此时调用add2(3) === 2 + 3 闭包的缺点及解决 缺点: 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长 容易造成内存泄露 解决: 能不用闭包就不用 及时释放 function fn1() { var arr = new Array(100000) function fn2() { console.log(arr.length) } return fn2 } var f = fn1() f() f = null //让内部函数成为垃圾对象--&gt;回收闭包","link":"/2024/07/19/JS%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/"},{"title":"Linux基本命令","text":"linux命令是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。 操作系统 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，便于使用，作为中间人，连接软件和硬件 Linux文件和目录 /bin[重点] (/usr/bin、/usr/local/bin） 是Binarv的缩写，这个目录存放着最经常使用的命令。 /sbin (/usr/sbin、/usr/local/sbin) s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home[重点] 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root[重点] 该目录为系统管理员，也称作超级权限者的用户主目录。 /boot[重点] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了26内核中新出现的一个文件系线。 /tmp 这个目录是用来存放一些临时文件的。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media[重点] linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt[重点] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。 默认为空。 /usr/local[重点] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。 /var[重点] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。 包括各种日志文件。 /selinux[security-enhanced linux]360 SELinux是一种安全子系统，它能控制程序只能访问特定文件。 文件和文件夹操作12#终端命令格式command [-options] [parameter] cd(change diectory) 切换到文件夹 12345- cd /home 绝对路径，以根目录开头- cd admin 相对路径，不以根目录开头，以文件名开头- cd .. 返回上一级目录- cd ~ 回到自己家的的目录，/home/damiin- cd - 返回上一步进入的文件夹 pwd(print work diectory) 查看当前所在文件夹 ls(list) 查看目录内容 1234567- ls -l 显示详细列表- ls -lh把文件大小以人性化的方式显示（如比特转换为kb）- ls -a 显示所有的文件，包含隐藏文件，隐藏文件是以“.”开头的文件touch .123.txt 创建隐藏文件- ls -lah - ls /home la 查看home中隐藏的文件列表 123drwxrwxr-x d代表文件夹 -代表文件rwx（文件拥有者的权限） rwx（文件拥有的组的权限 ） r-x（其他用户的权限） 通配符 通配符 解释 * 代表人任意个字符 ？ 代表任意一个字符，至少是一个 [] 掉膘可以匹配字符组中的任意一个 [abc] 匹配abc中的任意一个 [a-f] 匹配a到f范围内的任意一个字符 配合通配符使用 12- ls *txt 查看当前文件夹下以txt结尾的所有文件- ls 1* 查看以1开头的文件 mkdir 如果有要创建的文件夹重名，不要内需创建 (make diectory) 创建文件夹（相对路径，当前目录下创建文件夹） 1234567891011- mkdir /home/admin/(绝对路径）- mkdir /home/admin 如果上级目录不存在，加上-p自动创建父目录、- mkdir a b 在当前目录创建多个文件夹- mkdir a/{c,d}在指定目录下创建多个文件夹- mkdir .abc 以.开头 创建隐藏目录- mkdir -p a1/b1/c1/d1 递归创建多个目录 touch 如果文件不存在，创建空文件。如果文件存在，修改文件的末次修改日期 12345- touch abc.txt 在当前目录下创建 如果指定了目录，必须保证上级目录存在- touch .abc 创建隐藏文件- gedit abc.txt使用记事本打开文本 rm 删除文件 1234567- rm a.txt 删除文件- rm -r abv 删除目录- rm -f 强制删除，忽略不存在的文件，没有提示- rm * 删除当前目录下的所有内容 ，不能删除隐藏文件 . 和 .. 删除不掉 cp复制 12cp a.txt b.txtcp ~/Document/readme.txt . #将家目录下的readme文件复制到当前目录中 mer 描述 -a 该选项通常在复制目录时候使用，它保留链接，文件属性，并递归分复制目录，总之保留文件原有的属性 -f 覆盖已经存在的目标文件而且不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有目录和文件，目标文件必须为一个目录名 -v 显示拷贝进度 mv移动 123- mv 1.txt 2.txt 重命名- mv 1.txt 目录/2.txt 查阅命令帮助信息123456command --help#例如rm --help#或者使用manman rm 使用man时候操作键 操作建 解释 空格 显示手册下一页 Enter 一次滚动手册的一页 b 回滚一页 r 前滚一页 q 退出 /word 搜索word字符串 其它命令行重定向echo 1echo hello linux #输出命令hello linux 重定向 &gt;和&gt;&gt; 12345命令/文件 将命令返回的数据写入文件中，若命令没有返回则文件为空 echo hello linux &gt; 1.txt #将hello linux写入文件 ls -lh &gt; 1.txt #将ls查看内容输出到文件中 把命令返回的结果输出到文件中，会覆盖之前的数据，默认情况命令返回的结果是显示在屏幕中 ls &gt;&gt; 1.txt 把命令返回的结果输出到文件中，追加的方式 管道linux允许一个命令的输出通过管道作为另外一个命令的输入 123ls -al/ 显示根目录下的文件ls -al/ | more 使用more命令分屏显示前面命令返回的结果ls -al/ | grep D 搜寻根目录文件中含有D的文件 find查找文件12find /home -name 1.txt 在/home 目录中查找文件名为1.txt的文件find /home -name '*txt' 在/home 目录中查找以txt结尾的文件 ln 链接 软链接 序号 命令 解释 1 ln -s 被链接的源文件 软链接名 软链接只记住文件名，指向文件名的文件，不会管文件内容，类似快捷方式 12使用软连接时候要使用绝对路径，方便移动文件后链接能够正常使用sudo ln -s /home/mk310/softlink.txt /home/softlink2 硬链接 和软连接相比少了个 -s选项 12345硬链接本身占空间，相当于把源文件复制一份，与源文件同步变化，不能给目录创建硬链接使用ll查看时，有一个数字在，代表有几个文件能同步发生变化ln 1.txt 1.hard_link Ubuntu的软件安装apt apt是Advanced Packing Tool，是Linux下的安装包管理工具 可以在终端中安装卸载更新 123456#安装软件sudo apt install software#卸载软件sudo apt remove software#更新已经安装的包sudo apt upgrade 文件内容命令 catconcatenate（连接合并）查看文件内容 12345678#显示全部内容cat 1.txt把文件的内容全部显示到屏幕中cat 1.txt 2. txtcat 1.txt 2.txt &gt; 3.txt把多个文件的内容合并到新的文件中cat -b 1.txt #显示文件内容的行数 more 1.txt #可以分屏显示 适合内容多的 查看操作和man相同 grep文本搜索LInux系统中grep命令是一个强大的文本搜索工具，grep允许对文本文件进行模式查找，如果找到匹配模式，grep打印包含模式的所有行 1grep [-选项] '搜索内容串' 文件名 在grep命令中输入字符串参数时候，最好引号扩起来 1grep 'a' 1.txt 选项 描述 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式 参数 描述 ^a 行首，搜寻以a开头的行：grep -n '^a' 1.txt end$ 行尾，搜寻以end结束的行：grep -n 'end$' 1.txt [Ss]igna[Ll] 行首行尾忽略大小写 . (点)匹配一个非换行符的字符; 匹配e和e之间有任意一个字符，可以匹配 eee，eae.eve，但是不匹配 ee，eaae; grep -n e.e’ 1.txt 远程管理命令关机重启 命令 描述 reboot 重新启动操作系统（不需要权限） shutdown -r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20:25 系统在今天的20:25关机 shutdown -h +10 系统在输入命令后十分钟自动关机 shutdown -c 取消关机 网卡信息命令 命令 释义 作用 ifconfig configure a network interface 查看和配置网卡配置信息 ping ip ping 检测到目标ip地址的连接是否正常 查看网卡对应的ip地址 ifconfig | grep inet 检测本地网卡是否正常 ping 127.0.0.1 SSh(secure shell)常见服务端口号列表： 服务 端口号 SSH服务器 22 web服务器 80 HTTPS 443 FTP 21 SSH简单使用 1ssh [-p port] user@remote uer是在远程服务器上的用户名 ，不指定默认就是当前用户 remote是远程机器的地址，可以是ip/域名，或者是别名 port是SSH Server监听的端口，如果不指定，默认22 使用exit退出当前用户的登录 ssh免密码登录 12345ssh-keygen #在.ssh文件夹下生成id_rsa 和 id_rsa.pub 文件ssh-copy-id mk310@172.168.0.109 #将授权文件送到远程服务器#之后不用输入密码就可以登录 配置别名 在.ssh/config中追加一下内容： 1234Host nickname HostName 192.168.0.101 User mk310 port 22 之后可以使用ssh nickname可以直接登录远程服务器 scpsecure copy 远程拷贝命令 123456789101112#将远程加目录下Desktop/1.py复制到本地目录下scp -P port user@remote:Desktop/1.py 1.py#把本地当前目录下的1.py文件复制到远程家目录下的Desktop/1.pyscp -P port 1.py user@remote:Desktop/1.py#加上-r可以传送文件夹#把当前目录下的demo文件夹复制到远程家目录下的Desktopscp -r demo user@remote:Desktop#把远程家目录下的Desktop 复制到当前目录下的demo文件夹中scp -r user@remote:Desktop demo 用户权限命令 who查看登陆用户信息 选项 描述 -q –count 只显示用户的登录账号和登录用户的数量 -u –heading 只列标题 chown修改文件/文件夹所有者 1sudo chown zhangsan python/ #将python文件所有者换为张三 chgrp 修改文件/文件夹所在组 1sudo chgrp -R zhangsan python/ #将python文件所在组换为张三，-R对文件夹递归操作 chmod修改文件权限 chmod修改文件权限有两种格式：字母法和数字法 1字母法：chmod u/g/o/a +/-/= rwx 文件 参数 描述 u user表示该文件的所有者 g group表示与该文件所有者一组的，即用户组 o other表示其他意外的人 a all表示这三者皆是 参数 描述 + 增加权限 - 减少权限 = 设定权限 参数 描述 r read 表示可以读取，没有r权限非可读 w write可写入权限 x excute可执行权限 数字法 参数 描述 r 代号4 w 代号2 x 代号1 - 代号0，不具备任何权限 1执行 chmod u = rwx,g = rx,o-f filename 相当于 chmod u = 7,g = 5,o = 4 filename 用户管理命令创建/设置密码/删除用户 序号 命令 作用 说明 01 useradd -m -g 组新建用户名 添加新用户 -m 自动建立用户家目录 -g指定用户所在的组，否则会建立一个和用户名同名的组 02 passwd 用户名 设置用户密码 普通用户可以直接用passwd修改 03 userdel -r 用户名 删除用户 -r 选项会自动删除家目录 04 cat /etc/passwd |grep 用户名 确认用户信息 新建用户信息保存在passwd文件 查看用户信息 序号 命令 解释 1 id username 查看用户UID和GID信息 2 who 查看当前所有登录的用户列表 3 whoami 查看当前登录用户的账户名 /etc/passwd存放的是用户信息： 用户名 密码（x表示加密） UID GID（组标识） 用户全名和本地账号 家目录 用户登录使用的Shell which查询命令在系统中的保存位置 /etc/passwd是用于保存用户信息的文件 /usr/bin/passwd是用于修改用户密码的程序 bin和sbin 在linux中大多数可执行文件保存在/bin /sbin /usr/bin /usr/sbin /bin（binary）是二进制执行文件目录，用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin （user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 su切换用户 序号 命令 作用 解释 1 su -username 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 2 exit 退出当前登录账户 系统信息命令时间date和cal 序号 命令 解释 1 date 查看系统当前时间 2 cal calendar 查看日历，-y选项可以查看一年的日历 磁盘信息 序号 命令 解释 1 df -h disk free 显示磁盘剩余空间 2 du -h 【目录名】 disk usage显示目录下的文件大小 进程信息 序号 命令 解释 1 ps aux process status 查看进程详细状况 2 top 动态显示运行中的进程并且进行排序 3 kill [-9] 进程代号 种植指定代号的进程 -9表示强行终止 ps默认只会显示当前用户通过终端启动的应用程序 选型 解释 a 显示终端上所有的进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 压缩命令 tar打包命令（没有压缩）12345678打包tar cvf a.txt *.txt解包tar xvf a.tar -C atar列出出档案内的名称tar tf tarName.tar tar很特殊，其参数前面可以使用-也可以不使用 参数 描述 -c 生成档案文档，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称 -t 列出档案中包含的文件 -x 解开档案文件 gzip文件压缩12345压缩打包后的文件gzip -r tarName.tar解压缩gzip -d tarName.tar.gz tar命令和gzip命令结合 1234一步打包压缩tar czf name.tar.gz *txt一步解压缩到指定文件夹tar xzf name name.tar.gz -C dciName bzip2文件压缩1234一步打包压缩tar cjf name.tar.gz *txt一步解压缩tar xjf name name.tar.gz -C dciName zip unzip 文件压缩1234压缩文件zip -r zname *txt将zname压缩到zz文件夹中unzip -d zz zname.zip 压缩率：zip&lt;gzip&lt;bzip2，zip最通用 其他命令编辑器Vim","link":"/2023/02/07/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"title":"11-Less","text":"Less（Leaner Style Sheets） Less基础1.维护CSS的弊端CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的 不方便维护及扩展，不利于复用 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目 2.Less介绍Less（Leaner Style Sheets 的缩写）是一门 CSS 扩展语言，也称为 CSS 预处理器。 做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性。 它在 CSS 的语法基础上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，Less 可以让我们用更少的代码做更多的事情。 Less 中文网址：Less 快速入门 | Less.js 中文文档 - Less 中文网 (bootcss.com) 常见的 CSS 预处理器：Sass、Less、Stylus 一句话：Less 是一门 CSS 预处理语言，它扩展了 CSS 的动态特性。 3.Less安装（注意如果使用VSCode无需安装Less）本质上，Less 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。 所以，我们需要把我们的 Less 文件，编译生成为 CSS 文件，这样我们的 HTML 页面才能使用。 【VSCode Less 插件】 vscode 的 Easy LESS 插件 这个插件可以自动将less文件转义成css文件关于配置 settings.json配置如下 12345&quot;less.compile&quot;: { &quot;compress&quot;: true, // true =&gt; remove surplus whitespace &quot;sourceMap&quot;: true, // true =&gt; generate source maps (.css.map files)将浏览器审查元素中css代码在css文件中的位置改成对应的less文件中的位置 &quot;out&quot;: true // false =&gt; DON'T output .css files (overridable per-file, see below)生成对应的css文件 } 只要保存一下 less 文件，会自动生成 CSS 文件。 4.注释(Comments) 多行注释保留 单行注释不被保留在编译生成的 CSS 中 123456789/* * 一个块注释 * style comment! */// 这一行被注释掉了！div { color: red;} 5.变量(Variables)变量是指没有固定值，可以改变的。因为我们 CSS 中的一些颜色和数值等经常使用。 @变量名: 值; 变量是指没有固定值，可以改变的。因为我们 CSS 中的一些颜色和数值等经常使用。 @变量名: 值; 5.1 变量命名规范 必须有 @ 为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 @color: pink; 5.2 基本使用12345678// 直接使用body { color: @color;}a:hover { color: @color;} 5.3 变量插值(Variable Interpolation)变量用于选择器名、属性名、URL、@import语句 12345678@my-selector: banner;// 需要添加 {}.@{my-selector} { font-weight: bold; line-height: 40px; margin: 0 auto;} 123456@property: color;.widget { @{property}: #0ee; background-@{property}: #999;} 12345678// Variables@images: '../img';// Usagebody { color: #444; background: url('@{images}/white-sand.png');} 12345// Variables@themes: '../../src/themes';// Usage@import '@{themes}/tidal-wave.less'; 5.4 延迟加载(Lazy Evaluation)当一个变量被声明多次，会取最后一次的值，并从当前作用域往外寻找变量。 12345678910@var: 0;.class { @var: 1; .brass { @var: 2; three: @var; @var: 3; } one: @var;} 编译后 123456.class { one: 1;}.class .brass { three: 3;} 5.5 属性名变量(Properties as Variables)1234.widget { color: #efefef; background-color: $color;} 编译后 1234.widget { color: #efefef; background-color: #efefef;} 6.嵌套(Nesting)6.1 基本使用Less 提供了使用嵌套(nesting)代替层叠或与层叠结合使用的能力 【我们经常用到选择器的嵌套】 123#header .logo { width: 300px;} 【less 嵌套写法】 12345#header { .logo { width: 300px; }} 用 Less 书写的代码更加简洁，并且模仿了 HTML 的组织结构。 6.2 父选择器 (Parent Selectors)在嵌套规则中， &amp; 表示父选择器，常用于给现有选择器添加伪类。 12345678.header { a { color: blue; &amp;:hover { color: green; } }} 编译后 123456.header a { color: blue;}.header a:hover { color: green;} 你还可以使用此方法将伪选择器（pseudo-selectors）与混合（mixins）一同使用。下面是一个经典的 clearfix 技巧，重写为一个混合（mixin） (&amp; 表示当前选择器的父级）： 12345678910111213.clearfix { display: block; zoom: 1; &amp;:after { content: &quot; &quot;; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; }} 7.混合(Mixins)混合(Mixin)是一种将一组属性从一个规则集包含(或混入)到另一个规则集的方式，可理解为复制粘贴。 7.1 普通混合 定义了一个bordered类 如果希望在其它规则集中使用这些属性，只需像下面这样输入所需属性的类（class）名称即可 1234567891011121314.bordered { border-top: dotted 1px black; border-bottom: solid 2px black;}#menu a { color: #111; .bordered;}.post a { color: red; .bordered();} 1234567891011121314.bordered { border-top: dotted 1px black; border-bottom: solid 2px black;}#menu a { color: #111; border-top: dotted 1px black; border-bottom: solid 2px black;}.post a { color: red; border-top: dotted 1px black; border-bottom: solid 2px black;} 12345678910// 使用类选择器时可以在选择器后边添加一个括号，这时我们实际上就创建了一个mixins// 这种是不会被识别进css.myMixin() { width: 400px; height: 400px;}.p4 { .myMixin; //.myMixin();都可以} 7.2 带参数的混合(Parametric Mixins) 混合带参数，参数需要按顺序传递 123456.border(@width, @style, @color) { border: @width @style @color;}div { .border(1px, solid, #ccc);} 123div { border: 1px solid #ccc;} 混合带参数并有默认值 需注意的是，就算有默认值，也要按顺序传递 1234567891011121314.border(@width, @style, @color: #ccc) { border: @width @style @color;}div { .border(1px, solid);}// 会出错.border(@width: 1px, @style, @color) { border: @width @style @color;}div { .border(solid, #ccc);} 7.3 命名参数可以在向混合传参是指定参数名称，从而不需要按顺序传入 123456.border(@width, @style, @color: #ccc) { border: @width @style @color;}div { .border(@style: solid, @color: red, @width: 100px);} 7.4 @arguments 变量@arguments 变量包含了传入的所有参数 12345678.box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) { -webkit-box-shadow: @arguments; -moz-box-shadow: @arguments; box-shadow: @arguments;}.big-block { .box-shadow(2px, 5px);} 12345.big-block { -webkit-box-shadow: 2px 5px 1px #000; -moz-box-shadow: 2px 5px 1px #000; box-shadow: 2px 5px 1px #000;} 7.5 匹配模式(Pattern-matching)在多个相同的混合中(参数个数必须相同)，匹配特定的混合。 12345678910111213141516.mixin(dark, @color) { color: darken(@color, 10%);}.mixin(light, @color) { color: lighten(@color, 10%);}// @_ 表示匹配所有，对应面两种选择（dark和light）.mixin(@_, @color) { display: block;}@switch: light;.class { .mixin(@switch, #888);} 1234.class { color: #a2a2a2; display: block;} 7.6 运算(Operations)任何数字、颜色或者变量都可以参与运算。就是 Less 提供了加（+）、减（-）、乘（*）、除（/）算术运算。 123456789/* Less 里面写 */@width: 10px + 5;div { border: @width solid red;}/* Less 甚至还可以这样 */width: (@width + 5) * 2; 【生成的 css】 123div { border: 15px solid red;} 注意： 乘号（*）和除号（/）的写法要牢记 运算符中间左右必须有个空格隔开 1px + 5 在新版本的 Less 中，除法有变动，应将 100px / 10 改为 (100px / 10)，否则没有效果 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 计算结果以操作数最左侧的单位类型为准 123456789101112131415@conversion-1: 5cm + 10mm; // 6cm@conversion-2: 2 - 3cm - 5mm; // -1.5cm@conversion-3: 3.1 * 2cm; // 6.2cm@conversion-4: 4px / 2; // 4px / 2// conversion is impossible@incompatible-units: 1cm - 1px; // 0.97354167cm// example with variables@base: 5%;@filler: @base * 2; // 10%@other: @base + @filler; // 15%@color: #224488 / 2; // #112244background-color: #112244 + #111; // #223355 8.继承(Extend)Extend Syntax 继承可让多个选择器应用同一组属性，最终编译为并集选择器 其性能比混合高，但灵活性比混合低 1234567nav ul { &amp;:extend(.inline); background: blue;}.inline { color: red;} 1234567nav ul { background: blue;}.inline,nav ul { color: red;} 9.避免编译通过加引号可以避免 Less 编译，直接把内容输出到 CSS 中 1234.banner .inline .header { width: '100px + 100px'; height: 100px + 100px;} 1234.banner .inline .header { width: '100px + 100px'; height: 200px;} 10.函数（Functions）Less 内置了多种函数用于转换颜色、处理字符串、算术运算等。这些函数在Less 函数手册中有详细介绍。 函数的用法非常简单。下面这个例子将介绍如何利用 percentage 函数将 0.5 转换为 50%，将颜色饱和度增加 5%，以及颜色亮度降低 25% 并且色相值增加 8 等用法： 12345678@base: #f04615;@width: 0.5;.class { width: percentage(@width); // returns `50%` color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8);} 11.导入（Importing）你可以导入一个 .less 文件，此文件中的所有变量就可以全部使用了。如果导入的文件是 .less 扩展名，则可以将扩展名省略掉： 123@import url(&quot;syntax.less&quot;);//url可以不加但是可能会有问题@import &quot;library&quot;; // library.less@import &quot;typo.css&quot;; 12.导出手动给每个less文件指定导出 导出必须写到第一行 12// out: 路径/文件名// out: ./mycss/pink.css 设置导出： 当面目录下，创建一个 mycss 文件夹， 生成 一个 pink.css （做了改名） 1// out: ./mycss/ 设置导出： 当面目录下，创建一个 mycss 文件夹， 生成 一个 跟less一样的文件名（原名） less 禁止导出 1// out: false","link":"/2024/06/01/Less/"},{"title":"MySQL","text":"MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 https://blog.csdn.net/qq_48584557/article/details/130456706 MySQl安装和基本使用安装教程：MySQL 8.0保姆级下载、安装及配置教程（我妈看了都能学会）_哔哩哔哩_bilibili 使用Mariadb，安装需要设置编码为UTF-8，管理用户设置为root，密码设置为1111 下载地址：Download MariaDB Server - MariaDB.org MySQL的数据类型 类型 描述 int 整型 bigint 长整型 float 浮点型 double 浮点型 datetime 日期类型 timestamp 日期类型（可存储时间戳） char 定长字符 varchar 不定长字符 text 大文本，用于存储很长的字符内容 blob 字节数据类型，存储图片，音频等文件 建表操作语法1234567-- 删除表DROP TABLE IF EXISTS tabelename;-- 新建表creat tabel tablename( 字段名 类型 约束 (主键,非空,唯一,默认值) 字段名 类型 约束 (主键,非空,唯一,默认值))编码,存储引擎; 在SQL中，我们有如下约束: NOT NULL:指示某列不能存储NULL值。 UNIQUE :保证某列的每行必须有唯一的值。 PRIMARY KEY :NOT NULL和UNIQUE的结合。确保某列(或两个列多个列的结合)有唯一标识， 有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY :保证- 个表中的数据匹配另一 个表中的值的参照完整性。 CHECK :保证列中的值符合指定的条件。 DEFAULT :规定没有给列赋值时的默认值。 实例12345678910DROP TABLE IF EXISTS websites;CREATE TABLE websites( id int(11) NOT NULL AUTO_INCREMENT, name char(20) NOT NULL DEFAULT '' COMMENT ' 站点名称', url varchar(255) NOT NULL DEFAULT '', alexa int(11) NOT NULL DEFAULT '0' COMMENT '排名', sal double COMMENT '广告收入', country char(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入删除更新插入语句1INSERT INTO websites(NAME,url,alexa,sal,country)VALUES('腾讯','https://www.qq.com',18,1000,'CN'); 删除语句1DELETE FROM websites WHERE id = 2; 更新语句1UPDATE websites SET sal =NULL WHERE id =1; 基本select查询语句创建一个表 123456789101112131415161718192021222324252627282930313233DROP TABLE IF EXISTS websites;CREATE TABLE websites( id INT(11) NOT NULL AUTO_INCREMENT, name CHAR(20) NOT NULL DEFAULT '' COMMENT ' 站点名称', url VARCHAR(255) NOT NULL DEFAULT '', alexa INT(11) NOT NULL DEFAULT '0' COMMENT '排名', sal DOUBLE COMMENT '广告收入', country CHAR(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY(id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO websites VALUES (1,'Google', 'https ://www. goog1e.cm/','1',2000,'USA'), (2,'淘宝', 'https://www. taobao .com/','13',2050,'CN'), (3,'菜鸟教程','http://www. runoob.com/', '4689',0.0001, 'CN'), (4,'微博','http://weibo.com/', '20',50, 'CN'), (5,' Facebook', 'https://www. facebook .com/','3',500,'USA');CREATE TABLE If NOT EXISTS access_log ( aid INT(11) NOT NULL AUTO_INCREMENT, site_id INT(11) NOT NULL DEFAULT '0' COMMENT '网站id', COUNT INT(11) NOT NULL DEFAULT '0' COMMENT '访问次数', DATE DATE NOT NULL, PRIMARY KEY (aid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO access_log (aid,site_id, COUNT, DATE) VALUES (1, 1, 45,'2016-05-10'), (2,3,100, '2016-05-13'), (3,1, 230, '2016-05-14'), (4, 2, 10, '2016-05-14'), (5,5,205, '2016-05-14'), (6,4,13, ' 2016-05-15'), (7,3,220, ' 2016-05-15'), (8,5,545, '2016-05-16'), (9,3,201, '2016-05-17'), (10, 88,9999, ' 2016-09-09'); 查找全部信息12-- 一般不使用*查找全部SELECT id ,NAME ,url,alexa,sal,country FROM websites 分页查询 mysql的分页查询是最优雅的 1234-- 从下标为2开始查找，查找三条SELECT * FROM websites LIMIT 2,3;-- 从最开始查找，查找三条SELECT * FROM websites LIMIT 3; distinct关键字 distinct用于返回唯一不同的值 12-- 返回多个相同的国家，distinct关键字合并相同的返回值SELECT distinct country FROM websites where语句 作为条件筛选，运算符：&gt;&lt;= , is NULL, is not NULL 因为在sql语句中null和任何东西相比较都是假，包括它本身 like in 逻辑条件and，or1234SELECT * FROM websites WHERE sal &gt;=0 AND sal &lt;=200;SELECT * FROM websites WHERE sal BETWEEN 0 AND 2000;SELECT * FROM websites WHERE sal &lt;5 OR sal IS null order by12-- 先按照sal升序排列，然后按照alexa降序排列SELECT * FROM websites ORDER BY sal ASC , alexa DESC; like和通配符模糊查找 12345-- 多个字符0多个字符SELECT * FROM websites WHERE NAME LIKE '%o%'-- 一个字符0多个字符SELECT * FROM websites WHERE NAME LIKE '_o%' in12-- 从国家是CN或者是CA选中SELECT * FROM websites WHERE country IN ('CN','CA') 别名12-- tt是websites的别名 销量是tt.sal的别名SELECT tt.sal &quot;销量&quot; FROM websites tt Group by分组查询 注意：分组的时候沙宣使用having 常见的几个组函数：max() min() avg() count() sum() 1SELECT AVG(sal) &quot;average&quot; FROM websites GROUP BY country HAVING average &gt; 1000 子查询 嵌套查询 1SELECT id FROM websites WHERE NAME IN (SELECT NAME WHERE sal &gt; 2001) 连接查询1234SELECT * FROM websites w JOIN access_log a -- 两表相关联ON w.id = a.site_id -- 关联条件WHERE sal &gt; 2000 -- 筛选条件 Null处理函数1ifull(date,'无') --如果数据为null 显示为无 经典练习","link":"/2023/02/24/MySQL/"},{"title":"SaSS","text":"SASS是对CSS3（层叠样式表）的语法的一种扩充，它可以使用巢状、混入、选择子继承等功能，可以更有效有弹性的写出Stylesheet。Sass最后还是会编译出合法的CSS让浏览可以使用，也就是说它本身的语法并不太容易让浏览器识别（虽然它和CSS的语法非常的像，几乎一样），因为它不是标准的CSS格式，在它的语法内部可以使用动态变量等，所以它更像一种极简单的动态语言。 安装使用在vscode扩展中搜索easy sass并安装 在项目文件夹中新建test.scss文件,编写后保存生成css文件 变量申明变量的概念 使用美元符号$ 注意声明的顺序(要在变量使用前声明) 可以在一个变量中引用另一个变量 调用变量时候依然使用美元符号加变量名 123456789101112//scss文件//不同变量可以相互引用，但是要注意声明顺序$demo-color:pink;$demo-border: 1px solid $demo-color;.nav-border{ border: $demo-border;}//生成css文件.nav-border { border: 1px solid pink;} 嵌套 使用Sass可以轻松的将多个内容嵌套在一起 不用像css一样需要分开写 12345678910111213141516171819202122/*可以尽情使用sass语法实现css无法实现的套娃操作*/#content{ div{ h1{border: 1px solid #000;} p{border: 1px solid #000;} }}//css/*可以尽情使用sass语法实现css无法实现的套娃操作*/#content div h1 { border: 1px solid #000;}#content div p { border: 1px solid #000;} &amp;符号将该符号后面的内容与其父元素直接进行连接,不用像平常的嵌套子元素一样与父元素使用空格进行连接 12345678910111213141516//&amp;符号article a{ color: #000; &amp;:hover{ color: #fff; }}//css文件article a { color: #000;}article a:hover { color: #fff;} 群组嵌套子元素会和父元素一一配对 反之亦然,如果父元素使用逗号隔开,那么每个父元素都会和子元素一一配对 1234567891011//群组嵌套#content{ h1,h2,h3,h4{ border: 1px solid #000; }}//css#content h1, #content h2, #content h3, #content h4 { border: 1px solid #000;} 多重选择器可以在嵌套层中使用多种选择器 +相邻兄弟选择器 &gt;子元素选择器 ~后继兄弟选择器 123456789101112131415161718192021222324252627//选择器#strick{ &gt; h1{border: #000;} + h2{border: #000;} th &gt; { dt{margin: auto;} dd{margin: auto;} }}//css#strick &gt; h1 { border: #000;}#strick + h2 { border: #000;}#strick th &gt; dt { margin: auto;}#strick th &gt; dd { margin: auto;} 多属性叠写如果需要一次指定border-width,borde-style 12345678910111213// 多属性叠写#border-test{ border: { width: 1px; style: solid; }}//css文件#border-test { border-width: 1px; border-style: solid;} import使用方法: 导入外部scss文件,注意不需要添加后缀.scss 不可以导入css文件 scss文件编译时候,优先把导import导入的文件进行编译并插入到输出css文件头部中,之后才会编译本文件中的内容 可以导入scss文件中的局部内容@import &quot;./part/abc&quot;,这样就导入part.scss文件中的abc 1234567891011121314151617181920212223//part.scss文件part{ margin-top: auto;}//test.scss文件@import &quot;part&quot;;// 多属性叠写#border-test{ border: { width: 1px; style: solid; }}//生成的test.css文件part{ margin-top: auto;}#border-test { border-width: 1px; border-style: solid;} !default如果这个变量被声明赋值了,就使用它声明的值,否则使用默认值 123456789101112//默认值$default-border: 1px solid #000 !default;div{ border:$default-border }//css文件div { border: 1px solid #000;} @mixin混合可以作为一个大型的结构体 @mixin name{} 在任意处使用@include即可把@mixin定义内容引入 12345678910111213141516//混合@mixin border-test{ border: 1px solid #000; padding: 10px;}notice{ @include border-test;}//css文件notice { border: 1px solid #000; padding: 10px;} @mixin嵌套解构mixin中可以写入任意的解构,可以使用多种选择器 123456789101112131415161718192021222324252627282930@mixin mixintest{ demo{ &gt; h1{color: #000;} + div{ div.echo &amp; { border: 1px solid #000; } &amp;:hover{ color: #fff; } } } }asideTest{ @include mixintest;}//css生成文件asideTest demo &gt; h1 { color: #000;}div.echo asideTest demo + div { border: 1px solid #000;}asideTest demo + div:hover { color: #fff;} @mixin函数@mixin声明名称后小括号中写入函数形参,注意变量的声明形式 调用是使用小括号传入实参即可 可以定义带有默认值的形参 1234567891011121314151617//mixin函数@mixin mixin-function($a,$b,$c){ color:$a; background-color:$b; border:$c;}a{ @include mixin-function(#000,#fff,1px solid #000);}//css生成文件a { color: #000; background-color: #fff; border: 1px solid #000;} 注释 普通注释//编译后不会显示在css中 多行注释/**/编译后会显示在css中 继承使用@extends name来使用继承关系,引入名称(或者部分名称)为name的选择器 @extend 指令告诉 Sass 一个选择器的样式从另一选择器继承。 如果一个样式与另外一个样式几乎相同，只有少量的区别，则使用 @extend 就显得很有用。 以下 Sass 实例中，我们创建了一个基本的按钮样式 .button-basic，接着我们定义了两个按钮样式 .button-report 与 .button-submit，它们都继承了 .button-basic ，它们主要区别在于背景颜色与字体颜色，其他的样式都是一样的。 123456789101112131415161718192021222324252627282930313233343536.button-basic { border: none; padding: 15px 30px; text-align: center; font-size: 16px; cursor: pointer;}.button-report { @extend .button-basic; background-color: red;}.button-submit { @extend .button-basic; background-color: green; color: white;}//生成css文件.button-basic, .button-report, .button-submit { border: none; padding: 15px 30px; text-align: center; font-size: 16px; cursor: pointer;}.button-report { background-color: red;}.button-submit { background-color: green; color: white;}","link":"/2024/10/22/SaSS/"},{"title":"cactus主题的使用配置","text":"创建标签页，分类页，搜索页以标签页为例子 1hexo new page tags 进入创建的tags文件夹中，将index.md中的title中添加type:tag 创建搜索页 1hexo new page search 进入创建的tags文件夹中，将index.md中的title中添加type:search.同时安装本地搜索插件 hexo-generate-search 1cnpm install hexo-generator-search --save 主题配置文件主要选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139############################################################################### Content############################################################################### Link to a page that gives an overview of all your projects.# This can be an external link (e.g., to you GitHub profile) or to another# page within your website.#链接到giteeprojects_url: http://gitee.com# Set the page direction to RTL or LTR. default is LTR. (if you set it 'rtl', the 'vazir' font will be loaded.)#菜单栏在左（ltr），右（rtl）direction: ltr# Configure the navigation menu.# A pair 'Key: url' will result in a link to 'url' with the name 'Key' in the# navigation menu. Optionally, you can add translations for the 'Key' in# languages/*.yml#导航栏设置nav: home: / articles: /archives/ category: /categories/ tag: /tags/ search: /search/ about: /about/ projects: http://gitee.com/# Links to your social media accounts.# The keys should correspond to Fontawesome icon names# (see https://fontawesome.com/icons?d=gallery&amp;s=brands);# only 'mail' is an exception.#社交媒体账号social_links: github: http://gitee zhihu: https://zhuanlan.zhihu.com/ magnifying-glass: https://www.baidu.com/ mail: https://mail.qq.com/# Customize the overview with displaying a tagcloud on the index page.# Options: https://hexo.io/docs/helpers.html#tagcloud# 在首页显示文章，生成tag云tags_overview: true# Customize the overview with the most recent blog posts on the index page.# Options:# - show_all_posts: whether to show all available posts.# - post_count: whether to show only the x most recent posts.# - sort_updated: sort posts by last modification date instead of creation date.posts_overview: show_all_posts: false post_count: 5 sort_updated: true# Customize the archive view.# Options:# - sort_updated: sort posts by last modification date instead of creation date.# Note: this does not work together with pagination, since the pagination# plugin will sort pages by date of creation.#归档中的文章按照更新日期排序archive: sort_updated: true# Customize the article view.# Options:# - show_updated: show the last modification date.#显示修改日期post: show_updated: true# Customize the copyright years# Note: if start_year/end_year not provided, will use current year.copyright: start_year: 2018 end_year: 2023# Customize the 404 page# Options:# - enabled: whether to enable the 404 page (404.html).#定义404页error_404: enabled: true title: &quot;404 Page Not Found&quot; description: &quot;The page you are looking for might have been removed, had its name changed, or is temporarily unavailable.&quot;############################################################################### Look and Feel############################################################################### Customize the logo (i.e., the cactus) in the header.# Options:# - enabled: whether to show (true) or hide (false) the logo.# - width: width of the logo in pixel units# - height: height of the logo in pixel units# - url: where the logo can be found# - gravatar: whether to use your Gravatar as the logo# - grayout: whether to enable a hover effect on the logo# 图标显示logo: enabled: true width: 50 height: 50 url: /images/logo.png gravatar: false grayout: true# Customize the favicons.# Cactus supports a limited set of the three most important icons:# - desktop: The classic favion.ico file.# - android: A 192x192 PNG file.# - apple: A 180x180 PNG file.# These can be generated with http://realfavicongenerator.net/# Options:# - url: where the icon can be found# - gravatar: whether to create a favicon from your Gravatarfavicon: desktop: url: /images/favicon.ico gravatar: false android: url: /images/favicon-192x192.png gravatar: false apple: url: /images/apple-touch-icon.png gravatar: false# The color scheme that should be used to highlight codeblocks.# See source/css/_highlight for a list of all available color schemes.#代码高亮，样式在主题文件夹中highlight: idea# Set the color scheme.# Available color schemes are 'dark', 'light', 'classic' and 'white'.# Alternatively, add your own custom color scheme to source/css/_colors.# 页面显示颜色：黑色 灰色 米黄色 白色colorscheme: classic# Maximal width of the page in rem units.page_width: 48 Hexo基本信息配置站点名称语言 12345678# Sitetitle: Hexosubtitle: ''description: ''keywords:author: mk310language: zh-CNtimezone: '' gitee部署 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git branch: master repo: https://gitee.com/SmashDog1/SmashDog1 配置邮箱和用户名 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 使用hexo d命令部署，然后会提示用户名和密码输入后上传成功","link":"/2023/01/17/cactus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"call,apply和arguments","text":"JS call，apply，arguments call()和apply()这两个方法都是函数对象的方法，需要通过函数对象来调用 当对函数调用 call()和apply()都会调用函数执行 1234567891011var obj = { name: &quot;obj&quot;};var obj2 = { name:&quot;obj2&quot;}function fun(){ console.log(this.name);}fun.call(obj); // objfun.call(obj2); // obj2 在调用call()和apply()可以将一个对象指定为第一个参数此时这个对象将会成为函数执行时的this call()方法可以将实参在对象之后依次传递 apply()方法需要将实参封装到一个数组中统一传递 12345function fun(a, b){ console.log(&quot;a = &quot; + a + &quot;, b = &quot; + b);}fun.call(obj, 2, 3); // a = 2, b = 3fun.apply(obj, [2, 3]); // a = 2, b = 3 this的情况 以函数的形式调用时，this永远都是window 以方法的形式调用时，this是调用方法的对象 以构造函数的形式调用时，this是新创建的那个对象 使用call和apply调用时，this是指定的那个对象 arguments在调用函数时，浏览器每次都会传递进两个隐含的参数： 函数的上下文对象this 封装实参的对象arguments arguments是一个类数组对象（并非数组），可以通过索引来操作数据，也可以获取长度 12345function fun1(){ console.log(arguments instanceof Array); // false console.log(Array.isArray(arguments)); // false}fun1(); 在调用函数时，我们所传递的实参都会在arguments中保存 我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦 arguments[0]表示第一个实参 arguments[1]表示第二个实参 12345function fun2(a,b,c){ console.log(&quot;arguments.length = &quot; + arguments.length + &quot;, arguments[0] = &quot; + arguments[0]); }fun2(&quot;hello&quot;); // arguments.length = 1, arguments[0] = hellofun2(true, &quot;hello&quot;); // arguments.length = 2, arguments[0] = true 它里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在执行的函数对象 12345678function fun3(){ console.log(arguments.callee); // function fun3(){ // console.log(arguments.callee); // } console.log(arguments.callee == fun3); // true}fun3();","link":"/2024/04/26/call,apply%E5%92%8Carguments/"},{"title":"css_exercise","text":"exercise exercise_1-京东图片列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;图片列表&lt;/title&gt; &lt;!-- 引入css,去除预设值的css样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;style&gt; /* 设置背景方便观察 */ body{ background-color:antiquewhite; } ul{ width: 190px; height: 470px; /* 居中对齐 */ margin: 40px auto; /* 设置背景颜色 */ background-color: aliceblue; } ul li:not(:last-child){ /* 设置li之间的外边距 */ /* 除掉最后一个孩子元素其他元素下边距为20px */ margin-bottom: 20px; } ul&gt;li img{ /* 这里只需要修改宽度为父元素百分百,css自动按照图片原比例缩小 */ width: 100%; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img1/01.png.avif&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img1/02.png.avif&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img1/03.jpg.avif&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： exercise_2-京东文字列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文字列表&lt;/title&gt; &lt;!-- 清除默认样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;style&gt; /* 设置网页背景 */ body{ background-color: bisque; } .left-nav{ width: 200px; height: 300px; background-color: azure; /* 居中 */ margin: 20px auto; /* 设置内边距 */ padding: 10px 0px; } .left-nav .item{ height: 25px; /* 要让一个文字再父元素中垂直居中,只需将父元素的line-height设置为同父元素一个值就好 */ line-height: 25px; /* 设置margin向右移动item的阴影覆盖不到 */ padding: 0px 8px; } .item:hover{ background-color: #d9d9d9; } /* 设置超链接样式 */ a{ text-decoration: none; font-size: 14px; color: #333; } a:hover{ color: #c81623; } .item span{ padding: 0 2px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;left-nav&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;运营商&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;数码&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;电脑&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;办公&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;家具&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;家居&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;家装&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;厨具&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;男装&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;女装&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;童装&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;内衣&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;美妆&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;个护清洁&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;宠物&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;女鞋&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;箱包&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;钟表&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;男鞋&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;运动&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;户外&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;房产&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;汽车&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;汽车用品&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;母婴&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;玩具乐器&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;食品&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;酒类&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;生鲜&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;特产&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;艺术&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;礼品鲜花&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;农牧园艺&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;a href=&quot;#&quot;&gt;京东买药&lt;/a&gt; &lt;span&gt;/&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;计生情趣&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; exercise_3-网易新闻列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;网易新闻列表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/reset.css&quot;&gt; &lt;style&gt; body { background-color: antiquewhite; } .news-wrapper { background-color: azure; width: 300px; height: 362px; margin: 40px auto; } /* 去除超链接默认下划线 */ a { text-decoration: none; } .news-title { height: 40px; border-top: 1px #ddeedd solid; } .news-title&gt;h2 { width: 32px; height: 24px; line-height: 24px; padding-top: 6px; margin-left: 10px; border-top: 1px red solid; margin-top: -1px; } /* 标题样式 */ .news-title a { color: #404040; font-weight: bold; } .news-title a:hover { color: red; } /* 列表图片 */ .news-img { height: 150px; } .news-img .img-title { color: #fff; font-size: bold; height: 48px; line-height: 48px; margin-top: -48px; margin-left: 20px; } /* 新闻列表 */ .news-list { margin-top: 27px; } .news-list li { width: 285px; height: 30px; line-height: 30px; padding-left: 10px; } .news-list a { /* 新闻列表字体样式 */ font-size: 14px; color: #666; } .news-list a:hover { /* 新闻列表悬浮样式 */ color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 创建新闻列表的容器 --&gt; &lt;div class=&quot;news-wrapper&quot;&gt; &lt;!-- 新闻标题 --&gt; &lt;div class=&quot;news-title&quot;&gt; &lt;h2&gt;&lt;a href=&quot;#&quot;&gt;体育&lt;/a&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;news-img&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img3/01.jpg&quot; alt=&quot;梅西&quot;&gt; &lt;div class=&quot;img-title&quot;&gt; &lt;h2&gt;恰尔汗奥卢30岁生日，国米官方庆生&lt;/h2&gt; &lt;/div&gt; &lt;/a&gt; &lt;ul class=&quot;news-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;论梅球王的倒掉&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;一份医保，难倒10年NBA老兵&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;全明星票王胡明轩，已经是“超级高水&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;冰球场上的割喉惨案：意外还是谋杀？&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2024/02/11/css-exercise/"},{"title":"flask","text":"环境python环境 保证python在3.6以上 flask安装 1pip3 install flask 基础配置项目文件结构 FlaskDemo （项目文件名） statc（静态文件存储） template（html代码存储） app.py（主程序代码） 基础代码12345678910111213141516# 从flask这个包中导入Flask类from flask import Flask# 使用Flask类创建一个app对象# __name__: 代表app.py这个模块# 作用1:以后出现bug可以帮助进行快速定位# 作用2:对于寻找模板文件,有一个相对路径app = Flask(__name__)# 创建一个路由和视图函数的映射@app.route('/')def hello_world(): return 'hello world'if __name__ == '__main__': app.run() 项目配置123456789#开启debug模式if __name__ == '__main__': app.run(debug=True) #修改host使得同局域网主机可以访问#修改端口当默认端口被占用的时候可以更改 URL与视图（参数传递）1234567891011121314151617# 访问 /second/123 返回 the netcode is 123# int:netcode 强制netcode为整型@app.route('/second/&lt;int:netcode&gt;')def secondcode(netcode): return 'the netcode is %s' % netcode# 查询字符串方式传参@app.route('/book/list')def book_list(): # arguments:参数 # requset.args:类字典类型 page = request.args.get('page',default=1,type=int) return f&quot;你获取的是第{page}页的数据&quot;# http://127.0.0.1:5000/book/list?page=3 返回 你获取的是第3页的数据# 没有输入page默认返回1 后续有get post请求 模板渲染（jinja2）12345后端@app.route(&quot;/blog/&lt;blog_id&gt;&quot;)def blog_detail(blog_id): # 返回渲染的blog_detail文件同时将路径中传入的参数blog_id从后端传入前端 return render_template(&quot;blog_detail.html&quot;,blog_id =blog_id,userName=&quot;mk&quot;) 12345前端&lt;!-- 通过双花括号引用后端传入的数据 --&gt;&lt;title&gt;This is my blog&lt;/title&gt;&lt;h1&gt;your blog_id is {{blog_id}}&lt;/h1&gt;&lt;h1&gt;your userName is {{userName}}&lt;/h1&gt; 模板访问对象属性1234567891011121314后端# 通过创建一个类来实例一个对象传参class User: def __init__(self,username,email): self.username = username self.email = email@app.route('/')def hello_world(): # 创建一个user对象 user = User(username=&quot;mk310&quot;,email = &quot;xxxx@qq.com&quot;) # 返回渲染后的index超文本文件,和创建好的user return render_template(&quot;index.html&quot;,user = user) 1&lt;h1&gt;用户名是{{user.username}},邮箱是{{user.email}}&lt;/h1&gt; 123456同时还可以使用字典来传参person = { &quot;username&quot;:&quot;mk&quot;, &quot;email&quot;:&quot;xxx@qq.com&quot;}&lt;div&gt;{{person['username']}}&lt;/div&gt; 过滤器的使用123 &lt;!-- 通过管道符号 | 来实现 --&gt;&lt;h1&gt;用户名{{user.username}}的长度是{{user.username|length}}&lt;/h1&gt;返回用户名mk310的长度是5 常用过滤器【Flask框架】——12 Jinja2模板-过滤器_jinja2 自定义过滤器-CSDN博客 控制语句12345678910if语句{% if age &gt;10 %}&lt;div&gt;宁的年龄已满18&lt;/div&gt;{% else %}&lt;div&gt;宁的年龄不满18&lt;/div&gt;{% endif %}for语句{% for book in books %}{% endfor %} jinja2中没有break语句,循环必须有限 模板继承子模板从父模板中继承绝大数样式,同时可以通过block语句自定义需要的样式 文件： template father.html child1.html 1234567891011121314father.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 在父模板中定义主要的样式同时留出自定义的空间block title为可定义的名称 --&gt; &lt;title&gt;{% block title %} {% endblock %}&lt;/title&gt; &lt;h1&gt;父亲模板的文字&lt;/h1&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 123456789child1.html&lt;!--从父模板中继承主要的样式--&gt;{% extends &quot;father.html&quot; %}&lt;!--在子模版中自定义标题--&gt;{% block title %}子模板的title{% endblock %} jinja2中加载静态文件 flask中静态文件默认放在static文件夹中 12同时可以对样式表和js使用同种方式&lt;img src=&quot;{{url_for('static',filename='2.jpg')}}&quot; &gt; 数据库连接123456#首先给pip换成豆瓣源pip config set global.index-url https://pypi.douban.com/simple/#设置后若返回 https://pypi.douban.com/simple/ 则设置成功pip config get global.index-url 复习一下数据库 12345安装pymysqlpip install pymysql安装Flask-SQLAlchemypip install flask-sqlalchemy 连接数据库： 1234567891011121314151617181920212223242526272829303132from flask_sqlalchemy import SQLAlchemyfrom sqlalchemy import textapp = Flask(__name__)# MySQl所在的主机名HOSTNAME = &quot;127.0.0.1&quot;#MySQl监听的端口号PORT = &quot;3306&quot;#连接MySQl的用户名是用户自己设置的USERNAME = &quot;root&quot;#连接数据库的密码PASSWORD = &quot;1111&quot;# 数据库中创建的数据库名称DATABASE = &quot;database_learn&quot;app.config['SQLALCHEMY_DATABASE_URI'] = f&quot;mysql+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8mb4&quot;# 在app.config中设置好连接数据库的信息# 使用SQlAlchemy(app)创建一个对象# SQlAlchemy会自动读取信息db = SQLAlchemy(app)# 测试连接代码 无实际意义# 获取引擎连接with app.app_context(): with db.engine.connect() as conn: # 执行语句 rs = conn.execute(text(&quot;select 1&quot;)) # 查看返回值,若为1连接成功 print(rs.fetchone()) ORM模型对象关系映射（Object Relationship Mapping）python面向对象的方式来操作关系型数据库的技术,一个ORM模型和数据库中的一个表相对应,ORM模型中的每个类属性分别对应表的每个字段.ORM模型的每个实例对象对应表中的每个记录,ORM技术提供了面向对象和SQL交互的桥梁. 优势: 开发效率高,几乎不用写原生sql语句 安全性高 灵活性强,跟换数据库只需小改少量代码 创建表和基本字段 12345678910111213# 继承属性class User(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) # 定义字段,字符型,不可为空 username = db.Column(db.String(100),nullable=False) password = db.Column(db.String(100), nullable=False)# user = User(username=&quot;张三&quot;,password=&quot;1111&quot;)# 把表同步到数据库中去with app.app_context(): db.create_all() CRUD（Create Read Update Delete）123456789101112131415161718192021222324252627282930313233343536373839Create添加数据# 在打开网页后数据库中才会添加数据@app.route(&quot;/user/add&quot;)def add_user(): user = User(username=&quot;张三&quot;,password=&quot;1111&quot;) db.session.add(user) db.session.commit() # 防止报错 没有可用的response对象 添加返回 return &quot;添加用户成功&quot;Read查询@app.route(&quot;/user/query&quot;)def query_user(): # 1.get查找 根据主键查找 user = User.query.get(1) print(f&quot;{user.id}:{user.username}-{user.password}&quot;) # 2.filter_by查找 # users是Query类型 是类数组 users = User.query.filter_by(username=&quot;张三&quot;) for user in users: print(user.username) # 另外看一下其他查找操作 return(&quot;查找成功&quot;)Update该@app.route(&quot;/user/update&quot;)def update_user(): user = User.query.filter_by(username=&quot;张三&quot;).first() user.password = &quot;2222&quot; db.session.commit() return &quot;数据修改成功&quot;Delete删除@app.route(&quot;/user/delete&quot;)def delete_user(): user = User.query.get(2) db.session.delete(user) db.session.commit() return &quot;数据删除成功&quot; 表关系关系型数据库一个强大的功能，就是多个表之间可以建立关系。 通过给Article添加外键，建立和User之间的关系 1234567891011121314class Article(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(200),nullable=False) content = db.Column(db.Text,nullable=False) # 添加外键 数据类型和被引用表中的数据类型保持一致 author_id = db.Column(db.Integer,db.ForeignKey(&quot;user.id&quot;)) # relationship相当于 返回article.author = User.query.get(&quot;article.author_id&quot;) author = db.relationship(&quot;User&quot;)artical = Article(title=&quot;Flask_study&quot;,content=&quot;flaskxxxxxxxxxx&quot;) 12345678910111213141516171819202122232425262728class User(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) # 定义字段,字符型,不可为空 username = db.Column(db.String(100),nullable=False) password = db.Column(db.String(100), nullable=False) articles = db.relationship(&quot;Article&quot;,back_populates = &quot;author&quot;)class Article(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(200),nullable=False) content = db.Column(db.Text,nullable=False) # 添加外键 数据类型和被引用表中的数据类型保持一致 author_id = db.Column(db.Integer,db.ForeignKey(&quot;user.id&quot;)) # relationship相当于 返回article.author = User.query.get(&quot;article.author_id&quot;) # back_populates指数据从User表中的author传入 author = db.relationship(&quot;User&quot;,back_populates = &quot;articles&quot;) 此时可以通过这种方法查找到一个人的所有文章@app.route(&quot;/article/query&quot;)def article_query(): user = User.query.get(4) for article in user.articles: print(article.title) 数据库的更新create_all不能识别模型中的变化,只能识别新增模型,弃用 使用migrate更新数据库,首先pip安装之后引入 1234567migrate = Migrate(app,db)# ORM模型映射三步骤# 1.flask db init:这步只要做一次# 2.flask db migrate:识别ORM模型变化,生成迁移脚本# 3.flask db upgrade:将变化同步到数据库中","link":"/2023/01/18/flask/"},{"title":"flex布局","text":"CSSflex弹性盒 弹性盒子概念 Flex容器（flex container）：采用Flex布局的元素的父元素； Flex项目（flex item）：采用Flex布局容器里面的子元素； 主轴（cross axis）：触发弹性盒子之后，项目的排列方向 侧轴 （main axis）：触发弹性盒子之后，与主轴对立的方向 注意：角触发弹性盒子之后，项目默认沿主轴排列。 触发弹性盒子1display:flex; 触发弹性盒之后的特点 父元素触发弹性盒子之后，子元素默认横向显示 父元素触发弹性盒子之后，子元素会横向显示，类似浮动但是和浮动没有关系 变化的效果不会影响孙子辈元素 触发弹性盒子之后，会改变子元素的元素类型，会让子元素变成块级元素 触发弹性盒子之后，如果只有一个子元素，给子元素添加margin:auto的时候，子元素会位于水平垂直居中位置显示 容器属性修改主轴方向flex-direction12345678//默认值flex-direction: row;//横向反序排列flex-direction: row-reverse;//纵向排列flex-direction: column;//纵向反序排列flex-direction: column-reverse; 主轴对齐方式justify-content1justify-content：flex-start； 主轴的默认对齐方式是flex-start 123456789101112//末端对齐justify-content：flex-end；//居中对齐justify-content：center；//两端对齐justify-content：space-between；//两端对齐justify-content：space-between；//环绕对齐：贴边空白是项目之间空白的1/2justify-content：space-around；//间距均分justify-content：space-evenly； 侧轴对齐方式align-items1align-items:flex-start 侧轴的默认对齐方式是flex-start 12345678//底部显示align-items:flex-end//居中显示align-items:center//baseline位于交叉轴基线位置（基本不使用）align-items:baseline//拉伸显示，项目没有指定高度时候生效align-items:stretch 折行属性flex-wrap没有触发弹性盒子之前，子元素过多的时候，默认会产生溢出效果，元素有自己的宽度和高度 当给父元素触发完弹性盒子之后display: flex子元素会横向显示，没有折行，并且原有宽度被挤压了 1234//默认值不折行flex-wrap:nowrap//折行flex-wrap：wrap 右侧有空白是因为右侧区域留白放不下一个项目了只能折行显示 行之间空隙是因为项目设置了固定的高度，如果没有高度的话，高度默认是拉伸的效果，高度均分在每一行中 多行侧轴对齐align-content123456789101112//侧轴开始显示，没有行间距align-content: flex-start//侧轴结束显示，没有行间距align-content: flex-end//侧轴中间显示，没有行间距align-content: center//侧轴两端，上下两侧没有行间距align-content: space-berween//环绕对齐align-content: space-around//平分对齐align-content: space-evenly 项目属性单独侧轴对齐align-self12345678910//侧轴开始位置对齐。默认值align-self: flex-start//侧轴结束位置对齐align-self: flex-end//侧轴开始位置对齐align-self: center//侧轴开始位置对齐align-self: flex-baseline//默认拉伸align-self: stretch 调整显示顺序order默认order取值为：auto；可以理解成o；1)元素添加，order:5；位于最后显示5）元素添加，order:-1；位于最前面显示 占剩余空间的所有flex: 主轴在横向的时候 如果项目不设置高度的话，默认高度是拉伸的 项目添加flex:1实现的是占剩余宽度的所有 主轴在纵向的时候 如果项目不设置宽度的话，默认宽度是拉伸的 项目添加flex:1实现的是占剩余高度的所有 所有项目都是flex:1则所有项目平分 不挤压不占行 flex属性是一个复合属性是由：flex-grow、flex-shrink、flex-basis三个属性的缩写。 flex-grow：定义项目的的放大比例;默认为0，即使存在剩余空间，也不会放大；所有项目的flex-grow为1：等分剩余空间（自动放大占位）；flex-grow为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍。 flex-basis：定义在分配多余空间之前，项目占据的主轴空间（mainsize）浏览器根据此属性计算主轴是否有多余空间。相当于设置初始值，默认值为autt flex-shrink:定义项目的缩小比例取值为0/1 1234//不挤压，不折行flex-shrink:0//挤压flex-shrink:1","link":"/2024/11/06/flex%E5%B8%83%E5%B1%80/"},{"title":"Git","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 Git概述Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 Linus对新的系统制定了若干目标： 速度 简单的设计 对分线性开发模式的强力支持（允许成千上万并行开发的分支） 完全分布式 有能力高效管理类似LInux内核一样超大规模项目（速度和数据量） Git和SVN相比SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。 集中式版本控制工具缺点： 服务器单点故障 容错性差 GIT（Distributed Version Control System）即分布式版本控制系统，有两种类型的仓库,本地仓库和远程仓库。 本地仓库：是开发人员自己电脑上的GIT仓库 远程仓库：是远在服务器上的GIT仓库 Clone：克隆，将远程仓库复制到本地 Push：推送，将本地仓库代码上传到远程仓库 Pull：拉取，将远程仓库代码下载到本地仓库 Git工作流程 从远程仓库中克隆代码到本地仓库 从本地仓库中checkout代码然后进行代码修改 在提交代码前先将代码提交到暂存区 提交到本地仓库。本地仓库中保存修改的各个历史版本 修改完成后，需要和团队成员共享代码的时候，将代码push到远程仓库 GIT常用命令环境配置12345678设置用户配置信息git config --global user.name &quot;username&quot;git config --global user.email &quot;user@.com&quot;查看配置信息git config --listgit config user.name通过上面命令设置的信息会保存在~/.gitconfig文件中 获取GIT仓库使用git init命令新建一个本地仓库 使用git clone命令从远程仓库进行克隆，将远程仓库克隆到本地 库的概念和文件状态版本库：.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等 工作目录（工作区）：包含.git文件夹的目录就是工作目录，主要用于存放开发的代码 暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方 未跟踪（Untracked)：文件没有加入到git库中，不参与本本控制，使用git add变为暂存 已暂存（Staged）：标识对已经修改文件的当前版本做了标记，使之包含在下次提交的列表 已修改（Modified）：标识修改了文件，但没有将修改的结果放到暂存区 已提交（Unmodified）：标识文件已经安全保存在本地Git仓库中 查看文件状态12345678910111213141516查看文件状态git statusgit status -s 可以让输出结果更加简洁将未跟踪的文件添加到暂存区git add将暂存区中的文件取消暂存git reset将暂存区中文件修改提交到本地仓库git commit 删除文件 git rm 将文件添加到忽略列表： 有些文件无需纳入Git管理，在工作目录中创建一个.gitignore文件，列出忽略的文件模式 123456789101112#不跟踪所有以a结尾文件*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf 远程仓库操作查看远程仓库1如果想查看已经配置的远程仓库服务器，可以运行 `git remote`，会列出没有远程服务器的简写 添加远程仓库12添加一个新的远程仓库，同时指定一个可以引用的简写（shortname）git remote add &lt;shortname&gt; &lt;url&gt; 克隆仓库1git clone [url] 移除无效的远程仓库1git remote rm [name] 此命令只是从本地删除远程仓库记录，不会影响远程仓库 远程仓库抓取和拉取12345从远程仓库中获取最新版本到本地仓库，不会自动mergegit fetch从远程仓库中获取最新版本到本地仓库，自动mergegit pull 如果当前仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库中拉取文件会报错（fatal: refusing to merge unrelated histories ），解决问题：git pull –allow-unrelated-histories 推送到远程仓库1git push [remote_name] [branch_name] Git分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。 查看分支123456列出所有的分支git branch列出所有的远程分支git branch -r列出所有的本地和远程分支git branch -a 创建分支1git branch [branch_name] 切换分支1git checkout [branch_name] 推送分支去远程仓库分支1git push origin [branch_name] 合并分支12在进入master后，执行后于master合并git merge [branch_name] 有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决 删除分支1234git branch -d [branch_name]如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-Dgit branch -D [branch_name] Git标签像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。标签指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 1234567891011121314151617181920212223列出已有标签git tag查看tag信息git show [tag]创建标签# 新建一个标签git tag [tagName]将标签推送到远程仓库# 提交指定taggit push [remote] [tag]#检出标签git checkout -b [branch] [tag]删除标签#删除本地taggit tag -d [tag]#删除远程taggit push origin :refs/tags/[tag]","link":"/2023/02/26/git/"},{"title":"13-grid网格布局","text":"CSSgrid网格布局 grid布局的含义含义grid布局，也被称之为网格布局，是将页面中的父元素划分成一个个小的格子，然后通过这些小的格子进行合并来制作出各种不同的网站效果 触发网格给父元素添加display属性，并且将取值设置成：grid/inline-grid．grid：代表的是块状网格，默认独占一行，类似于块级元素.inline-grid：代表的是行内块网格，与行内块元素类似 触发网格的特点划分行列之后才能将里面的区域进行划分，显示网格 grid网格和flex弹性盒，表格和flex： 相同点：都有容器和项目之分 不同点：flex一维，grid二维 和表格： 相同点：行列之分，能划分格子 不同点：代码嵌套，表格需要代码嵌套 grid布局中的基础概念grid容器：采用grid布局的父元素；grid内容：显示项目的区域grid项目：grid布局中每一个格子内部放置的网格线：网格布局中的横向的纵线的线条单元格：横纵线交汇的区域被称之为单元格间距：网格与网格之间的距离被称为间距 grid布局中的容器属性触发网格1234//代表的是块状网格，默认独占一行，类似于块级元素display:grid代表的是行内块网格，与行内块元素类似display:inline-grid 容器行列划分 取值为数值 grid-template-rows:100px 100px 100px 取值为百分比 grid-template-rows:20% 30% 50% 重复函数 grid-template-rows:repeat(3,20%) 自动填充 grid-template-rows:repeat(auto-fill, 30%) auto自动 grid-template-rows:100px auto 100px fr片段划分 grid-template-rows:1fr 2fr 1fr minmax() grid-template-rows:200px 200px minmax(100px,200px) 调整间距1234567891011.box { /* 写法一：*/ grid-row-gap: 20px; grid-column-gap: 30px; /* 写法二：*/ grid-gap: 20px 30px; /* 写法三：*/ gap: 20px 30px;} 网格在容器中的对齐方式水平方向对其属性：justify-content垂直方向对其属性：align-content justify-content:start align-content:center 12345justify-centent:centeralign-centent:center//复合简写形式place-centent：center center 注意：justify-content，align-content取值除了有star，end，center,这些取值之外还有对应的stretch,space-around，space-between，space-evenly等值stretch：代表的是拉伸默认值： space-around:行列间距环绕： space-between:行列两端对对齐： space-evenly:行列间距平分： grid布局中的项目属性添加项目在容器中添加标签即为项目，项目会自动撑开显示在单元格内部，默认项目是从左向右排列 显示顺序1234//横向显示grid-auto-flow:row;//纵向显示grid-auto-flow:column; 项目对齐方式123456.box { //水平对齐方式 justify-items: center; //start，center，end三个位置可选 //垂直对齐方式 align-items: center; //start，center，end三个位置可选} justify-items: start;也是默认值 justify-items: center;这行代码代表的是，项目位于水平方向的中间位置 同理垂直方向对齐： align-items: end; 复合属性对齐123place-items：水平对齐，垂直对齐place-items：center，center； 合并单元格属性1234567891011121314151617181920.header { /* 写法一：*/ grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2; /* 写法二：*/ grid-column: 1 / 3; grid-row: 1 / 2; /* 写法三：使用 span 关键字，表示跨越。表示项目的左边框距离右边框跨越 2 个网格。*/ grid-column-start: span 2; /* 写法四：若跨度为 1，则可简写第二根网格线*/ grid-row: 1/2; /* grid-row: 1; */ grid-row: 3/4; background-position:; /* grid-row: 3; */} 容器中区域定义12345&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item a&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item c&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526.box { width: 800px; height: 800px; display: grid; grid-template-columns: repeat(3, 100px); grid-template-rows: repeat(3, 100px); align-content: center; justify-content: center; grid-gap: 10px; grid-template-areas: 'a a a' '. b b' 'c c c';}.item { border: 1px dashed #000;}.a { grid-area: a;}.b { grid-area: b;}.c { grid-area: c;} 项目属性grid案例分析grid小游戏 grid在线生成器","link":"/2024/11/02/grid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/17/hello-world/"},{"title":"html","text":"超文本标记语言（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 html文档基本格式12345678910111213&lt;!DOCTYPE html&gt; &lt;!--声明html5文档 --&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!-- 声明语言 --&gt;&lt;head&gt; &lt;!-- 声明字符集 --&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html &gt; 基本标签 序号 标签 解释 1 html 定义HTML文档 2 &lt;body&gt; 定义文档的主体 3 &lt;h1&gt;-&lt;h6&gt; 定义文档中的标题 4 &lt;hr&gt; 定义水平线 5 &lt;!----&gt; 定义注释 6 &lt;p&gt; 段落 7 &lt;br&gt; 换行 8 &lt;img&gt; 图像 文本格式化HTML 文本格式化 | 菜鸟教程 (runoob.com) 链接标签1&lt;a href=&quot;超链接地址&quot; target=&quot;_self当前网页打开 _blank新建标签打开&quot; &gt;&lt;/a&gt; 外部标签 内部标签 空标签 下载标签 1&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt; 网页元素标签 锚点标签 12&lt;a href=&quot;two&quot;&gt;跳转到网页的第二段&lt;/a&gt;&lt;h1 id=&quot;two&quot;&gt;网页第二段文字&lt;/h1&gt; 从另一个网页跳转到tips 123&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 头部标签&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 &lt;title&gt;:定义文档的标题 &lt;base&gt;:标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接 &lt;link&gt;:标签通常用于链接到样式表 &lt;style&gt;:元素中你也可以直接添加样式来渲染 HTML 文档 &lt;meta&gt;:标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。 12345搜索引擎定义关键词&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;网页描述内容&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt; &lt;script&gt;:标签用于加载脚本文件 表格标签123456789101112&lt;table&gt; &lt;!-- 表格标签 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头便签&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!-- 行标签--&gt; &lt;td&gt;&lt;/td&gt; &lt;!-- 单元格标签 --&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表格属性 表格属性 描述 boder 边框 align 对齐方式 cellpadding 边框和内容之间的间距 cellpacking 单元格之间的空白 width 表格的宽度 合并单元格（实际是设置单元格的宽度长度） 跨行合并单元格 rowspan 跨列合并单元格 colspan 代码 123456789101112131415161718192021&lt;table align=&quot;center&quot; border=&quot;2&quot; &gt; &lt;thead &gt; &lt;tr&gt; &lt;th&gt;a&lt;/th&gt; &lt;!-- 第一行的第二个单元格的宽度为2 --&gt; &lt;th colspan=&quot;2&quot;&gt;b&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody &gt; &lt;tr&gt; &lt;!-- 第一列的第二个单元格的长度为2 --&gt; &lt;td rowspan=&quot;2&quot;&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; HTML区块 HTML 区块 | 菜鸟教程 (runoob.com) 12&lt;div&gt;&lt;/div&gt; division分割 大盒子 一个占一行&lt;span&gt;&lt;/span&gt; span跨度 小盒子 一行可以放多个span 列表标签 无序列表 有序列表 自定义列表 123456&lt;!-- 无序列表 --&gt;&lt;ul&gt; &lt;!-- ul里只可以嵌套li元素 li中可以嵌套其他元素 --&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 123456&lt;!-- 有序列表 --&gt;&lt;ol&gt; &lt;!-- ol里只可以嵌套li元素 li中可以嵌套其他元素 --&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 12345&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;名词解释&lt;/ddd&gt;&lt;/dl&gt; 表单标签表单域123&lt;form action = &quot;url&quot; method = &quot;提交方式&quot; name = &quot;表单域名称&quot;&gt; 表单控件&lt;/form&gt; 常用属性 属性 属性值 作用 action url地址 指定接受处理表单数据的服务器程序的地址 method get/post 设置表单提交方式 name 名称 表单名称。区分一个页面中的多个表单域 表单元素1&lt;input type = &quot;&quot;/&gt; type属性设置不同可以用来指定不同的空间类型 属性 属性值 描述 text 单行输入字段，默认宽度为20 submit 定义提交按钮，提交按钮会把表单中数据发送到服务端 password 密码字段，输入的字符被隐藏 radio 定义单选按钮 checkbox 定义复选框 Button 定义可点击按钮（用于通过javaScript启动脚本） file 供上传文件 image 上传图像 reset 重置按钮，恢复表单默认状态 hidden 隐藏输入字段 标签属性 属性 属性值 描述 name 自定义 input元素的名称 value 自定义 input的值 checked checke 默认选中 maxlength 正整数 输入字符的最大长度 例子 12345&lt;form align = &quot;center&quot; &gt; 用户： eat &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked = &quot;checked&quot; value = &quot;eat&quot;&gt; sleep &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value = &quot;sleep&quot;&gt; jump &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;jump&quot;&gt; &lt;/form&gt; Label标签标签用于绑定一个表单元素，点击lable中文本的时候，浏览器自动将光标转到对应的表单元素上，增加用户体验 下拉表单1234567&lt;select&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt;&lt;/select&gt; 文本域元素（留言评论）12&lt;textarea cols = &quot;50&quot; rows= &quot;5&quot;&gt;文本内容&lt;/textarea&gt;&lt;!-- 一般使用css来控制文本域的大小 --&gt; CSS样式表 内联样式 内联样式表 外联样式表 阶段测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=`, initial-scale=1.0&quot;&gt; &lt;title&gt;网站标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;青春不再&lt;/h4&gt; &lt;table width = '500' border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;生日:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择年份--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2001&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2002&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2003&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择月份--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择日期--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;杭州&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;yihun&quot;&gt; &lt;label for=&quot;yihun&quot;&gt;已婚 &lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;weihun&quot;&gt; &lt;label for=&quot;weihun&quot;&gt;未婚 &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第武行 --&gt; &lt;tr&gt; &lt;td&gt;学历&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;博士&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;喜欢的类型&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;1 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;2 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;3 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;4 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;个人简介&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第九行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;check&quot;&gt;同意条款 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第十行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;我是会员,登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第十一行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;h5&gt;我承诺&lt;/h5&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/03/25/html/"},{"title":"hexo问题和使用","text":"在hexo中添加图片 hexo + typora 粘贴上传图片到指定目录 - 简书 (jianshu.com) 安装hexo-renderer-marked插件 安装插件 1cnpm install hexo-renderer-marked 在source文件夹下创建images文件夹用来存放文件 ​ 设置typora偏好设置，设置完成后，在typora中粘贴图片会在images文件夹中创建文件名相同的文件夹来存放文章图片 设置图片根目录 “格式 –&gt; 图像 –&gt; 设置图片根目录”，将source目录设置为根目录","link":"/2022/01/18/hexo%E9%97%AE%E9%A2%98%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"jQuery","text":"jQuery 是⼀套兼容多浏览器的 javascript 脚本库.。核⼼理念是写得更少,做得更多,使⽤ jQuery 将极⼤的提⾼编写 javascript 代码的效率,帮助开发者节省了⼤量的⼯作,让写出来的代码更加优雅,更加 健壮,”如⻁添翼”。 123456789101112131415161718192021222324JQuery├── Jquery对象│ ├── Jquery的使用│ └── Dom对象与Jquery包装集对象├── Jquery选择器│ ├── 基础选择器│ ├── 层次选择器│ └── 表单选择器├── Jquery Dom操作│ ├── 操作元素的属性│ ├── 操作元素的样式│ ├── 操作元素的内容│ ├── 创建元素│ ├── 添加元素│ ├── 删除元素│ └── 遍历元素├── Jquery 事件│ ├── ready加载事件│ └── 绑定事件└── Jquery Ajax ├── $.ajax() ├── $.get() ├── $.post() └── $.getJSON() jQuery 对象jQuery 是⼀套兼容多浏览器的 javascript 脚本库.。核⼼理念是写得更少,做得更多,使⽤ jQuery 将极⼤的提⾼编写 javascript 代码的效率,帮助开发者节省了⼤量的⼯作,让写出来的代码更加优雅,更加 健壮,”如⻁添翼”。 Jquery核⼼ $ 符号在 jQuery 中代表对 jQuery 对象的引⽤, “jQuery”是核⼼对象。通过该对象可以获取jQuery对 象,调⽤jQuery提供的⽅法等。只有jQuery对象才能调⽤jQuery提供的⽅法。 1$ &lt;==&gt; jQuery Dom对象 与 Jquery包装集对象原始的 Dom 对象只有 DOM接⼝提供的⽅法和属性,通过js代码获取的对象都是 Dom 对象;⽽通过 jQuery 获取的对象是 jQuery 包 装集对象,简称jQuery对象,只有jQuery对象才能使⽤jQuery提供的⽅法。 Dom对象javascript 中获取 Dom 对象,Dom 对象只有有限的属性和⽅法: 1var div = document.getElementById(&quot;testDiv&quot;); var divs = document.getElementsByTagName(&quot;div&quot;); Jquery包装集对象可以说是 Dom 对象的扩充。在 jQuery 的世界中将所有的对象, ⽆论是⼀个还是⼀组,都封装成⼀个 jQuery 包装集,⽐如获取包含⼀个元素的 jQuery 包装集: 1var jQueryObject = $(&quot;\\#testDiv&quot;); Dom对象 转 Jquery对象Dom 对象转为 jQuery 对象,只需要利⽤ $() ⽅法进⾏包装即可 var domDiv = document.getElementById(‘mydiv’); // 获取Dom对象 mydiv = $(domDiv); Jquery对象 转 Dom对象jQuery 对象转 Dom 对象,只需要取数组中的元素即可 12345// 第⼀种⽅式 获取jQuery对象 var jqueryDiv = jQuery('\\#mydiv');// 第⼆种⽅式 获取jQuery对象 jqueryDiv = $('\\#mydiv');var dom = jqueryDiv[0]; // 将以获取的jquery对象转为dom 通过遍历 jQuery 对象数组得到的对象是 Dom 对象,可以通过 $() 转为 jQuery 对象 123$('\\#mydiv').each(function() {//遍历 var jquery = $(this); }); 案例: 123456789101112131415161718192021222324252627&lt;div id=&quot;mydiv&quot;&gt;write less, do more&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log(&quot;-------------获取dom对象------------------&quot;) // dom对象 var domDiv = document.getElementById(&quot;mydiv&quot;); console.log(domDiv); console.log(&quot;-------------获取jquery对象------------------&quot;) // 获取jquery对象 // 第⼀种⽅式 var jqueryDiv = jQuery('\\#mydiv'); console.log(jqueryDiv); // 第⼆种⽅式 jqueryDiv = $('\\#mydiv'); console.log(jqueryDiv); console.log(&quot;-------------dom转jquery------------------&quot;) // dom转jquery包装集/对象 var obj = $(domDiv); console.log(obj); console.log(&quot;-------------jquery转dom------------------&quot;) // jquery对象转dom对象 var dom = $('\\#mydiv')[0]; // 获取jquery对象转为dom // 或 var dom2 = jqueryDiv[0]; // 将jquery对象转为dom console.log(dom); console.log(dom2); /* this代表了dom对象,不是jquery对象 */ console.log(&quot;-------------dom转jquery------------------&quot;) $('\\#mydiv').each(function() { // 通过id选择器选择了id为mydiv的所有元素然后进⾏遍历 // 那么遍历出的每个元素就是id为mydiv的标签元素 // ⽽this就代表了当前的这个元素 var jquery = $(this); }); console.log(&quot;-------------jquery转dom------------------&quot;) $('\\#mydiv').each(function() { var dom3 = this; });&lt;/script&gt; Jquery选择器和使⽤ JS 操作Dom⼀样,获取⽂档中的节点对象是很频繁的⼀个操作,在jQuery中提供了简便的⽅式 供我们查找|定位元素,称为jQuery选择器,选择器可以说是最考验⼀个⼈ jQuery 功⼒的地⽅,通俗的 讲, Selector 选择器就是”⼀个表示特殊语意的字符串”。 只要把选择器字符串传⼊上⾯的⽅法中就能够选 择不同的 Dom 对象并且以 jQuery 包装集的形式返回。 jQuery 选择器按照功能主要分为”选择”和”过滤”。 并且是配合使⽤的,具体分类如下。基础选择器掌 握即可 ,其他⽤到再查阅。 基础选择器 选择器 名称 举例 id选择器 #id $(“#testDiv”)选择id为testDiv的元素 元素名称选择 器 element $(“div”)选择所有div元素 类选择器 .class $(“.blue”)选择所有class=blue的元素 选择所有元素 * $(“*”)选择⻚⾯所有元素 组合选择器 selector1,selector2,selectorN $(“#testDiv,span,.blue”)同时选中多个选择器匹 配的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style type=&quot;text/css&quot;&gt; .blue { background: blue; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;mydiv1&quot;&gt;id选择器1&lt;span&gt;span中的内容&lt;/span&gt;&lt;/div&gt; &lt;div id=&quot;mydiv2&quot; class=&quot;blue&quot;&gt;元素选择器&lt;/div&gt; &lt;span class=&quot;blue&quot;&gt;样式选择器&lt;/span&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // id选择器 console.log(&quot;======id====&quot;); var idSelecter = $('\\#mydiv1'); console.log(idSelecter.html()); console.log(idSelecter.text()); // 元素选择器 console.log(&quot;======name====&quot;); var nameSe = $('div'); // 有多个div元素 nameSe.each(function () { // this是dom对象,$(this)是jquery对象 console.log($(this).text()); }); // 类选择器,class console.log(&quot;======class====&quot;); var classSe = $('.blue'); // 有多个class=blue的元素 classSe.each(function () { console.log($(this).text()); }); // 通⽤选择器:* console.log(&quot;======所有元素====&quot;); var all = $(&quot;*&quot;); console.log(all.length); // 组合选择器 console.log(&quot;======组合====&quot;); var unionSe = $('span, .blue,div'); unionSe.each(function () { console.log($(this).text()); });&lt;/script&gt; 层次选择器 选择器 名称 举例 后代选择器 ancestor descendant $(“#parent div”)选择id为parent的元素的所有div元素 ⼦代选择器 parent &gt; child $(“#parent&gt;div”)选择id为parent的直接div⼦元素 相邻选择器 prev + next $(“.blue + img”)选择css类为blue的下⼀个img元素 同辈选择器 prev ~ sibling $(“.blue ~ img”)选择css类为blue的之后的img元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;层次选择器&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .testColor { background: green; } .gray { background: gray; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;parent&quot;&gt;层次择器 &lt;div id=&quot;child&quot; class=&quot;testColor&quot;&gt;⽗选择器 &lt;div class=&quot;gray&quot;&gt;⼦选择器&lt;/div&gt; &lt;img src=&quot;http://www.baidu.com/img/bd_logo1.png&quot; width=&quot;270&quot; height=&quot;129&quot; /&gt; &lt;img src=&quot;http://www.baidu.com/img/bd_logo1.png&quot; width=&quot;270&quot; height=&quot;129&quot; /&gt; &lt;/div&gt; &lt;div&gt; 选择器2&lt;div&gt;选择器2中的div&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; console.log(&quot;=========后代选择器-选择所有后代=====&quot;); var ancestorS = $('\\#parent div'); ancestorS.each(function () { console.log($(this).text()); }); console.log(&quot;=========⼦代选择器-选择⼉⼦辈=====&quot;); var child = $('\\#parent&gt;div'); child.each(function () { console.log($(this).text()); }); console.log(&quot;=========相邻选择器=====&quot;); var pre_next = $(&quot;.gray + img&quot;); console.log(pre_next.length); console.log(&quot;=========同辈选择器,其后,(弟弟)=====&quot;); var pre_siblings = $(&quot;.gray ~ img&quot;); console.log(pre_siblings.length);&lt;/script&gt;&lt;/HTML&gt; 表单选择器 Forms 名称 举例 查找所有的input元素:$(“:input”); 表单选择器 :input 注意:会匹配所有的input、textarea、select和button元素。 ⽂本框选择器 :text 查找所有⽂本框:$(“:text”) 密码框选择器 :password 查找所有密码框:$(“:password”) 单选按钮选择器 :radio 查找所有单选按钮:$(“:radio”) 复选框选择器 :checkbox 查找所有复选框:$(“:checkbox”) 提交按钮选择器 :submit 查找所有提交按钮:$(“:submit”) 图像域选择器 :image 查找所有图像域:$(“:image”) 重置按钮选择器 :reset 查找所有重置按钮:$(“:reset”) 按钮选择器 :button 查找所有按钮:$(“:button”) ⽂件域选择器 :file 查找所有⽂件域:$(“:file”) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;表单验证&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;myform&quot; name=&quot;myform&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;uno&quot; value=&quot;9999&quot; /&gt; 姓名: &lt;input type=&quot;text&quot; id=&quot;uname&quot; name=&quot;uname&quot; /&gt;&lt;br /&gt; 密码: &lt;input type=&quot;password&quot; id=&quot;upwd&quot; name=&quot;upwd&quot; value=&quot;123456&quot; /&gt;&lt;br /&gt; 年龄: &lt;input type=&quot;radio&quot; name=&quot;uage&quot; value=&quot;0&quot; checked=&quot;checked&quot; /&gt;小屁孩 &lt;input type=&quot;radio&quot; name=&quot;uage&quot; value=&quot;1&quot; /&gt;你懂得&lt;br /&gt; 爱好: &lt;input type=&quot;checkbox&quot; name=&quot;ufav&quot; value=&quot;篮球&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;ufav&quot; value=&quot;爬床&quot; /&gt;爬床 &lt;input type=&quot;checkbox&quot; name=&quot;ufav&quot; value=&quot;代码&quot; /&gt;代码&lt;br /&gt; 来自: &lt;select id=&quot;ufrom&quot; name=&quot;ufrom&quot;&gt; &lt;option value=&quot;-1&quot; selected=&quot;selected&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; 简介: &lt;textarea rows=&quot;10&quot; cols=&quot;30&quot; name=&quot;uintro&quot;&gt;&lt;/textarea&gt;&lt;br /&gt; 头像: &lt;input type=&quot;file&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;image&quot; src=&quot;http://www.baidu.com/img/bd_logo1.png&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt; &lt;button type=&quot;submit&quot; onclick=&quot;return checkForm();&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;function checkForm() { // 获取所有的表单元素 $(&quot;:input&quot;).each(function(){ console.log($(this)[0].tagName); }); console.log(&quot;------+++++++++++++++++++++--------&quot;); // 获取 text console.log(&quot;text--&gt;&quot; + $(&quot;:text&quot;).length); // 1 // 获取 password console.log(&quot;password--&gt;&quot; + $(&quot;:password&quot;).length); // 1 // 获取radio console.log(&quot;radio--&gt;&quot; + $(&quot;:radio&quot;).length); // 2 // 获取checkbox console.log(&quot;checkbox--&gt;&quot; + $(&quot;:checkbox&quot;).length); // 3 // 获取file console.log(&quot;file--&gt;&quot; + $(&quot;:file&quot;).length); // 1 // 获取按钮 console.log(&quot;button--&gt;&quot; + $(&quot;:button&quot;).length); // 2 // 获取submit按钮 console.log(&quot;submit--&gt;&quot; + $(&quot;:submit&quot;).length); // 1 // 获取image按钮 console.log(&quot;image--&gt;&quot; + $(&quot;:image&quot;).length); // 1 // 获取reset按钮 console.log(&quot;reset--&gt;&quot; + $(&quot;:reset&quot;).length); // 1 return false;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Jquery Dom操作jQuery也提供了对HTML节点的操作,⽽且在原⽣js的基础之上进⾏了优化,使⽤起来更加⽅便。 常⽤的从⼏个⽅⾯来操作,查找元素(选择器已经实现);创建节点对象;访问和设置节点对象的 值,以及属性;添加节点;删除节点;删除、添加、修改、设定节点的CSS样式等。注意:以下的操作 ⽅式只适⽤于jQuery对象。 操作元素的属性获取属性 ⽅法 说明 举例 attr(‘checked’) attr(属性名称) 获取指定的属性值,操作 checkbox 时, 选中返回 checked,没有选中返回 undefined。 attr(‘name’) prop(属性名称) 获取具有true和false两个属性的属性值 prop(‘checked’) 1234567891011121314151617&lt;form action=&quot;&quot; id=&quot;myform&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ch&quot; checked=&quot;checked&quot; /&gt; aa&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ch&quot; /&gt; bb&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function() { var checkboxes = $(&quot;input[type='checkbox']&quot;); console.log(checkboxes); checkboxes.each(function(idx, element) { console.log(idx + &quot;-&quot; + $(element) + &quot;=&quot; + this); console.log($(element).attr('checked') + &quot;==&quot; + $(element).prop('checked')); console.log('--------------'); });});&lt;/script&gt; 设置属性 方法 说明 举例 attr(属性名称，属性值) 设置指定的属性值，操作checkbox时，选中返回checked，没有选中返回undefined。 attr(‘checked’,’checked’) attr(‘name’,’zs’) prop(属性名称，属性值) 设置具有true和false的属性值 prop(‘checked’,true’) 移除属性 ⽅法 说明 举例 removeAttr(属性名) 移除指定的属性 removeAttr(‘checked’) 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;属性操作&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;&lt;h5&gt;1. attr()&lt;/h5&gt;设置或者返回元素的属性;&lt;h5&gt;2. prop()&lt;/h5&gt;设置具有 true 和 false 两个属性的属性, 如 checked, selected 或者 disabled。&lt;/pre&gt;&lt;hr /&gt;&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;a1&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://www.sina.com&quot; id=&quot;a2&quot;&gt;新浪&lt;/a&gt;&lt;input type=&quot;checkbox&quot; name=&quot;all&quot; checked=&quot;checked&quot; /&gt;全选&lt;script type=&quot;text/javascript&quot;&gt;// 获取属性值: attrconsole.log($('#a1').attr('href'));console.log($(':checkbox').attr('name'));// 若未选中显示 undefined, 选中显示 checkedconsole.log($(':checkbox').attr('checked'));// 获取属性值: prop// 若未选中显示 false, 选中显示 trueconsole.log($(&quot;:checkbox&quot;).prop('checked'));console.log($('#a2').prop('href'));// 设置属性值$('#a1').attr('href', 'https://jquery.com');$(&quot;:checkbox&quot;).prop(&quot;checked&quot;, false);// 移除属性$('#a2').removeAttr('href');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作元素的样式对于元素的样式,也是⼀种属性,由于样式⽤得特别多,所以对于样式除了当做属性处理外还可以有 专⻔的⽅法进⾏处理。 ⽅法 说明 attr(“class”) 获取class属性的值,即样式名称 attr(“class”,”样式名”) 修改class属性的值,修改样式 addClass(“样式名”) 添加样式名称 css() 添加具体的样式 removeClass(class) 移除样式名称 1234增加元素的具体样式,格式:1)css({'样式名':'样式值','样式名2':'样式值2'})例:css({&quot;background-color&quot;:&quot;red&quot;,&quot;color&quot;:&quot;\\#fff&quot;});2)css(&quot;样式名&quot;,&quot;样式值&quot;) 例:css('color','white') 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;设置元素样式&lt;/title&gt; &lt;script src=&quot;jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; div { padding: 8px; width: 180px; } .blue { background: blue; } .larger { font-size: 30px; } .green { background: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;css()方法设置元素样式&lt;/h3&gt; &lt;div id=&quot;conBlue&quot; class=&quot;blue larger&quot;&gt;天蓝色&lt;/div&gt; &lt;div id=&quot;conRed&quot;&gt;大红色&lt;/div&gt; &lt;div id=&quot;remove&quot; class=&quot;blue larger&quot;&gt;天蓝色&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取样式名称 console.log($(&quot;#remove&quot;).attr(&quot;class&quot;)); // 修改样式，那么id为remove的元素样式class只有green // $(&quot;#remove&quot;).attr(&quot;class&quot;, &quot;green&quot;); // 添加样式名称，class名称 -- 叠加 // $(&quot;#conBlue&quot;).addClass(&quot;blue larger&quot;); // 添加元素具体样式 // {&quot;&quot;:&quot;&quot;, &quot;&quot;:&quot;&quot;} 名:值 对 $(&quot;#conRed&quot;).css({ &quot;background-color&quot;: &quot;red&quot;, &quot;color&quot;: &quot;#fff&quot; }); $(&quot;#remove&quot;).css(&quot;color&quot;, &quot;red&quot;); // 移除样式 // $(&quot;#remove&quot;).removeClass(&quot;blue larger&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作元素的内容对于元素还可以操作其中的内容,例如⽂本,值,甚⾄是html。 ⽅法 说明 html() 获取元素的html内容 html(“html, 内容”) 设定元素的html内容 text() 获取元素的⽂本内容,不包含html text(“text 内容”) 设置元素的⽂本内容,不包含html val() 获取元素value值 val(“值”) 设定元素的value值 操作内容 html()和text()方法设置元素内容 &lt;script type=&quot;text/javascript&quot;&gt; // 获取HTML内容，包括HTML标签 console.log($('h3').html()); // 获取文本内容，不包括HTML标签 console.log($('h3').text()); // 获取value值 console.log($('[name=&quot;uname&quot;]').val()); // 设置 $('#html').html(&quot;&lt;p&gt;使用html设置，看不到标签&lt;/p&gt;&quot;); $('#text').text(&quot;使用text设置，能看到标签&quot;); // 注意这里没有实际的HTML标签，因此不会渲染成HTML元素 $('[name=&quot;uname&quot;]').val(&quot;哈哈哈&quot;); // 下面是注释掉的日志输出示例 // console.info(&quot;abc&quot;); // console.log(&quot;abc&quot;); // console.warn(&quot;abc&quot;); // console.error(&quot;abc&quot;); &lt;/script&gt; 创建元素在jQuery中创建元素很简单,直接使⽤核⼼函数即可 12$('元素内容');$('&lt;p&gt;this is a paragraph!!!&lt;/p&gt;'); 添加元素 ⽅法 说明 prepend(content) 在被选元素内部的开头插⼊元素或内容,被追加的 content 参 数,可以是字符、HTML 元素标记。 $(content).prependTo(selector) 把 content 元素或内容加⼊ selector 元素开头 append(content) 在被选元素内部的结尾插⼊元素或内容,被追加的 content 参 数,可以是字符、HTML 元素标记。 $(content).appendTo(selector) 把 content元素或内容插⼊selector 元素内,默认是在尾部 before() 在元素前插⼊指定的元素或内容:$(selector).before(content) after() 在元素后插⼊指定的元素或内容:$(selector).after(content) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;追加&lt;/title&gt; &lt;script src=&quot;jquery-3.4.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; div { margin: 10px 0px; } span { color: white; padding: 8px; } .red { background-color: red; } .blue { background-color: blue; } .green { background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;prepend()方法前追加内容&lt;/h3&gt; &lt;h3&gt;prependTo()方法前追加内容&lt;/h3&gt; &lt;h3&gt;append()方法后追加内容&lt;/h3&gt; &lt;h3&gt;appendTo()方法后追加内容&lt;/h3&gt; &lt;span class=&quot;red&quot;&gt;男神&lt;/span&gt; &lt;span class=&quot;blue&quot;&gt;偶像&lt;/span&gt; &lt;div class=&quot;green&quot;&gt; &lt;span&gt;小鲜肉&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;&lt;span id='mydiv' style='padding: 8px; width: 180px; background-color: #ADFF2F;'&gt;动态创建span&lt;/span&gt;&quot;; // 1、使用prepend前加内容 $(&quot;body&quot;).prepend(str); // 2、使用prependTo前加内容 $(&quot;&lt;b&gt;开头&lt;/b&gt;&quot;).prependTo('body'); // 3、使用append后加内容 $(&quot;body&quot;).append(str); // 4、使用appendTo后追加内容 $(str).appendTo('body'); // 注意：当把已存在的元素添加到另一处的时候相当于移动 // 下面的代码注释掉了，因为它们会改变现有的DOM结构 // $(&quot;div&quot;).append($('.red')); // $('.blue').appendTo(&quot;div&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;插入元素&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; span { color: white; padding: 8px; } .red { background-color: red; } .blue { background-color: blue; } .green { background-color: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;before() 和 after() 方法在元素之前后插入内容&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;财大气粗&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; var str1 = &quot;&lt;span class='red'&gt;土豪&lt;/span&gt;&quot;; var str2 = &quot;&lt;span class='blue'&gt;暴发户&lt;/span&gt;&quot;; // 在.green元素前插入str1 $(&quot;.green&quot;).before(str1); // 在.green元素后插入str2 $(&quot;.green&quot;).after(str2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除元素 ⽅法 说明 remove() 删除所选元素或指定的⼦元素,包括整个标签和内容⼀起删。 empty() 清空所选元素的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;删除元素&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; span { color: white; padding: 8px; margin: 5px; float: left; } .green { background-color: green; } .blue { background-color: blue; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;删除元素&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;jquery&lt;a&gt;删除&lt;/a&gt;&lt;/span&gt; &lt;span class=&quot;blue&quot;&gt;javase&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;http协议&lt;/span&gt; &lt;span class=&quot;blue&quot;&gt;servlet&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 删除所选元素 或指定的子元素 // $(&quot;span&quot;).remove(); // 删除样式为blue的span // $(&quot;span.blue&quot;).remove(); // 清空元素 // $(&quot;span&quot;).empty(); // $(&quot;.green&quot;).empty(); // 示例：删除包含链接的绿色span元素 // $(&quot;span.green a&quot;).remove(); // 示例：清空包含链接的绿色span元素 // $(&quot;span.green a&quot;).empty(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 遍历元素each()$(selector).each(function(index,element)) :遍历元素 参数 function 为遍历时的回调函数, index 为遍历元素的序列号,从 0 开始 element是当前的元素,此时是dom元素 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;遍历元素&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; span { color: white; padding: 8px; margin: 5px; float: left; } .green { background-color: green; } .blue { background-color: blue; } &lt;/style&gt; &lt;script src=&quot;jquery-3.4.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;遍历元素 each()&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;jQuery&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;JavaSE&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;HTTP协议&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;Servlet&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $('span').each(function(idx, element) { console.log(idx + &quot; ---&gt; &quot; + $(element).text()); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Jquery事件ready加载事件ready()类似于 onLoad()事件 ready()可以写多个，按顺序执⾏ $(document).ready(function(){})等价于$(function(){}) 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;ready事件&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 文档载入完便触发ready方法 $(document).ready(function() { $(&quot;div&quot;).html(&quot;ready go...&quot;); }); // $(document).ready(function(){}) 等价于 $(function(){}); $(function() { $(&quot;p&quot;).click(function() { $(this).hide(); }); }); $(function() { $(&quot;#btntest&quot;).on(&quot;click&quot;, function() { $(&quot;div&quot;).html(&quot;剁吧...&quot;); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;页面载入时触发ready()事件&lt;/h3&gt; &lt;div&gt;&lt;/div&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;剁手&quot; /&gt; &lt;p&gt;aaa&lt;/p&gt; &lt;p&gt;bbbb&lt;/p&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;p&gt;dddd&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Bind()绑定事件为被选元素添加⼀个或多个事件处理程序,并规定事件发⽣时运⾏的函数。 $(selector).bind( eventType [, eventData], handler(eventObject));eventType :是⼀个字符串类型的事件类型,就是你所需要绑定的事件。 这类类型可以包括如下: 1blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter mouseleave,change, select, submit, keydown, keypress, keyup, error [, eventData]：传递的参数，格式：{名:值,名2:值2} handler(eventObject)：该事件触发执⾏的函数 简单的Bind()事件123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;事件绑定&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;bind()方法简单的绑定事件&lt;/h3&gt; &lt;div id=&quot;test&quot; style=&quot;cursor:pointer&quot;&gt;点击查看名言&lt;/div&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;点击就不可用了&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { /* 使用bind方法绑定click事件 * $(&quot;#test&quot;).bind(&quot;click&quot;, function() { * alert(&quot;世界会向那些有目标和远见的人让路!!&quot;); * }); */ /* 等同于上面的方法 */ $(&quot;#test&quot;).click(function() { alert(&quot;世界会向那些有目标和远见的人让路!!&quot;); }); /* * 绑定事件的基本步骤: * 1. 确定为哪些元素绑定事件 (获取元素) * 2. 绑定什么事件 (事件类型)，第一个参数：事件的类型 * 3. 相应事件触发的，执行的操作，第二个参数：函数 */ $(&quot;#btntest&quot;).bind('click', function() { // $(this).attr('disabled', true); $(this).prop(&quot;disabled&quot;, true); }); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绑定多个事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;绑定多个事件&lt;/title&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;bind()方法绑多个事件&lt;/h3&gt; &lt;div id=&quot;test&quot; style=&quot;cursor:pointer;&quot;&gt;点击查看名言&lt;/div&gt; &lt;div id=&quot;slowDiv&quot; style=&quot;width:200px; height:200px; display:none;&quot;&gt; 人之所以能，是相信能 &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { // 绑定click 和 mouseout事件 /*$(&quot;h3&quot;).bind('click mouseout', function() { console.log(&quot;绑多个事件&quot;); });*/ // 链式编程 $(&quot;h3&quot;).bind('click', function() { alert(&quot;链式编程1&quot;); }).bind('mouseout', function() { $(&quot;#slowDiv&quot;).show(&quot;slow&quot;); // 让slowDiv显示 }); /*$(&quot;#test&quot;).click(function() { console.log(&quot;点击鼠标了....&quot;); }).mouseout(function() { console.log(&quot;移出鼠标了...&quot;); });*/ // 使用对象字面量来绑定多个事件 $(&quot;#test&quot;).bind({ click: function() { alert(&quot;点击事件&quot;); }, mouseout: function() { $(&quot;#slowDiv&quot;).show(&quot;slow&quot;); } }); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Jquery Ajax$.ajaxjquery 调⽤ ajax ⽅法： 格式：$.ajax({}); 参数： type：请求⽅式 GET/POST url：请求地址 url async：是否异步，默认是 true 表示异步 data：发送到服务器的数据 dataType：预期服务器返回的数据类型 contentType：设置请求头 uccess：请求成功时调⽤此函数 error：请求失败时调⽤此函 get请求 12345678910111213141516171819202122232425$.ajax({ type: &quot;GET&quot;, // 使用大写表示HTTP方法 url: &quot;js/cuisine_area.json&quot;, async: true, success: function(msg) { var str = JSON.stringify(msg); // 将数据转换为字符串形式以便打印 console.log(str); $('div').append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;); // 遍历prices数组并添加到&lt;ul&gt;中 for (var i = 0; i &lt; msg.prices.length; i++) { $('ul').append(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $('li').eq(i).text(msg.prices[i]); } }, error: function(errMsg) { console.log(errMsg); // 将错误信息显示在&lt;div&gt;中 // 注意：通常错误响应不会包含responseText，而是包含statusText // 这里假设errMsg.responseText存在且包含了想要显示的信息 $('div').html(errMsg.responseText || errMsg.statusText); }}); post请求 123456789101112131415161718192021222324252627$.ajax({ type: &quot;POST&quot;, data: &quot;name=tom&quot;, url: &quot;js/cuisine_area.json&quot;, contentType: &quot;application/x-www-form-urlencoded&quot;, async: true, success: function(msg) { var str = JSON.stringify(msg); // 将数据转换为字符串形式以便打印 console.log(str); $('div').append(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;); // 遍历prices数组并添加到&lt;ul&gt;中 for (var i = 0; i &lt; msg.prices.length; i++) { $('ul').append(&quot;&lt;li&gt;&lt;/li&gt;&quot;); $('li').eq(i).text(msg.prices[i]); } }, error: function(errMsg) { console.log(errMsg); // 将错误信息显示在&lt;div&gt;中 // 注意：通常错误响应不会包含responseText，而是包含statusText // 这里假设errMsg.responseText存在且包含了想要显示的信息 $('div').html(errMsg.responseText || errMsg.statusText); }}); $.Get这是⼀个简单的 GET 请求功能以取代复杂 $.ajax 。 请求成功时可调⽤回调函数。如果需要在出错时执⾏函数,请使⽤ $.ajax。 123456789// 1.请求json⽂件,忽略返回值$.get('js/cuisine_area.json'); // 2.请求json⽂件,传递参数,忽略返回值$.get('js/cuisine_area.json',{name:&quot;tom&quot;,age:100});// 3.请求json⽂件,拿到返回值,请求成功后可拿到返回值$.get('js/cuisine_area.json',function(data){ console.log(data); });// 4.请求json⽂件,传递参数,拿到返回值 $.get('js/cuisine_area.json',{name:&quot;tom&quot;,age:100},function(data){ console.log(data);}); $.Post这是⼀个简单的 POST 请求功能以取代复杂 $.ajax 。 请求成功时可调⽤回调函数。如果需要在出错时执⾏函数,请使⽤ $.ajax。 1234567891011// 1.请求json⽂件,忽略返回值$.post('../js/cuisine_area.json'); // 2.请求json⽂件,传递参数,忽略返回值$.post('js/cuisine_area.json',{name:&quot;tom&quot;,age:100});// 3.请求json⽂件,拿到返回值,请求成功后可拿到返回值$.post('js/cuisine_area.json',function(data){ console.log(data);}); // 4.请求json⽂件,传递参数,拿到返回值 $.post('js/cuisine_area.json',{name:&quot;tom&quot;,age:100},function(data){ console.log(data);}); $.Getjson表示请求返回的数据类型是JSON格式的ajax请求 123$.getJSON('js/cuisine_area.json',{name:&quot;tom&quot;,age:100},function(data){ console.log(data); // 要求返回的数据格式是JSON格式})","link":"/2024/10/09/jQuery/"},{"title":"macOS软件","text":"软件下载网站 精品MAC应用分享 (xclient.info) Appstorrent - Игры и программы для macOS typoramd编辑软件 备份 homebrew参考安装教程Homebrew国内如何自动安装（国内地址）（Mac &amp; Linux） - 知乎 (zhihu.com) pap.er壁纸软件 备份 visual-stdio-codeide homebrew下载 edge浏览器microsoft-edge 浏览器 homebrew下载 Snipaste截图软件brew下载 cheatsheet长按显示command显示所有的快捷键 brew下载 rectangle分屏软件 brew下载 senseimacos综合管理工具 含状态栏监视器 备份 aDrive阿里云盘备份文件 brew下载 motrix下载工具 brew下载 geekbench跨平台跑分软件 备份 Keka压缩软件 brew下载","link":"/2022/01/18/macOS%E8%BD%AF%E4%BB%B6/"},{"title":"poem","text":"临江仙·夜饮东坡醒复醉 宋-苏轼 夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声 长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生 唐崔道融《梅花》 数萼初含雪，孤标画本难。 香中别有韵，清极不知寒。 横笛和愁听，斜枝依病看。 朔风如解意，容易莫摧残。 唐珙（gǒng）《题龙阳县青草湖》 西风吹老洞庭波，一夜湘君白发多。 醉后不知天在水，满船清梦压星河。 白居易《问刘十九》 绿蚁新醅酒，红泥小火炉。 晚来天欲雪，能饮一杯无？ 《梦微之》 夜来携手梦同游，晨起盈巾泪莫收。 漳浦老身三度病，咸阳宿草八回秋。 君埋泉下泥销骨，我寄人间雪满头。 阿卫韩郎相次去，夜台茫昧得知不？ 温庭筠《新添声杨柳枝词二首》 一尺深红胜曲尘，天生旧物不如新。 合欢桃核终堪恨，里许元来别有人。 井底点灯深烛伊，共郎长行莫围棋。 玲珑骰子安红豆，入骨相思知不知。 宋苏轼《西江月》 世事一场大梦，人生几度秋凉？夜来风叶已鸣廊，看取眉头鬓上。 酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄凉北望。 陆游陆游《沈园二首·其一》 城上斜阳画角哀，沈园非复旧池台。 伤心桥下春波绿，曾是惊鸿照影来。 明施耐庵《鲁智深坐化诗》 平生不修善果，只爱杀人放火。 忽地顿开金枷，这里扯断玉锁。 咦！钱塘江上潮信来，今日方知我是我。 《西江月》 宋江反诗 自幼曾攻经史，长成亦有权谋。恰如猛虎卧荒丘，潜伏爪牙忍受。 不幸刺文双颊，那堪配在江州。他年若得报冤仇，血染浔阳江口! 心在山东身在吴，飘蓬江海谩嗟吁。他时若遂凌云志，敢笑黄巢不丈夫! 清曹雪芹《自题一绝》 满纸荒唐言，一把辛酸泪！ 都云作者痴，谁解其中味？ 石达开《入川题壁》 大盗亦有道，诗书所不屑。黄金若粪土，肝胆硬如铁。 策马渡悬崖，弯弓射胡月。人头作酒杯，饮尽仇雠血。 钱彩《说岳全传》>《风云》 金麟岂是池中物，一遇风云便化龙。 九霄龙吟惊天变，风云际会浅水游。 现代毛泽东《七律·和郭沫若同志》 一从大地起风雷，便有精生白骨堆。僧是愚氓犹可训，妖为鬼蜮必成灾。 金猴奋起千钧棒，玉宇澄清万里埃。今日欢呼孙大圣，只缘妖雾又重来。","link":"/2023/01/16/poem/"},{"title":"python","text":"​ Python是一种广泛使用的解释型、高级和通用的编程语言。 预备变量变量的命名规则： 变量名只能包含字母、数字和下划线。变量名能以字母或下划线打头，但不能以数字打头。例如，可将变量命名为message_1但不能将其命名为1_message 。 变量名不能包含空格，但能使用下划线来分隔其中的单词。例如,变量名greeting_message 可行，但变量名greeting message 会 引发错误。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print 。 变量名应既简短又具有描述性。例如，name 比n好，student_name 比s_n好，name_length 比length_of_persons_name 好。 慎用小写字母l 和大写字母O ，因为它们可能被人错看成数字1 和0 常量1在代码中特定变量视为常量，可将其字母全部大写 注释单行注释 注意在#后有一个小空格 123# 这是注释print('hello world') #单行注释 两个小空格 多行注释 123''''''多行注释'''''' 标识符（命名规则） 标识符就是程序员定义的变量名，函数名 标识符可以由字母下划线和数字组成 不能以数字开头 不能与关键字重名 标识符区分大小写 局部变量和全局变量 局部变量：在函数内部定义的变量，只能在函数内部使用 全局变量：在函数外部定义的变量，所有函数内部都可以使用这个变量 在其他开发语言中，不推荐使用全局变量，可变范围太大，程序不方便维护 可变和不可变类型 不可变数据类型：是一旦定义，内存中的数据不可修改 可变数据类型：变量名引用的内存地址不变，内存中的数据可以修改 局部变量的生命周期： 所谓生命周期就是变量从被创建到被系统回收的过程 局部变量在函数执行时候创建 函数执行结束后局部变量被系统回收 局部变量在生命周期内，可以用来存贮函数内部临时使用到的数据 基本数据结构 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number（数字） 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 python中的数字包括 int float 和 complex 整数 浮点数 整数和浮点数 任意两个数相除时候，结果总是浮点数(其他情况下没有浮点数结果都是整数) 其他操作中，如果一个操作数是整数，另一个操作数是浮点数，结果也总是浮点数 数中的下划线 更好识别位数长的数 1234num = 14_0000_000&gt;&gt;print(num) 1400000000 常用函数 Python3 数字(Number) | 菜鸟教程 (runoob.com) String（字符串）python中字符串使用单引号'或者双引号”括起来，一般使用双引号 字符串截取1变量[头下表:尾下表] 字符串运算 操作符 描述 + 字符串链接 * 重复输出字符串 [] 通过索引获取字符串中字符 [:] 截取字符串中的一部分，遵循左闭右开的原则 in 成员运算符，如果运算符中包含所给的字符返回True not in 成员运算符，如果运算符中不包含所给的字符返回True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 % 格式化字符串 字符串格式化1234567print('my name is %s this year %d'%('liu',10))print('this is float %.2f' % float_num)#输出浮点数保留两位小数print('this is code %06d')#输出格式为六位整数 不足使用0占位print('the scale is %.2f%%' % scale)#输出百分号 字符串常用函数 12345#统计字符串长度 len函数#统计某一个小字符串出现的次数str.count(&quot;查询的字符串&quot;)# 某一个子字符串出现的索引位置str.index(&quot;查询的字符串&quot;) 判断类型（9个） 方法 解释 isspace() 如果string包含空格（或者是空字符\\t,\\r），返回True isalnum() string之后有一个字符，并且所有字符都是字母或者数字返回True isalpha() string至少有一个字符并且所有字符是字母返回True isdecimal() string只包含数字，全角数字返回True isdigit() string只包含数字，全角数字，（1）或者转义的Unicode字符\\u00b2返回True isnumeric() string只包含数字，全角数字，汉字数字返回True istitle() 如果string是标题化的（每个单词的首字母大写）返回True islower() 如果string中至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，返回True isupper() 如果string中包含字少一个区分大小写的字符，都是大写返回True 查找和替换（7个） 方法 解释 startswith(str) 检查字符是否已str开头，是则返回True endswith 检查字符串是否已str结束，是则返回True find(str,start=0,end=len(string)) 检查str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果返回是返回开始的索引值，反则返回-1 index(str,start=0,end=len(string)) 跟find方法类似，只不过不会报错 rfind(str,start=0,end=len(string)) 跟find方法类似，只不过从右边开始查找 rindex(str,start=0,end=len(string)) 跟index方法类似，只不过从右边开始查找 replace(old_str,new_str,num=string.count(old)) 把string中替换，num若指定，则替换次数不超过num次，返回修改后的字符串，不会修改原有的字符串 文本对齐（3个） 方法 解释 ljust(width) 返回一个原字符串左对齐，并使用空格填充值长度width的新字符串 rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度width的新字符串 center(width) 返回一个原字符串居中，并使用空格田中至长度width的新字符串 应用：打印一首诗 去除空白字符（3个） 方法 解释 string.lstrip() 裁掉string左边的空白字符 string.rstrip() 裁掉string右边的空白字符 string.strip() 裁掉string左右的空白字符 字符串拆分连接（5个） 方法 解释 string.partition(str) 把字符串string分成一个三元素的元组（str前，str，str后） string.rpartition(str) 类似于partition()方法，不过是从右边开始 string.split(str = ‘’,num) 以str为分隔符拆分string,如果num有指定值，则仅分隔num+1个子字符串,str默认包含\\r,\\t,\\n和空格 string.splitlines() 按照行(\\r,\\n,\\r\\n)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以string作为分隔符，将seq中所有元素合并为一个新的字符串 bool（布尔） List（列表）1list1 = ['Google', 'Runoob', 1997, 2000] 列表方法 查询元素： 第一种方法是使用下标直接访问； 第二种方法是使用切片： 切片： list[0:3]前三个元素 list[-3:0]最后三个元素 list_copy = list[:]复制元素（待补充：python的赋值原理） index('value')根据关键字得到索引 下标修改列表中元素，访问元素 添加元素： appen()在列表末尾追加元素 insert()在列表中某个索引位置插入元素 extend()：末尾追加一个列表 1234list1 = [1,2,3]list2 = [4,5,6]lsit1.extend(list2)#list = [1,2,3,4,5,6] 删除元素： del list[index]使用索引直接删除，从内存中删除,一般不使用 pop()默认删除列表尾部元素，传递删除元素,可以删除指定下标元素 remove('value')以关键字删除元素，若重复则删除第一个 clear()清空列表 排序： sort()永久排序 sorted()暂时排序 reverse()永久翻转列表 list = [i*2 for i in range(1,11)]列表解析（创建10以内数的平方） 列表迭代遍历123nums = [1,2,3,4]for num in nums: print(num) 应用场景 即使python的列表可以存储不同类型的数据 在实际开发中： 列表存储相同类型的数据 通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 Tuple（元组）定义Python 的元组与列表类似，不同之处在于元组的元素不能修改,元组中通常保存不同类型的数据。 列表使用方括号 []，元组使用小括号 ()。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可 123tup = ('Google', 'Runoob', 1997, 2000)#定义只含一个元素的元组one_thing = (1,) 方法 元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用 访问：元组可以相list一样通过下标访问，使用索引时候用[] 修改：元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 删除：元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组 截取：元组同样可以通过[:]方法来截取 元组中能用的方法和列表差不多 1del tup #删除整个元组 应用场景 函数的参数和返回值，一个函数可以接受任意多个参数，或者一次返回多个数据 格式化字符串，格式化字符串后面的()，类如：print('this is %s he is %d'%(name,age))，本质上是一个元组 让列表不可修改，保护数据安全 Set（集合）集合（set）是一个无序的不重复元素序列。 123parame = {value01,value02,...}或者set(value) 添加：add() 移除：remove() 清空：clear() 12345s.add(x) #添加，如果元素已经存在，不进行任何操作s.update(x) #同样是添加元素s.remove(x) #元素不存在发生错误s.discard(x) #删除，不存在不会法生错误 集合函数 Python3 集合 | 菜鸟教程 (runoob.com) Dictionary（字典）123tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} 方法 123456789101112131415161718192021222324252627282930#取值,使用键值获取对应的值dic['key']# 添加dic = {} # 创建一个空字典dic['first'] = '1'# 修改键值对中的值dic['first'] = '一' #以关键字来访问# 删除键值对del dic['first'] #以关键字来访问删除dic.pop('key') #使用pop方法dic.clear() #清空字典# 遍历字典## 遍历字典键值对for key,value in dic.items()## 遍历所有的键for key in dic.keys()## 遍历所有值for value in dic.values()#合并字典##如果被合并的字典中含有已经存在的键值对，会覆盖原有的键值对temp_dict = {'height':1.75}now_dict.update(temp_dict) 字典特性 字典可以用来存储多个数据，通常用于存储描述一个物体的相关信息 和列表的区别是： 列表是有序的对象集合 字典是无序的对象集合 字典使用键值对存储数据，键值对之间用,分隔： 字典用{}定义 键key是索引 值value是数据 键和值之间使用:分隔 键必须是唯一的 值可以是任何数据类型，但键只能是字符串，数字或者元组（不可变类型） 在python中，设置字典的键值对时候，首先会对key进行hash决定在内存中如何保存字典中的数据，以便后续对字典的操作 应用场景 使用多个键值对时候，存储描述一个物体相关信息–描述更复杂的数据信息 将多个字典放在同一个列表中，在进行遍历，在循环体内部正对每一个字典进行相同的处理 公共方法运算符 逻辑结构程序的三大结构： 顺序 分支 循环 条件控制（if）if 123456if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 match case 123456789match subject: case &lt;pattern_1&gt;: &lt;action_1&gt; case &lt;pattern_2&gt;: &lt;action_2&gt; case &lt;pattern_3&gt;: &lt;action_3&gt; case _: &lt;action_wildcard&gt; case 12345678910111213mystatus=400print(http_error(400))def http_error(status): match status: case 400: return &quot;Bad request&quot; case 404: return &quot;Not found&quot; case 418: return &quot;I'm a teapot&quot; case _: return &quot;Something's wrong with the internet&quot; 循环语句（while for）while 12while 判断条件(condition)： 执行语句(statements)…… 经典用例 1234567891011121314151617181920212223242526272829303132# 列表之间移动元素sandwich_orders = ['rose','lily','maria']finished_sandwichs = []while sandwich_orders: concurrent_sandwich = sandwich_orders.pop() print(f'I make your {concurrent_sandwich}') finished_sandwichs.append(concurrent_sandwich)print(f'we have finieshed {finished_sandwichs}')#删除特定元素pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']print(pets)while 'cat' in pets: pets.remove('cat')print(pets)#填充字典qa = {}flag = Trueprint(type(flag))while flag: name = input('whats your name?') place = input('where would want to go someday?') qa[name] = place repeat = input('would want to talk more?(Yes/No) ') if repeat == 'No': flag = Falseprint(qa) for 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; range() 12345&gt;&gt;&gt;for i in range(5): #打印（0，5）... print(i)&gt;&gt;&gt;for i in range(5,9) : #前开后闭 print(i) break continue pass 12&gt;&gt;&gt;while True:... pass # 等待键盘中断 (Ctrl+C) python推导式列表推导式123456[表达式 for 变量 in 列表 if 条件]res = [x for x in range(1,10) if x%2==0] #迭代偶数列表print(res) [2, 4, 6, 8] 字典推导式1234567{ key_expr: value_expr for value in collection if condition }listdemo = ['Google','Runoob', 'Taobao']# 将列表中各字符串值为键，各字符串的长度为值，组成键值对&gt;&gt;&gt; newdict = {key:len(key) for key in listdemo}&gt;&gt;&gt; newdict{'Google': 6, 'Runoob': 6, 'Taobao': 6} 集合推导式12345{ expression for item in Sequence if conditional }&gt;&gt;&gt; setnew = {i**2 for i in (1,2,3)}&gt;&gt;&gt; setnew{1, 4, 9} 元组推导式12345678(expression for item in Sequence if conditional )&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象&gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9) 迭代器和生成器 15分钟彻底搞懂迭代器、可迭代对象、生成器【python迭代器】_哔哩哔哩_bilibili 迭代器 1234567891011121314151617181920212223242526272829303132#迭代器类型的定义 1.当类中定义了_iter和_next_两个方法 2._iter_方法需要返回对象本身，即self 3._next_方法，返回下一个数据，如果没有数据了，即要抛出一个StopIteration的异常 #创建迭代器类型 class IT(object): def _init_(self): self.count = 0 def _iter_(self): return self def _next_(self): self.count+=1 if self.count==3: raise StopIteration() return self.count #根据类实例创建一个迭代器对象 obj1 = IT() v1 = obj._next_()#执行类中的函数 v1 = next(obj1)#相当于执行上个代码 obj2 = IT() for item in obj2: #首先会执行迭代对象的_iter_方法并获取返回值，一直区反复执行next（对象）,每执行一次将返回值传递给item print(item) #迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration#for循环内部循环时候，先执行_iter_方法，获取一个迭代器对象，然后不断执行next取值 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 1234567891011121314# 创建生成器函数 def func(): yield 1 yield 2 #创建生成器对象（内部是更具生成器类generator创建的对象），生成器类的内部也声明了:__iter__,__next__方法 obj1= func() for item in obj1: print(item) #如果迭代器的规定来看，其实生成器也是一种特殊的迭代器类（生成器是一种特殊的迭代器） 可迭代对象 123456789101112131415161718192021#创建迭代器类型class IT(object): def _init_(self): self.count = 0 def _iter_(self): return self def _next_(self): self.count+=1 if self.count==3: raise StopIteration() return self.count class Foo(object): def __iter__(self): return IT() #返回迭代器对象 obj = Foo() #可迭代对象 for item in obj: #循环可迭代对象时候，内部限制性obj.__iter__并获取迭代器对象，不断执行迭代对象的__next__方法 print(item) 1234567891011121314151617181920212223242526#基于可迭代对象和迭代器实现：自定义rangeclass IterRange(object): def __init__(self,num): self.num = num self.counter = -1 def __iter__(self): return self self __next__(self): self.counter += 1 if self.counter ==self.num； raise StopIteration() return self.counter class Xrange(object): def __inint__(self,max_num): self.max_num = max_num def __iter__(self.max_num) obj = Xrange(100)for item in obj: print(item) python函数语法1234def greet_user(username): &quot;&quot;&quot;显示简单的问候语。&quot;&quot;&quot; print(f&quot;Hello, {username.title()}!&quot;)greet_user('jesse') 函数编写指南： 函数命名遵循使用小写加下划线表示意思 给形参指定默认值时候，等号两边不要有空格（同样对 使用关键字传递实参的时候） 参数过多时候，换行显示 形参实参上述定义函数greet_user()时，要求给变量username指定一个值。调用这个函数并提供这种信息的时候，它将打印相应的问候语。 在函数greet_user()的定义中，变量username是一个形参(parameter)，即函数完成工作所需要的信息。在调用函数greet_user(‘jesse’)中，值’jesse’是一个实参(argument)，即调用函数时候传递给函数的信息。调用函数时候，将要让函数使用的信息放在圆括号中。在函数greet_user(),这个值被赋给形参username。 ·参数传递 123a = [1,2,3]a = 'Runoob' 上述代码中[1,2,3]是list类型，’Runoob’是String类型，但是变量a是没有类型的，仅仅是一个对象的引用（指针），可以指向list或者String类型对象 可更改和不可更改对象 在python中，strings, tuples,和numbers是不可更改的对象，而list dict等则是可以修改的对象。 可变类型:变量赋值a=5后再赋值a=10,这里实际是新生成-个int值对象10.再让a指向它,而5被丢弃，不是改变a的值,相当于新生成了a. 可变类型:变量赋值la=[1,2,3,4] 后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改 python函数的参数传递: 可变类型:类似C++的值传递，如整数、字符串、元组。如fun(a),传递的只是a的值,没有影响a对象本身。如果在fun(a)内部修改a的值，则是新生成一个a的对象。 可变类型:类似C++的引用传递，如列表，字典。如fun(la),则是将la真正的传过去，修改后fun外部的la也会受影响python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 传递实参必须参数（位置参数）必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。（传入实参时候的顺序必须和定义形参时候的顺序一样） 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 123456def describe_pet(animal_type, pet_name): &quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot; print(f&quot;\\nI have a {animal_type}.&quot;) print(f&quot;My {animal_type}'s name is {pet_name.title()}.&quot;)# 调用时候直接声明实参类型describe_pet(animal_type='hamster', pet_name='harry') 让实参变为可选的 1234567891011 def get_formatted_name(first_name, last_name, middle_name=''): &quot;&quot;&quot;返回整洁的姓名。&quot;&quot;&quot; ❷ if middle_name: full_name = f&quot;{first_name} {middle_name} {last_name}&quot; ❸ else: full_name = f&quot;{first_name} {last_name}&quot; return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)❹ musician = get_formatted_name('john', 'hooker', 'lee')print(musician) 默认参数调用函数时，如果没有传递参数，则会使用默认参数。 12345def describe_pet(pet_name, animal_type='dog'): &quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot; print(f&quot;\\nI have a {animal_type}.&quot;) print(f&quot;My {animal_type}'s name is {pet_name.title()}.&quot;)describe_pet(pet_name='willie') 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数 第一种方法是使用*的方法引入 123456789101112131415161718192021def functionname([formal_args,]*var_args_tuple) “函数文档字符串” function_suite return [expression]加星号的参数会以元组的形式导入，存放所有未命名的变量参数def printInfo(arg1,*vartuple): print(arg1) print(vartuple) #调用函数print(70,60,50)#输出结果70(60, 50) 如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 第一种方法是使用**的方法引入，参数以字典的形式导入 1234567891011121314151617def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression] # 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 输出: 1{'a': 2, 'b': 3} 禁止函数修改列表： 1unprinted_designs[:] #表示unprinted_designs的副本，表示不想改变原来的数据 使用任意数量的关键字实参 123456789def build_profile(first, last, **user_info):&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切。&quot;&quot;&quot;❶ user_info['first_name'] = firstuser_info['last_name'] = lastreturn user_infouser_profile = build_profile('albert', 'einstein',location='princeton',field='physics')print(user_profile) 匿名函数Python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 1lambda [arg1 [,arg2,.....argn]]:expression 函数注释123def say_hello(): '''这是函数注释''' print('hello') 在使用函数时候通过热键CTRL+Q查看注释 python模块python提供一种方法，把定义的所有方法和变量都存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块的引入 模块的命名也要遵循标识符规则 import引入 在文件头部使用import引入库 123456#!/usr/bin/python3# Filename: support.py def print_func( par ): print (&quot;Hello : &quot;, par) return 12345678#!/usr/bin/python3# Filename: test.py # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func(&quot;Runoob&quot;) 这样做并没有把直接定义在库中的print_func写入到当前符号表中，只是把模块support写到了那里，可以把它赋给一个本地的名称 12print_func = support.ptint_func#之后调用函数直接使用print_func()就好了 from ...import 让你从模块中导入一个指定的部分到当前命令空间中： 1from modname import name1,name2 这个生命不会把整个模块导入到当前的命名空间中，只会把函数引入 from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的 引入库的最佳做法： 只导入需要使用的函数 导入整个模块使用句点表示法 标准模块Python 本身带着一些标准的模块库，有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。 包包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。 就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。 这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。 python面向对象面向对象基本概念 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 创建和使用对象创建Dog类123456789101112131415dog.py❶ class Dog: ❷ &quot;&quot;&quot;一次模拟小狗的简单尝试。&quot;&quot;&quot; ##init函数是构造函数 在实例化对象的时候会自动执行 ❸ def __init__(self, name, age): ## self是实例对象，self位置必须是第一个（dog = Dog() self 就是实例对象dog） &quot;&quot;&quot;初始化属性name和age。&quot;&quot;&quot; ❹ self.name = name self.age = age ❺ def sit(self): &quot;&quot;&quot;模拟小狗收到命令时蹲下。&quot;&quot;&quot; print(f&quot;{self.name} is now sitting.&quot;) def roll_over(self): &quot;&quot;&quot;模拟小狗收到命令时打滚。&quot;&quot;&quot; print(f&quot;{self.name} rolled over!&quot;) 类中的函数称为方法 根据类创建实例1my_dog = Dog(&quot;Willie&quot;,6) 使用句点法访问实例的属性和方法 继承编写类时，并非总是要从空白开始。如果要编写的类是另一个现成 类的特殊版本，可使用继承 。一个类继承 另一个类时，将自动获 得另一个类的所有属性和方法。原有的类称为父类 ，而新类称为 子类 。子类继承了父类的所有属性和方法，同时还可以定义自己 的属性和方法。 子类的__init__()1234❸ def __init__(self, make, model, year):&quot;&quot;&quot;初始化父类的属性。&quot;&quot;&quot; ❹ super().__init__(make, model, year) #super()是一个特殊函数，能够调用父类的方法 父类必须包含在当前的文件中，且位于子类前面 给子类定义属性和方法1234567891011121314class ElectricCar(Car): &quot;&quot;&quot;电动汽车的独特之处。&quot;&quot;&quot; def __init__(self, make, model, year): &quot;&quot;&quot; 初始化父类的属性。 再初始化电动汽车特有的属性。 &quot;&quot;&quot; super().__init__(make, model, year) #定义电车的电池属性 ❶ self.battery_size = 75 #定义电车的展示点亮方法 ❷ def describe_battery(self): &quot;&quot;&quot;打印一条᧿述电瓶容量的消息。&quot;&quot;&quot; print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;) 重写父类方法直接根据父类的方法名重新定义子类的方法 将实例用作属性当类添加细节过多时候，可以将一类细节提取出来作为一个类，这种条件下，类的层次会更加的清晰 1234567891011121314151617181920class Car:--snip--❶ class Battery:&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试。&quot;&quot;&quot; ❷ def __init__(self, battery_size=75): &quot;&quot;&quot;初始化电瓶的属性。&quot;&quot;&quot; self.battery_size = battery_size ❸ def describe_battery(self): &quot;&quot;&quot;打印一条᧿述电瓶容量的消息。&quot;&quot;&quot; print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)class ElectricCar(Car):&quot;&quot;&quot;电动汽车的独特之处。&quot;&quot;&quot; def __init__(self, make, model, year): &quot;&quot;&quot; 初始化父类的属性。 再初始化电动汽车特有的属性。 &quot;&quot;&quot; super().__init__(make, model, year) #直接在电车类中将电池类实例化 ❹ self.battery = Battery() 导入类像库一样存储类，但是使用类的时候要注意：如类的名称是car.py那么调用类的文件名为my_car.py，引入类的方法和库一样 。 文件从文件中读取数据读取全部数据12345with open('shutdown.bat') as file_obj: #open 打开文件，返回一个表示文件的对象，with表示在不需要文件后关闭 contents = file_obj.read()#末尾读到空内容时候返回一个空行，使用rstrip()清除空格print(contents) 逐行读取使用for循环逐行读取 创建一个包含文件各行内容的列表123filename = 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines() 数据写入文件写入空白文件12345filename = 'programming.txt'#以写模式打开文件 with open(filename, 'w') as file_object: file_object.write(&quot;I love programming.&quot;)#如果写入文件不存在 会自动创建 注意默认没有换行符，输入时候如有需要要添加换行符 模式 解释 w 写入模式（全覆盖） r 读取模式 a 追加模式 r+ 读写模式 异常处理不能被除以零的异常1234try: print(5/0)except ZeroDivisionError: print(&quot;You can't divide by zero!&quot;) else代码1234567891011while True:--snip--if second_number == 'q': break❶ try:answer = int(first_number) / int(second_number)❷ except ZeroDivisionError:print(&quot;You can't divide by 0!&quot;)# 依赖try代码成功执行的代码应该放到else中❸ else:print(answer) 测试代码","link":"/2023/03/23/python/"},{"title":"python_Excel操作","text":"python操作Excel 基本操作12345678910111213# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbook#如果没有文件创建文件wb = Workbook()#如果有文件读取文件wb = load_workbook(r'.\\test.xlsx')# 返回激活的sheetws = wb.activeprint(ws.title)# 保存文件wb.save(r'.\\test.xlsx') 工作表操作12345678#创建工作表（表名，表顺序位置）ws2 = wb.create_sheet('Sheet2',1)#打印文件中所有的工作表名print(wb.sheetnames)# 移动表的顺序wb.move_sheet(ws2,-1)# 删除工作表del wb[&quot;Sheet2&quot;] 访问单元格123456789101112131415161718192021222324252627282930# 访问单元格，以二位坐标形式（第几行，第几列，内容）cell = ws.cell(6,2,'coceef')#打印单元格内容print(cell.value)# 打印坐标print(cell.coordinate)# 打印行print(cell.row)# 打印列print(cell.column)# 打印列的字母print(cell.column_letter)x = 1for i in range(1,11): for j in range(1,6): ws.cell(i,j,x) x= x+1# 按列访问，返回从双层元组print(ws['a:c'])# 按行访问print(ws[1:5])# 自定义遍历print(ws['a1:c4'])# 遍历当行/列print(ws[1][2])# 遍历所有的行/列print(ws.iter_rows())print(ws.iter_cols()) 操作单元格1234567891011121314151617# 指定单元格 第一行到第二行，第二列到第六列print(ws.iter_rows(1,2,2,6))# 合并单元格(合并a1和b1)ws.merge_cells('a1:b1')# 取消合并ws.unmerge_cells('a1:b1')# 插入行/列ws.insert_rows(1,2)ws.insert_cols(1,2)# 删除行/列ws.delete_cols(1,2)ws.delete_rows(1,2)# 移动单元格(要移动的单元格，行移动，列移动)ws.move_range(&quot;a1:c4&quot;,4,4) 使用公式12345678910111213141516171819# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbookfrom openpyxl.utils import FORMULAEfrom openpyxl.formula.translate import Translatorwb = Workbook()ws = wb.activews.append(['价格1','价格2','求和','平均'])ws.append([12,33])ws.append([12,44])# 使用求和和平均值函数ws['c2'] = '=SUM(A2:B2)'ws['d2'] = '=AVERAGE(A2:B2)'ws['c3'] = Translator(formula='=SUM(A2:B2)',origin='c2').translate_formula('c3')ws['d3'] = Translator(formula='=AVERAGE(A2:B2)',origin='d2').translate_formula('d3')wb.save('test.xlsx') 设置样式12345678910111213141516# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbookfrom openpyxl.styles import Fontwb = Workbook()ws = wb.activews[&quot;a1&quot;] = 'fefefe'f= Font(name='微软雅黑',size=15,color='0000FF',bold=True,italic=True,strike=False,underline='double')ws['a1'].font = f# 第二行的高ws.row_dimensions[2].height = 30# 第二列的宽度ws.column_dimensions['B'].width = 30wb.save('test.xlsx')","link":"/2023/05/21/python-Excel%E6%93%8D%E4%BD%9C/"},{"title":"事件对象","text":"JS事件对象 事件对象 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数 在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标、键盘哪个按键被按下、鼠标滚轮滚动的方向。。。 练习：鼠标坐标显示 HTML 代码 12&lt;div id=&quot;areaDiv&quot;&gt;&lt;/div&gt;&lt;div id=&quot;showMsg&quot;&gt;&lt;/div&gt; CSS 代码 123456789101112#areaDiv { border: 1px solid black; width: 300px; height: 50px; margin-bottom: 10px;}#showMsg { border: 1px solid black; width: 300px; height: 20px;} JS 代码 1234567891011var areaDiv = document.getElementById(&quot;areaDiv&quot;);var showMsg = document.getElementById(&quot;showMsg&quot;);// 绑定鼠标移动事件areaDiv.onmousemove = function(event){ console.log(event); // IE8：undefined // clientX可以获取鼠标指针的水平坐标 // cilentY可以获取鼠标指针的垂直坐标 var x = event.clientX; var y = event.clientY; showMsg.innerHTML = &quot;x = &quot; + x + &quot;, y = &quot; + y;} 效果 内置浏览器 事件的冒泡（Bubble）所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发 在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡 可以将事件对象的cancelBubble设置为true，即可取消冒泡 123456document.getElementById(&quot;s1&quot;).onclick = function(event){ // 兼容event event = event || window.event; alert(&quot;我是span&quot;); // 我是span event.cancelBubble = true;}; 事件的委派（Delegate）HTML 代码 123456&lt;button type=&quot;button&quot; id=&quot;btn&quot;&gt;Add&lt;/button&gt;&lt;ul id=&quot;ulDiv&quot;&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; JS 代码 123456789101112131415161718function clickFun(){ alert(&quot;超链接&quot;);}window.onload = function(){ // 为每一个超链接都绑定一个单击响应函数 var aList = document.getElementsByTagName(&quot;a&quot;); for(var i=0;i&lt;aList.length;i++){ aList[i].onclick = clickFun; } var btn = document.getElementById(&quot;btn&quot;); var ulDiv = document.getElementById(&quot;ulDiv&quot;); btn.onclick = function(){ var li = document.createElement(&quot;li&quot;); li.innerHTML = &quot;&lt;a href=\\&quot;javascript:;\\&quot;&gt;add超链接&lt;/a&gt;&quot;; ulDiv.appendChild(li); };}; 为每一个超链接都绑定了一个单击响应函数，这种操作比较麻烦 而且这些操作只能为已有的超链接设置事件，而新添加的超链接必须重新绑定 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的 我们可以尝试将其绑定给元素的共同的祖先元素 这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 但是也有个问题，我们是给整个 ul 绑定的单击响应事件，ul 是块元素，在超链接所在行点击任何位置都会触发事件 12345678ulDiv.onclick = function(event){ event = event || window.event; // 如果触发事件的对象是我们期望的元素，则执行否则不执行 // alert(event.target); // 点击超链接外：[object HTMLLIElement]; 点击超链接：javascript:; if(event.target.className == &quot;link&quot;){ alert(&quot;事件委派超链接&quot;); }} 这里将tagName代替className作为判断条件进行判断 123456ulDiv.onclick = function(event){ event = event || window.event; if(event.target.tagName == &quot;A&quot; || event.target.tagName == &quot;a&quot;){ alert(&quot;事件委派超链接&quot;); }}; 事件的绑定（Bind）on事件名使用对象.事件 = 函数的形式绑定响应函数，它只能同时为一个元素的一个事件绑定一个响应函数 不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的 123456789var btn = document.getElementById(&quot;btn&quot;);// 为btn绑定一个单击响应函数btn.onclick = function() { alert(1);};// 为btn绑定第二个响应函数btn.onclick = function() { alert(2); // 2}; addEventListener()addEventListener()通过这个方法也可以为元素绑定响应函数，参数： 事件的字符串，不要on 回调函数，当事件触发时该函数会被调用 是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数 这样当事件被触发时，响应函数将会按昭函数的绑定顺序执行 123456789btn.addEventListener(&quot;click&quot;, function(){ alert(1); // 1}, false);btn.addEventListener(&quot;click&quot;, function(){ alert(2); // 2}, false);btn.addEventListener(&quot;click&quot;, function(){ alert(3); // 3}, false); IE8 需要用什么方法替代呢？ attachEvent()attachEvent()在 IE8 中可以用来绑定事件，参数： 事件的字符串，要on 回调函数 123456789btn.attachEvent(&quot;onclick&quot;, function(){ alert(1); // 1});btn.attachEvent(&quot;onclick&quot;, function(){ alert(2); // 2});btn.attachEvent(&quot;onclick&quot;, function(){ alert(3); // 3}); 在 IE8 中没有报错，但是执行顺序却是相反的，而且其他浏览器中直接就不行了 封装一个方法来兼容不同的浏览器 123456789101112// 定义一个函数，用来为指定元素绑定响应函数// 参数：// - obj 要绑定事件的对象// - eventStr 事件的字符串// - callback 回调函数function bind(obj, eventStr, callback) { if (obj.addEventListener) { obj.addEventListener(eventStr, callback, false); } else { obj.attachEvent(&quot;on&quot; + eventStr, callback); }} 1addEventListener()`中的`this`是绑定事件的对象，`attachEvent()`中的`this`是`window`，需要统一两个方法`this 我们之前讲过call和apply方法，this是指定的那个对象，是不是可以利用call或者apply方法对bind函数进行优化呢？ 123456789101112function bind(obj, eventStr, callback) { if (obj.addEventListener) { obj.addEventListener(eventStr, callback, false); } else { // this是谁由调用方式决定 // callback.call(obj) obj.attachEvent(&quot;on&quot; + eventStr, function(){ // 在匿名函数中调用回调函数 callback.call(obj); }); }} 事件的传播关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说件应该在 冒泡阶段 执行 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素 W3C综合了两个公司的方案，将事件传播分成了三个阶段 捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8 及以下的浏览器中没有捕获阶段 拖拽拖拽的流程 当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown 当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove 当鼠标松开时，被拖拽元素固定在当前位置 onmouseup HTML 代码 12&lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; CSS 代码 1234567891011121314#box1 { width: 100px; height: 100px; background-color: red; position: absolute;}#box2 { width: 100px; height: 100px; background-color: yellow; position: absolute; left: 300px; top: 300px;} JS 代码 1234567891011121314151617181920var box1 = document.getElementById(&quot;box1&quot;);// 1. 当鼠标在被拖拽元素上按下时，开始拖拽 `onmousedown`box1.onmousedown = function(event) { event = event || window.event; var boxLeft = event.clientX - box1.offsetLeft; // 鼠标水平坐标 - 元素水平偏移量 = 鼠标原点和元素原点水平距离 var boxTop = event.clientY - box1.offsetTop; // 鼠标垂直坐标 - 元素垂直偏移量 = 鼠标原点和元素原点垂直距离 // 2. 当鼠标移动时被拖拽元素跟随鼠标移动 `onmousemove` document.onmousemove = function(event) { event = event || window.event; box1.style.left = event.clientX - boxLeft + &quot;px&quot;; box1.style.top = event.clientY - boxTop + &quot;px&quot;; }; // 3. 当鼠标松开时，被拖拽元素固定在当前位置 `onmouseup` document.onmouseup = function(event) { // 取消document的onmousemove事件 document.onmousemove = null; // 取消document的onmouseup事件 document.onmouseup = null; };}; setCapture()123456789101112var btn1 = document.getElementById(&quot;btn1&quot;);var btn2 = document.getElementById(&quot;btn2&quot;);btn1.onclick = function() { alert(1);}btn2.onclick = function() { alert(2);}// 设置btn1对鼠标按下相关的事件进行捕获// 当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上btn1.setCapture(); 我们点击 btn2 按钮，发现只有刷新后的第一次点击的提示为1，再次点击就变成了2","link":"/2024/05/20/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"},{"title":"包装类和字符串","text":"JS 包装类和字符串 三大包装类基本数据类型：String、Number、Boolean、Null、Undefined 引用数据类型：Object 在JS中为我们提供了三大包装类，通过这三个包装类可以将基本数据类型的数据转换为对象 String()可以将基本数据类型字符串转换为String对象 Number()可以将基本数据类型的数字转换为Number对象 Boolean()可以将基本数据类型的布尔值转换为Boolean对象 123456789101112var str1 = &quot;hello&quot;;var str2 = new String();console.log(typeof str1); // stringconsole.log(typeof str2); // objectvar num1 = 3;var num2 = new Number(3);console.log(typeof num1); // stringconsole.log(typeof num2); // objectvar bol1 = true;var bol2 = new Boolean(true);console.log(typeof bol1); // stringconsole.log(typeof bol2); // object 但是注意：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果 1234567var n1 = new Number(1);var n2 = new Number(1);console.log(n1 == n2); // falsevar b = new Boolean(false);if(b){ console.log(b); // Boolean {false}} 方法和属性之能添加给对象，不能添加给基本数据类型（按照视频中的解释，是先将data临时转换为了一个包装类对象，进行了属性赋值操作；打印时又临时转换为了一个新的包装类对象，因为两次不是同一个对象，而且该对象刚刚创建，还没有任何属性和方法，所以是获取不到任何值的） 123var data = 4;data.hello = &quot;hello&quot;;console.log(data.hello); // undefined 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法调用完以后，在将其转换为基本数据类型 1234var s = 123;s = s.toString();console.log(s); // 123console.log(typeof s); // string 字符串方法字符串在底层是以字符数组的形式保存的：[&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;,&quot; &quot;,&quot;W&quot;,&quot;o&quot;,&quot;r&quot;,&quot;l&quot;,&quot;d&quot;,&quot;.&quot;] 1234var str = &quot;Hello World.&quot;;console.log(str[0]); // Hconsole.log(str[5]); // console.log(str[12]); // undefined length属性可以用来获取字符串的长度 1console.log(str.length); // 12 charAt()可以返回字符串中指定位置的字符，不会对原字符串产生影响 123var result = str.charAt(0);console.log(str); // Hello World.console.log(result); // H charCodeAt()获取指定位置字符的字符编码（Unicode编码），不会对原字符串产生影响 123456result = str.charCodeAt(0);console.log(str); // Hello World.console.log(result); // 72var str2 = &quot;您好，世界。&quot;;result = str2.charCodeAt(0);console.log(result); // 24744 String.formCharCode()可以根据字符编码去获取字符 123456result = String.fromCharCode(72);console.log(result); // Hresult = String.fromCharCode(24744);console.log(result); // 您result = String.fromCharCode(0x2682);console.log(result); // ⚂ concat()可以用来连接两个或多个字符串，作用和+一样，不会对原字符串产生影响 123result = str.concat(&quot;您好&quot;,&quot;世界&quot;);console.log(str); // Hello World.console.log(result); // Hello World.您好世界 indexof()该方法可以检索一个字符串中是否含有指定内容，不会对原字符串产生影响 如果字符串中含有该内容，则返回其第一次出现的索引 如果没有找到指定的内容，则返回-1 12345result = str.indexOf(&quot;o&quot;);console.log(str); // Hello World.console.log(result); // 4result = str.indexOf(&quot;y&quot;);console.log(result); // -1 可以指定一个第二个参数，指定开始查找的位置 1234result = str.indexOf(&quot;l&quot;,3);console.log(result); // 3result = str.indexOf(&quot;l&quot;,4);console.log(result); // 9 lastIndexof()该方法的用法和indexOf()一样，不同的是indexOf是从前往后找，而lastIndexOf是从后往前找 但返回的索引是按照从前往后计数的 1234result = str.lastIndexOf(&quot;o&quot;);console.log(result); // 7result = str.lastIndexOf(&quot;l&quot;);console.log(result); // 9 可以指定一个第二个参数，指定开始查找的位置（不过开始位置也是从后往前数的） 12result = str.lastIndexOf(&quot;l&quot;, 6);console.log(result); // 3 slice()可以从字符串中截取指定的内容，不会影响原字符串 第一个参数，开始位置的索引（包括开始位置） 第二个参数，结束位置的索引（不包括结束位置） 123result = str.slice(0,2);console.log(str); // Hello World.console.log(result); // He 如果省略第二个参数，则会截取到后边所有的 12result = str.slice(6);console.log(result); // World. 也可以传递一个负数作为参数，负数的话将会从后边计算 12result = str.slice(6,-1);console.log(result); // World substring()可以用来截取一个字符串，不会影响原字符串，和slice()类似 第一个参数，开始位置的索引（包括开始位置） 第二个参数，结束位置的索引（不包括结束位置） 123result = str.substring(0,2);console.log(str); // Hello World.console.log(result); // He 不同的是这个方法不能接受负值作为参数，如果传递了一个负值，则默认使用0 而且会自动调整参数的位置，如果第二个参数小于第一个，则自动交换 1234result = str.substring(1,-1); // 自动调整为str.substring(0,1);console.log(result); // Hresult = str.substring(1,0); // 自动调整为str.substring(0,1);console.log(result); // H substr()用来截取字符串，不会影响原字符串，不过不建议使用 第一个参数，截取开始位置的索引 第二个参数，截取的长度 123result = str.substr(1,3);console.log(str); // Hello World.console.log(result); // ell split()可以将一个字符串拆分为一个数组，不会影响原字符串 需要一个字符串作为参数，将会根据该字符串去拆分数组 123456result = str.split(&quot;o&quot;);console.log(str); // Hello World.console.log(result); // [&quot;Hell&quot;, &quot; W&quot;, &quot;rld.&quot;]console.log(result[0]); // Hellconsole.log(result[1]); // Wconsole.log(result[2]); // rld. 如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素 12result = str.split(&quot;&quot;);console.log(result); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;W&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;.&quot;] toUpperCase()将一个字符串转换为大写并返回，不会影响原字符串 123result = str.toUpperCase();console.log(str); // Hello World.console.log(result); // HELLO WORLD. toLowerCase()将一个字符串转换为小写并返回，不会影响原字符串 123result = str.toLowerCase();console.log(str); // Hello World.console.log(result); // hello world.","link":"/2024/04/30/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"10-变形：平移、旋转与缩放","text":"CSS变形：平移、旋转与缩放 平移 translateX() 沿着由方向平移 translateY() 沿着 y 轴方向平移 translateZ() 沿着 z 轴方向平移平移元素 百分比是相对于自身计算的 几种水平垂直双方向居中的方式对比 绝对定位的方式 1234567/* 这种居中方式，只适用于元素的大小确定，例如对行内元素会优先使用宽高来满足绝对约束 */position: absolute;top: 0;left: 0;bottom: 0;right: 0;margin: auto; 定位 - Hexo (gitee.io) table-cell的方式 1234/* table-cell的方式具有一定局限性 */display: table-cell;vertical-align: middle;text-align: center; transform的方式 12345/* transform变形平移的方式 */position: absolute;left: 50%;top: 50%;transform: translateX(-50%) translateY(-50%); 用平移实现浮动效果: 123456789101112.box1{ width: 300px; height: 300px; background-color: rgb(197, 192, 186); margin: 40px auto; transition: transform .3s;}.box1:hover{ background-color: rgb(197, 192, 186); transform: translateY(-10px); box-shadow: 0 0 10px rgb(0, 0, 0.3);} z 轴平移z 轴平移，调整元素在 z 轴的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近 z 轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果必须要设置网页的视距 123456789101112131415161718&lt;style&gt;/* 将视距设置给body才生效,设置给html没有生效 */body{ /* 设置视距：人眼到网页的距离 */ perspective: 800px;}.box1{ width: 100px; height: 100px; background-color: rgb(197, 192, 186); margin: 40px auto; transition: .3s;}.box1:hover{ background-color: rgb(197, 186, 189); transform: translateZ(100px);}&lt;/style&gt; 旋转通过旋转可以使元素沿着 x、y 或 z 旋转指定的角度 rotateX() rotateY() rotateZ() 注意：旋转后如果进行平移，是根据旋转后图形所在的坐标系决定的 1234/* transform: rotateY(0.5turn); */transform: rotateY(180deg); /* 设置转到背面后是否可见 */ backface-visibility: hidden; 练习（钟表）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 &lt;style&gt; .clock { position: relative; width: 500px; height: 500px; /* background-color: rgb(15, 73, 73); */ background-image: url(./img/13/bg3.jpg); background-size: cover; margin: 70px auto; border-radius: 50%; border: 7px solid black; } /* 设置时钟指针上下左右居中 */ .clock&gt;div { position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; } /* 设置动画 */ @keyframes run { form { transform: rotateZ(0); } to { transform: rotateZ(360deg); } } .hour-wrapper { width: 70%; height: 70%; /* background-color: aqua; */ animation: run 360s ; } .hour { height: 50%; width: 6px; background-color: black; margin: 0 auto; } .min-wrapper { width: 80%; height: 80%; /* background-color: aqua; */ animation: run 30s steps(60) infinite; } .min { height: 50%; width: 4px; background-color: rgb(142, 146, 204); margin: 0 auto; } .sec-wrapper { width: 90%; height: 90%; /* background-color: aqua; */ animation: run 0.5s steps(60) infinite; } .sec{ height: 50%; width: 2px; background-color: rgb(233, 2, 90); margin: 0 auto; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;hour-wrapper&quot;&gt; &lt;div class=&quot;hour&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;min-wrapper&quot;&gt; &lt;div class=&quot;min&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;sec-wrapper&quot;&gt; &lt;div class=&quot;sec&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 练习（旋转立方体）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 &lt;style&gt; body { /* 设置视距 视距要给包裹块*/ perspective: 300px; } .cube { width: 200px; height: 200px; margin: 170px auto; /* background-color: #bfa; */ /* 设置3d效果 */ transform-style: preserve-3d; /* 旋转动画 */ animation: cube_rotate 20s infinite linear; } @keyframes cube_rotate { from { transform: rotateX(0) rotateZ(0); } to { transform: rotateX(1turn) rotateZ(1turn); } } .cube&gt;div { width: 200px; height: 200px; /* 透明效果 */ opacity: 0.7; position: absolute; } img { vertical-align: top; } .box1 { transform: rotateY(90deg) translateZ(100px); } .box2 { transform: rotateY(-90deg) translateZ(100px); } .box3 { transform: rotateX(90deg) translateZ(100px); } .box4 { transform: rotateX(-90deg) translateZ(100px); } .box5 { transform: rotateY(180deg) translateZ(100px); } .box6 { transform: rotateX(0deg) translateZ(100px); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;img src=&quot;./img/14/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;img src=&quot;./img/14/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box3&quot;&gt; &lt;img src=&quot;./img/14/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box4&quot;&gt; &lt;img src=&quot;./img/14/4.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box5&quot;&gt; &lt;img src=&quot;./img/14/5.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box6&quot;&gt; &lt;img src=&quot;./img/14/6.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 缩放对元素进行缩放的函数 scalex() 水平方向缩放 scaleY() 垂直方向缩放 scale() 双方向的缩放 123456789101112131415.box { height: 200px; width: 200px; background-color: #bfa; margin: 200px auto; transition: 2s;}.box:hover { /* transform: scaleX(2); */ /* transform: scaleY(2); */ transform: scale(2); /* 变形的原点 */ transform-origin: 0 0;}","link":"/2024/03/13/%E5%8F%98%E5%BD%A2%EF%BC%9A%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E4%B8%8E%E7%BC%A9%E6%94%BE/"},{"title":"定时和延时调用","text":"JS定时和延时调用 定时调用JS 的程序的执行速度是非常非常快的如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用 setInterval()定时调用，可以将一个函数，每隔一段时间执行一次 参数： 回调函数，该函数会每隔一段时间被调用一次 每次调用间隔的时间，单位是毫秒 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识 12345var num = 1;info = document.getElementById(&quot;info&quot;);setInterval(function(){ info.innerHTML = num++;}, 1000); clearInterval()可以用来关闭一个定时器，方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 123456var timer = setInterval(function(){ info.innerHTML = num++; if(num &gt; 100){ clearInterval(timer); }}, 10); 延时调用setTimeout()、clearTimeout()延时调用，延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 延时调用和定时调用的区别：定时调用会执行多次，而延时调用只会执行一次 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 12345678var num = 1;var timer = setInterval(function(){ console.log(num++); // 1 2 3 4 5 ...}, 1000);var timer = setTimeout(function(){ console.log(num++); // 1}, 1000);clearTimeout(timer); 类的操作修改class属性HTML 代码 123&lt;button type=&quot;button&quot; id=&quot;btn1&quot;&gt;点击按钮修改box1样式&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;div id=&quot;box1&quot; class=&quot;b1&quot;&gt;&lt;/div&gt; CSS 代码 12345.b1{ width: 100px; height: 100px; background-color: red;} JS 代码 123box1.style.width = &quot;200px&quot;;box1.style.height = &quot;200px&quot;;box1.style.backgroundColor = &quot;yellow&quot;; 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面 这样执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 那怎么办呢？ 我们可以先事先定义好一个 class 属性，里面写好我们需要变化的样式 12345.b2{ width: 200px; height: 200px; background-color: yellow;} 然后在 JS 中修改className属性即可 1box1.className = &quot;b2&quot;; 效果是一样的 我们可以通过修改元素的class属性来间接的修改样式 这样一来，我们只需要修改一次，即可同时修改多个样式 浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离 添加class属性我们可以在此样式基础之上，定义一个函数，用来向一个元素中添加指定的 class 属性值 1234567891011// 参数：// obj 要添加class属性的元素// cn 要添加的class值function addClass(obj, cn){ obj.className += &quot; &quot; + cn;}//.b3{// position: absolute;// left: 100px;//}addClass(box1, &quot;b3&quot;); 但是也存在一个问题，虽然从效果上来看没有什么不同，但多次点击后会重复添加相同的 class 属性，而这个操作是多余的 我们就需要在写一个函数来判断是否已经存在 class 属性 12345678910function hasClass(obj, cn) { // return obj.className.indexOf(cn) != -1; var reg = new RegExp(&quot;\\\\b&quot;+cn+&quot;\\\\b&quot;); return reg.test(obj.className);}function addClass(obj, cn) { if (!hasClass(obj, cn)) { obj.className += &quot; &quot; + cn; }} 删除class属性删除一个元素中的指定的 class 属性 1234function removeClass(obj, cn) { var reg = new RegExp(&quot;\\\\b&quot; + cn + &quot;\\\\b&quot;); obj.className = obj.className.replace(reg, &quot;&quot;);} 切换class属性12345678910// toggleClass可以用来切换一个类// 如果元素中具有该类，则删除// 如果元素中没有该类，则添加function toggleClass(obj, cn) { if (hasClass(obj, cn)) { removeClass(obj, cn); } else { addClass(obj, cn); }}","link":"/2024/05/31/%E5%AE%9A%E6%97%B6%E5%92%8C%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8/"},{"title":"6-字体","text":"CSS字体 字体相关样式 color用来设置字体颜色 font-size字体的大小 em 相当于当前元素的一个font-size rem 相对于根元素的一个font-size font-familyfont-family 指定字体的类别，浏览器会自动使用该类别下的字体 font-family可以同时指定多个字体，多个字体间使用，隔开 字体生效时优先使用第一个，第一个无法使用则使用第二个，以此类推: 1font-family: &quot;Courier New&quot;, Courier, monospace; 常见字体 CSS Fonts(字体) | 菜鸟教程 (runoob.com) @font-face除了使用系统自带的字体外,还可以在服务器自定义字体位置 123456789101112131415@font-face { /* 指定字体名字 */ font-family: &quot;myFont1&quot;; /* 服务器中字体路径 */ src: url(&quot;/font/ZCOOLKuaiLe-Regular.woff&quot;), url(&quot;/font/ZCOOLKuaiLe-Regular.otf&quot;), url(&quot;/font/ZCOOLKuaiLe-Regular.ttf&quot;) format(&quot;truetype&quot;); /* 指定字体格式，一般不写 */}/* 定义之后引用 */p { font-size: 30px; color: salmon; font-family: myFont1;} 缺点: 受网络速度影响,可能会出现字体闪烁 版权 字体格式多,要指定多个 图标字体（iconfont）图标字体简介在网页中经常需要使用一些图标，可以通过图片来引入图标但是图片大小本身比较大，并且非常的不灵活 所以在使用图标时，我们还可以将图标直接设置为字体，然后通过@font-face的形式来对字体进行引入 这样我们就可以通过使用字体的形式来使用图标 fontawesome Font Awesome官网 下载解压完毕之后，直接将 css 和 webfonts 移动到项目中即可使用 123&lt;link rel=&quot;stylesheet&quot; href=&quot;./exercise/fontawesome-free-6.5.1-web/css/all.css&quot; &gt; &lt;div class=&quot;fab fa-qq&quot; style=&quot;font-size: 30px;&quot;&gt;&lt;/div&gt; 图标字体其他使用方式通过伪元素 找到要设置图标的元素通过::before或::after选中 在content中设置字体的编码 设置字体的样式 fab：font-family: 'Font Awesome 5 Brands'; fas：font-family: 'Font Awesome 5 Free'; font-weight：900; 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .poem { width: 200px; height: 300px; margin: auto; } li { list-style: none; margin-left: -40px; } li::before { content: &quot;\\f130&quot;; /* font-family: 'Font Awesome 5 Brands'; */ font-family: &quot;Font Awesome 5 Free&quot;; font-weight: 900; margin-right: 10px; color: gray; }&lt;/style&gt;&lt;div class=&quot;poem&quot;&gt; &lt;h1&gt;武陵春·春晚&lt;/h1&gt; &lt;p&gt;[宋] 李清照&lt;/p&gt; &lt;ul&gt; &lt;li&gt;风住尘香花已尽，&lt;/li&gt; &lt;li&gt;日晚倦梳头。&lt;/li&gt; &lt;li&gt;物是人非事事休，&lt;/li&gt; &lt;li&gt;欲语泪先流。&lt;/li&gt; &lt;li&gt;闻说双溪春尚好，&lt;/li&gt; &lt;li&gt;也拟泛轻舟。&lt;/li&gt; &lt;li&gt;只恐双溪舴艋舟，&lt;/li&gt; &lt;li&gt;载不动、许多愁。&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 通过实体设置通过实体来使用图标字体：&amp;#x图标编码; 1&lt;i class=&quot;fas&quot;&gt;&amp;#xf025;&lt;/i&gt; iconfont行高行高line height文字占有的实际高度，可以通过line-height来设置行高 可以直接指定一个大小 px/em 也可以直接为行高设置一个小数（字体大小的倍数） 行高经常还用来设置文字的行间距：行间距 = 行高 - 字体大小 字体框字体框就是字体存在的格子，设置font-size实际上就是在设置字体框的高度 行高会在字体框的上下平均分配 123border: 1px black solid;font-size: 100px;/* line-height: 100px; */ 字体的简写属性font 可以设置字体相关的所有属性： 1font: font-style font-variant font-weight font-size/line-height font-family 其中某些值可以不写，会用默认值 默认值 属性 默认值 其他常用值 font-style normal italic font-variant normal small-caps font-weight normal bold font-size medium small、large line-height normal font-family 取决于浏览器 文本对齐方式水平对齐text-align 文本的水平对齐 text-align属性值 对齐方式说明 left 左侧对齐 right 右侧对齐 center 居中对齐 justify 两端对齐 垂直对齐vertical-align 设置元素垂直对齐的方式 vertical-align 属性值 对齐方式说明 baseline 基线对齐 top 顶部对齐 bottom 底部对齐 middle 居中对齐 图片的垂直对齐问题 1234567891011121314&lt;style&gt; .imgDiv { border: 5px seagreen solid; } .imgDiv img { width: 400px; height: 300px; }&lt;/style&gt;&lt;div class=&quot;imgDiv&quot;&gt; &lt;img src=&quot;/assets/news.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; 明显默认情况下，图片底部有一定缝隙，我们稍作修改，给 img 元素添加vertical-align属性值 1234/* 只要不是基线对齐，就能消除底部缝隙 */vertical-align: top;vertical-align: bottom;vertical-align: middle; Q：为什么图片会有缝隙？ A：图片属于替换元素，特点与文本一致，也有自己的基线，默认也是基线对齐。而基线位置不在最底部，所以会出现缝隙","link":"/2024/02/29/%E5%AD%97%E4%BD%93/"},{"title":"JS对象","text":"JS Object对象， Object 对象基本数据类型都是单一的值&quot;hello&quot; 123 true，值和值之间没有任何的联系。 在JS中来表示一个人的信息（name gender age）： 123var name = &quot;孙悟空&quot;;var gender = &quot;男&quot;;var age = 18; 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。 对象的分类内建对象由ES标准中定义的对象，在任何的ES的实现中都可以使用 常见内建对象有以下，都可以直接通过new调用构造函数创建对象实例： Object、Function、Array、String、Number、Boolean、Date、RegExp Error（EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError） 宿主对象由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 比如 BOM DOM 1234// consoleconsole.log(&quot;hello&quot;);// documentdocument.write(&quot;hello&quot;); JavaScript实现包括三部分： 组成 作用 地位 例子 ES（ECMAScript） 描述JS语法和基本对象 核心 DOM（Document Object Model 文档对象模型） HTML和XML的应用程序接口，处理网页内容的方法和接口 W3C标准 document BOM（Browser Object Model 浏览器对象模型） 描述与浏览器进行交互的方法和接口，处理浏览器窗口和框架 浏览器厂商对DOM的实现 window DOM BOM DOM 和 BOM 的关系 自定义对象使用new关键字调用的函数，是构造函数constructor，构造函数是专门用来创建对象的 函数使用typeof检查一个对象时，会返回object 在对象中保存的值称为属性 添加或修改对象属性的语法：对象.属性名=属性值; 读取对象属性的语法：对象.属性名 删除对象属性的语法：delete 对象.属性名; 1234567891011var obj = new Object();// 向obj中添加一个name属性obj.name = &quot;孙悟空&quot;;// 向obj中添加一个gender属性obj.gender = &quot;男&quot;;// 向obj中添加一个age属性obj.age = &quot;18&quot;;// 打印objconsole.log(typeof obj); // objectconsole.log(obj); // {&quot;age&quot;:&quot;18&quot;,&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;孙悟空&quot;}console.log(obj.name); // 孙悟空 属性名对象的属性名不强制要求遵守标识符的规范，还是尽量贴近标准 如果要使用特殊的属性名，不能采用.的方式来操作，而需要使用另一种语法：对象[&quot;属性名&quot;]=属性值，读取时也需要采用这种方式 12obj[&quot;name&quot;] = &quot;齐天大圣&quot;;console.log(obj[&quot;name&quot;]); // 齐天大圣 使用[]这种形式去操作属性，更加的灵活，在[]中可以直接传递一个变量，这样变量值是哪个就会读取哪个属性 123var n = &quot;nihao&quot;;obj[n] = &quot;你好&quot;;console.log(obj[n]); // 你好 属性值JS对象的属性值，可以是任意的数据类型，包括对象 1234var obj2 = new Object();obj2.name = &quot;猪八戒&quot;;obj.bro = obj2;console.log(obj.bro.name); // 猪八戒 in运算符 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有则返回false 语法：&quot;属性名&quot; in 对象 12console.log(&quot;test&quot; in obj); // falseconsole.log(&quot;name&quot; in obj); // true 基本数据类型和引用数据类基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型 JS中的变量都是保存到栈内存中的，基本数据类型的值直接在栈内存中存储 值与值之间是独立存在，修改一个变量不会影响其他的变量 12345var a = 1;var b = a;console.log(&quot;a=&quot; + a + &quot;, b=&quot; + b); // a=1, b=1b = 2;console.log(&quot;a=&quot; + a + &quot;, b=&quot; + b); // a=1, b=2 引用数据类型 对象是保存到堆内存中的 每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用） 如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响 1234var obj2 = obj;obj.name = 1;console.log(obj.name); // 1console.log(obj2.name); // 1 比较 当比较两个基本数据类型的值时，就是比较值。 而比较两个引用数据类型时，它是比较的对象的内存地址，如果两个对象是一摸一样的，但是地址不同，它也会返回false 12345var obj = new Object();var obj2 = new Object();obj[&quot;name&quot;] = 2;obj2[&quot;name&quot;] = 2;console.log(obj == obj2); // false 对象字面量使用对象字面量，可以在创建对象时，直接指定对象属性的语法：{属性名: 属性值, 属性名: 属性值...} 对象字面量的属性名可以加引号也可以不加（建议不加），如果要使用一些特殊的名字，则必须加引号 属性名和属性值是一组一组的名值对结构，名和值之间使用:连接，多个名值对之间使用,隔开 如果一个属性之后没有其他的属性了，就不要写,了 123456789var obj = { name: &quot;孙悟空&quot;, age: 1000, gender: &quot;男&quot;, bor:{ name: &quot;猪八戒&quot; }}console.log(obj); // {&quot;age&quot;:1000,&quot;bor&quot;:{&quot;name&quot;:&quot;猪八戒&quot;},&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;孙悟空&quot;} 方法对象的属性值可以是任何的数据类型，也可以是个函数（下一节知识） 函数也可以称为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法 调用函数就说调用对象的方法，但是它只是名称上的区别没有其他的区别 12345678var obj2 = { name: &quot;猪八戒&quot;, age: 18, sayName: function() { console.log(obj2.name); }};obj2.sayName(); // 猪八戒 枚举对象中的属性使用for...in语句语法： 123for(var 变量 in 对象) { 语句...} for...in语句对象中有几个属性，循环体就会执行几次 123456789101112131415161718var obj = { name:'liu', age: 25, gender: 'male', ambition: 'leader', bro: { take: 3 }}for (var key in obj){document.write(key + '=' + obj[key])document.write(' ')}// name=liu age=25 gender=male ambition=leader bro=[object Object]","link":"/2024/03/27/%E5%AF%B9%E8%B1%A1/"},{"title":"5-定位","text":"CSS定位 定位简介定位（position） 定位是一种更加高级的布局手段 通过定位可以将元素摆放到页面的任意位置 使用position属性来设置定位 可选值 含义 static 不开启定位，元素是静止的，默认值 relative 开启元素的相对定位 absolute 开启元素的绝对定位 fixed 开启元素的固定定位 sticky 开启元素的粘滞定位 相对定位使用了相对定位后，只会移动自身的布局位置，而不会对已存在的其他元素产生任何影响 偏移量（offset）当元素开启相对定位以后，可以通过偏移量来设置元素的位置 offset 属性 含义 top 定位元素和定位位置的上边距离 bottom 定位元素和定位位置的下边距离 left 定位元素和定位位置的左侧距离 right 定位元素和定位位置的右侧距离 定位元素垂直方向的位置由top和bottom两个属性控制，通常情况下只会使用其中之一 top值越大，定位元素越靠下 bottom值越大，定位元素靠上 定位元素水平方向的位置由left和right两个属性控制，通常情况下只会使用其中之一 left越大，定位元素越靠右 right越大，定位元素越靠左 相对定位的特点 当元素开启相对定位以后，如果不设置偏移量元素，则元素不会发生任何变化（这里注意，不仅仅是位置） 相对定位是参照于元素在文档流中的位置进行定位的（可以理解为相对于自身原始位置） 相对定位会提升元素的层级（表现为可以覆盖其他元素） 相对定位不会改变元素的性质：块还是块，行内还是行内,不会脱离文档流 Q1:如果给上述三个 div 都设置相对定位，那么它们的层级关系会是什么样的呢？或者说谁会被谁覆盖呢？ 12345678910111213141516171819202122232425262728293031 &lt;style&gt; .box1{ width: 100px; height: 100px; background-color: red; position: relative; left: 10px; } .box2{ width: 100px; height: 100px; background-color: yellow; position: relative; left: 10px; bottom: 50px; } .box3{ width: 100px; height: 100px; background-color: blue; position: relative; left: 10px; bottom: 120px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; A：在页面文档流中，越靠下的元素开启相对定位后，其层级越高(z-index) Q2：相对定位的第三个特点相对定位会提升元素的层级，是不是就类似于浮动一样脱离了文档流？ A：我们可以对比下，浮动和相对定位的区别 参考系不同：浮动的参考系是其父元素；相对定位是相对于自身 可移动方向不同：浮动只能左右移动；相对定位是上下左右移动 影响不同：浮动会影响页面布局（包括下方元素位置影响和高度塌陷问题）；相对定位不对影响页面布局 性质不同：浮动会改变元素的性质（不再独占一行，其宽高都会被内容撑开）；相对定位不会改变元素的性质 文字环绕：浮动不会覆盖文字；相对定位可以覆盖文字（这个可以自行验证，不再赘述） 当然，浮动和相对定位也有其相似之处 浮动和相对定位都是移动位置（貌似是废话） 浮动和相对定位不会从父元素中移出 Q3：相对定位的第四个特点中块还是块，行内还是行内，意味着行内元素也可以使用相对定位是吗？ A：可以 绝对定位绝对定位的特点 开启绝对定位后，如果不设置偏移量，元素的位置不会发生变化 开启绝对定位后，元素会从文档流中脱离 绝对定位会改变元素的性质：行内变成块，块的宽高被内容撑开（与相对定位相反） 绝对定位会使元素提升一个层级 绝对定位元素是相对于其包含块进行定位的（与相对定位不同） 包含块（containing block）正常情况下： 包含块就是离当前元素最近的开启了定位的祖先块元素 如果所有的祖先元素都没有开启定位，则html（根元素、初始包含块）就是它的包含块 绝对定位元素的布局水平布局在文档流中的水平布局等式： 1margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素的宽度 当使用绝对定位时，需要添加left和right两个值（此时规则和之前一样，只是多添加了两个值） 1left + margin-left + border-left + padding-left + width + padding-right + border-right + margin-right + right = 其包含块素的宽度 当发生过度约束时 如果 9 个值中没有auto，则自动调整right值以使等式满足（之前 7 个值是margin-right） 如果 9 个值中有auto，则自动调整auto的值以使等式满足 可设置auto的值： margin-left/margin-right /width /left /right 因为left和right的值默认是auto，所以如果没有设置left和right，当等式不满足时，则会自动调整这两个值 垂直布局垂直方向布局的等式的也必须要满足 1top + margin-top + border-top + padding-top + height + padding-bottom + border-bottom + margin-bottom + top = 其包含块元素的高度 固定定位固定定位的特点 将元素的position属性设置为fixed，则开启了元素的固定定位 固定定位也是一种绝对定位，所以固定定位的大部分特点都和绝对定位一样 唯一不同的是，固定定位永远参照于浏览器的视口（viewport，可视窗口）进行定位，不会随网页的滚动条滚动 粘滞点位 该元素是根据文档流进行定位的，即相对于包含块进行偏移 偏移量不会影响任何其他元素的位置 粘性元素总是“粘”到其最近的具有“滚动机制”的祖先元素（当overflow为hidden、scroll、auto、overlay时创建），即使该祖先不是最近的实际滚动祖先 粘滞定位的特点 粘滞定位和相对定位的特点基本一致 不同的是粘滞定位可以在元素到达某个位置时将其固定 几种定位的对比我们通过上面的学习，知道position属性有五个可选值 但static是默认值，即不开启定位，所以我们只需要对比 4 种定位方式即可 定位方式 是否不设置偏移量，元素不会发生改变 是否脱离文档流 是否改变元素性质 是否提升元素层级 参考系 relative（相对定位） √ × × √ 参照于元素在文档流中的位置 absolute（绝对定位） × √ √ √ 参照于其包含块 fixed（固定定位） × √ √ √ 参照于浏览器的视口 sticky（粘滞定位） × √ √ √ 参照于浏览器的视口 元素的层级对于开启了定位元素，可以通过z-index属性来指定元素的层级 z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示 如果元素的层级一样，则优先显示靠下的元素 祖先的元素的层级再高，也不会盖住后代元素","link":"/2024/03/01/%E5%AE%9A%E4%BD%8D/"},{"title":"12-flex弹性盒","text":"CSSflex弹性盒 基本概念弹性盒flex（弹性盒、伸缩盒） 是css中的又一种布局手段，它主要用来代替浮动来完成页面的布局 flex可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变 弹性容器要使用弹性盒，必须先将一个元素设置为弹性容器 我们通过display 来设置弹性容器 display:flex 设置为块级弹性容器 display:inline-flex 设置为行内的弹性容器 练习(弹性导航条)123456789101112131415161718192021222324252627&lt;style&gt; .nav{ width: 1210px; height: 48px; margin: 50px auto; /* 文字垂直方向居中 */ line-height: 48px; background-color: #e6e7e2; /* 设置为弹性盒子 */ display: flex; } .box{ flex-grow: 1; } .nav a{ display: block; color: #808080; text-decoration: none; font-size: 16px; text-align: center; } .nav a:hover{ background-color: #636363; color: #fff; }&lt;/style&gt; 弹性容器的属性主轴与侧轴 主轴：弹性元素的排列方向称为主轴 侧轴：与主轴垂直方向的称为侧轴 主轴属性排列方式flex-direction 指定容器中弹性元素的排列方式 row默认值，弹性元素在容器中水平排列（自左向右） row-reverse 弹性元素在容器中反向水平排列（自右向左） column 弹性元素纵向排列（自上向下） column-reverse 弹性元素反向纵向排列（自下向上） 12/* 设置弹性元素排列方式 */flex-direction: column; 自动换行flex-wrap 设置弹性元素是否在弹性容器中自动换行 nowrap 默认值，元素不会自动换行 wrap 元素沿着辅轴方向自动换行 1234/* 设置弹性元素排列方式 */flex-direction: row;/* 设置自动换行 */flex-wrap: wrap; 简写属性 flex-flow 是wrap和direction的简写属性 12/* 简写属性 */flex-flow: row wrap; 空白空间justify-content 如何分配主轴上的空白空间（主轴上的元素如何排列） flex-start 元素沿着主轴起边排列 flex-end 元素沿着主轴终边排列 center 元素居中排列 space-around 空白分布到元素两侧 space-between 空白均匀分布到元素间 space-evenly 空白分布到元素的单侧 辅轴属性辅轴对齐align-items元素在辅轴上如何对齐 stretch 默认值，将元素的长度设置为相同的值 flex-start 元素不会拉伸，沿着辅轴起边对齐 flex-end 沿着辅轴的终边对齐 center 居中对齐 baseline 基线对齐 空白空间align-content 如何分配辅轴上的空白空间（辅轴上的元素如何排列） flex-start 元素沿着辅轴起边排列 flex-end 元素沿着辅轴终边排列 center 元素居中排列 space-around 空白分布到元素两侧 space-between 空白均匀分布到元素间 space-evenly 空白分布到元素的单侧 弹性居中利用弹性盒对元素进行水平垂直双方向居中 12justify-content: center;align-items: center; 弹性元素的属性伸展系数flex-grow 指定弹性元素的伸展系数，默认值为 0 当父元素有多余空间的时，子元素如何伸展 父元素的剩余空间，会按照比例进行分配 1234567891011121314li:nth-child(1) { background-color: #bfa; flex-grow: 1;}li:nth-child(2) { background-color: red; flex-grow: 2;}li:nth-child(3) { background-color: green; flex-grow: 3;} 缩减系数flex-shrink 指定弹性元素的收缩系数，默认值为 1 当父元素中的空间不足以容纳所有的子元素时，如何对子元素进行收缩 缩减系数的计算方式比较复杂，缩减多少是根据 缩减系数 和 元素大小 来计算 1234567891011121314li:nth-child(1) { background-color: #bfa; flex-shrink: 1;}li:nth-child(2) { background-color: red; flex-shrink: 2;}li:nth-child(3) { background-color: green; flex-shrink: 3;} 基础长度flex-basis 指定的是元素在主轴上的基础长度 如果主轴是横向的，则该值指定的就是元素的宽度 如果主轴是纵向的，则该值指定的就是元素的高度 默认值是auto，表示参考元素自身的高度或宽度 如果传递了一个具体的数值，则以该值为准 1234li:nth-child(1) { background-color: #bfa; flex-basis: 200px;} 简写属性 1flex`可以设置弹性元素所有的三个样式 `flex: 增长 缩减 基础 initial：flex: 0 1 auto auto：flex: 1 1 auto none：flex: 0 0 auto 弹性元素没有弹性 排列顺序order 决定弹性元素的排列顺序 1234567891011121314li:nth-child(1) { background-color: #bfa; order: 2;}li:nth-child(2) { background-color: red; order: 3;}li:nth-child(3) { background-color: green; order: 1;} 覆盖辅轴12345align-self` 用来覆盖当前弹性元素上的`align-itemsli:nth-child(1) { background-color: #bfa; align-self: flex-end;} 练习（手机淘宝）123456789101112131415161718192021222324252627&lt;style&gt; .nav{ width: 100%; } .nav .nav-inner{ margin-top: 40px; /* 变成弹性盒子 */ display: flex; /* 为保持两边空白使用空白环绕 */ justify-content: space-around; } .nav .item{ width: 19%; text-align: center; } img{ /* 保持图片大小防止页面变动时候影响布局 */ width: 100%; } .item a{ text-decoration: none; color: #333; font-size: 16px; }&lt;/style&gt; 效果： 练习（移动端网页）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247* { margin: 0; padding: 0;}.w,.top-bar,.banner,.menu,.course-list { width: 17.325rem; margin: 0 auto;}html { font-size: 5.33333333vw; background-color: #eff0f4;}.top-bar { display: flex; height: 4.375rem; justify-content: space-around; align-items: center;}.top-bar a { color: #24253d;}a { text-decoration: none; font-size: 36px;}a i { color: #999; font-size: 16px;}.banner img { width: 100%;}.menu { height: 8.225rem; display: flex; flex-flow: row wrap; justify-content: space-between;}.menu a { width: 8.175rem; height: 2.6rem; border-radius: 2.5em; text-align: center;}.menu a i { color: white; line-height: 2.6rem; vertical-align: top;}.menu .course { background-color: #fe7b52;}.menu .star { background-color: #d589ff;}.menu .sub { background-color: #ff4f71;}.menu .download { background-color: #0baeff;}.item-list { display: flex; flex-flow: row; justify-content: space-around;}.course-list { height: 9.85rem; display: flex; flex-flow: column; justify-content: space-between; margin-bottom: 1.15rem;}.course-list .title { display: flex; justify-content: space-between; align-items: center;}.course-list h2 { font-size: 0.825rem; color: #242538; border-left: 8px solid #3a84ff; padding-left: 8px;}.course-list a { font-size: 0.7rem; color: #656565;}.item { box-sizing: border-box; width: 8rem; height: 8.1rem; padding: 0 0.55rem; background-color: #fff; box-shadow: 0 0 10px #000000; border-radius: 5px; display: flex; flex-flow: column; justify-content: space-evenly;}.item img { width: 100%;}.item .course-title { font-size: 0.8rem; color: #24253d;}.item .user-info { display: flex; align-items: center;}.item .avatar { width: 1.05rem; height: 1.05rem;}.item .nickname { font-size: 0.6rem; color: #aba59f; margin-left: 4px;}&lt;body&gt; &lt;header class=&quot;top-bar&quot;&gt; &lt;div class=&quot;menu-btn&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-stream&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;h1 class=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot;&gt; 爱学习 &lt;/a&gt; &lt;/h1&gt; &lt;div class=&quot;search-btn&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/header&gt; &lt;div class=&quot;banner&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./img/17/banner.png&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;nav class=&quot;menu&quot;&gt; &lt;a class=&quot;course&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-book&quot;&gt; 我的课程&lt;/i&gt; &lt;/a&gt; &lt;a class=&quot;star&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-cut&quot;&gt; 明星讲师&lt;/i&gt; &lt;/a&gt; &lt;a class=&quot;sub&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-envelope&quot;&gt; 我的订阅&lt;/i&gt; &lt;/a&gt; &lt;a class=&quot;download&quot; href=&quot;#&quot;&gt; &lt;i class=&quot;fas fa-globe&quot;&gt; 我的下载&lt;/i&gt; &lt;/a&gt; &lt;/nav&gt; &lt;div class=&quot;course-list&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;h2&gt;最新课程&lt;/h2&gt; &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;更多&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;course-list&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;h2&gt;最新课程&lt;/h2&gt; &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;更多&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;img src=&quot;./img/17/cover.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3 class=&quot;course-title&quot;&gt; 摄影课程 &lt;/h3&gt; &lt;div class=&quot;user-info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;./img/17/avatar.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;nickname&quot;&gt; 令狐冲 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","link":"/2024/03/15/%E5%BC%B9%E6%80%A7%E7%9B%92/"},{"title":"数学","text":"math 高等数学预备知识函数概念和特性 函数 反函数（xy对调关系） 单调函数必有反函数（有反函数的函数不一定是单调函数） 反函数和原函数关于y=x对称 复合函数 函数四种特性和重要结论 有界性 单调性 奇偶性 周期性 若f是可导偶函数，其导数为奇函数 若f是可导奇函数，其导数为偶函数 若f是可导周期为T的周期函数，其导数为同周期的周期函数 连续的基函数一切原函数都是偶函数 连续的偶函数的原函数中只有一个原函数是奇数函数 若f以T为周期，且其在0到T上的定积分为0，则f的一切原函数也是以T为周期 若f在ab内可导且导数有界，则f在ab内有界 函数图像直角坐标下图像 常见图像：常数函数，幂函数（x^n），指数函数，对数函数，三角函数（正弦余弦正切），反三角 取整函数：x−1&lt;[x]≤x 图像变换 左加右减，上加下减 对称变化 伸缩变换，变大k倍，图像变1/k 极坐标图像心形线 玫瑰线 阿基米德螺线 使用直角系观点画极坐标参数方程摆线 心形线 常用基础知识数列等差数列 通项 通项和 等比数列 通项 通项和 常见数列前n项和 三角函数三角函数基本关系诱导公式（奇变偶不变符号看象限：把a看成锐角，变化后落在变化前函数的象限的奇偶） 特殊函数值重要公式倍角公式 半角公式 和差公式 积化和差 和差化积 指数运算相乘指数相加 次方指数相乘 对数运算积的对数 = 对数的和 一元二次方程基础 因式分解 ⭐常用不等式 数列极限数列极限定义 数列收敛和子数列的关系 收敛数列的性质 唯一性 有界性 保号性 夹逼准则单调有界函数极限和连续性函数极限邻域函数极限的定义 函数极限性质 唯一性 局部有界性 局部保号性 极限运算规则夹逼准则洛必达法则⭐泰勒公式 展开原则： 上下同阶 AB分别展开到他们稀疏不相等的x的最低次幂为止 海涅定理（归结原则）？ 无穷小比阶无穷小的运算： 有限个无穷小的和是无穷小 有界函数和无穷小的乘积还是无穷小 有限个无穷小的乘积还是无穷小 无穷小的运算 常用等价无穷小： 连续和间断间断点的定义和分类 可去间断点 跳越间断点 无穷间断点 振荡间断点 题型七种未定式 化简： 提出极限不为0的因式 等价无穷小替换 恒等变形 判断类型 选择方法 已知一极限求另一极限已知极限反求参数一元函数微分学的概念和计算概念 导数的概念（函数变化率） 可导条件（左右可导，导数相等） 可导必定连续，连续不一定可导 微分概念（化曲为直）可微判别 导数微分计算四则运算 和差的导数 积的导数 商的导数 分段函数的导数 分段点出用定义求导 非分段点处用公式求导 复合函数的导数和微分形式不变性 反函数的导数 参数方程的导数 隐函数求导法对数求导法对于多项相称相除开方乘方的式子，先取对数再求导 幂指函数求导法化为指数求导 高阶导数求导 归纳法 用高阶求导公式 泰勒公式 变限积分求导⭐基本求导公式 一元函数微分学的几何应用极值最值概念 极值定义d 最值定义 极值点不一定是最值点，最值点不一定是极值点 单调性和极值的判断 单调性判断（导数） 一阶可导点是极值点的必要条件（驻点） 判断极值的第一充分条件（一阶导数判断） 判断极值的第二充分条件（二阶导数判断） 判断极值的第三充分条件（偶数阶导数判断） 凹凸性和拐点的概念 凹凸性定义（直线中点大于曲线） 拐点定义（凹凸转换） 判断凹凸性（二阶导） 二阶导数是拐点的必要条件（二阶导） 判断拐点的第一充分条件（二阶导异号） 判断拐点的第二充分条件（二阶导数判断） 判断拐点的第三充分条件（奇数阶导数判断） 渐近线 铅锤渐近线 水平渐近线 斜渐近线 最值或者取值范围 求闭区间[a,b]上连续函数f的最大值和最小值 求开区间(a,b)上连续函数f的最值和取值范围 做函数图形曲率半径 🚗中值定理构造函数 涉及函数的中值定理 有界和最值定理（直接就是求函数的最大值和最小值） 介值定理（介于函数两个之间的函数值，函数的连续性） 平均值定理（多个自变量的介值定理） 零点定理（两个函数值异号得零） 涉及导数的中值定理 费马定理（可导取极值的驻点）！费马定理的证明 罗尔定理（三个条件，1闭区间上连续 2开区间上可导 3端点函数值相等 得 端点间一值导数为0） 构造函数 拉格朗日中值定理（闭区间连续，开区间可导） 柯西中值定理（两个函数之间的定理） 泰勒公式 带拉格朗日余项的泰勒公式 带佩亚诺余项的泰勒公式 麦克劳林公式 积分中值定理（拉格朗日的变种） 新加 导数介值定理 🚗零点问题和微分不等式零点问题 零点定理（用于证明根的存在性） 单调性（用于证明根的唯一性） 罗尔原话（n阶方程至多有k个根，则f=0至多有k+n的根） 实系数奇次方程至少有一个实根 微分不等式 用函数性态（单调性，凹凸性，最值） 用常数变量化证明不等式 用中值定理（主要是拉格朗日和泰勒公式） 一元函数积分学的概念和计算不定积分 原函数和不定积分（不定积分没有上下限） 原函数（不定积分存在定理） 连续函数必有原函数 含有第一类间断点和无穷间断点的函数在包含该间断点的区间内没有原函数（含有震荡间断点的函数也不一定有原函数） 定积分 定积分的概念（将不规则图形划分为规则的梯形） 积分区间有限 被积函数有界 定积分存在定理 定积分存在的充分条件 f在闭区间a,b上连续，原函数存在 f在闭区间上单调，原函数存在 f在闭区间上有界，且有有限个间断点（可以从间断点处拆开），原函数存在 定积分存在的必要条件 若定积分存在，其在上下界上有界 定积分的性质 求区间长度 积分中的常数可以提到积分符号之前 积分可加/拆分性 积分的保号性（积分的绝对值小于绝对值的积分） 估值定理（积分的介值定理） 积分中值定理 变限积分 变限积分的定义 变限积分的性质 f在a,b上可积，则f的积分在a,b上连续（积分区域的增加是连续的） f在a,b上连续，则f的积分在a,b上可导（积分区域的增加是平滑的） 变限积分的求导公式 反常积分 反常积分的概念（1 积分区间无线，2 被积函数无界） 被积函数越小，反常函数通常越容易收敛 被积区间无线的反常函数收敛，其被积函数不一定收敛于0，可能是被积函数的无穷小程度超过了高的无穷大程度 无穷区间上反常函数的概念和敛散性 上积分区间无限 下积分区间无限 上下都无限 无界函数的反常积分概念和敛散性 积分后从被积函数的瑕点趋近 题型： 反常积分判敛公式 积分计算不定积分的积分法 基本积分公式 凑微分法（将被积函数中的一部分提取到积分最右） 换元法（当被积函数不容易积分的时候（反对幂函指三）） 三角函数代换（三种平方形式） 恒等变形后做三角变换（先化成三角函数代换方式在代换） 根式代换（根式内无法凑平方的，直接将整个根式代换） 倒代换（被积函数分母的幂次比分子高两次或者以上的时候） 复杂函数直接代换（反对幂函指三） 分部积分法（分部积分的推广公式） 在积分中凑出于前式一样相减消去 有理函数的积分（拆分为若干有理项之和） 定积分的计算 不定积分 凑微分法 换元法 分部积分法 有理函数积分 定积分 区间再现公式 华理士公式 常用含三角函数积分公式 区间化简公式 对称性 分部积分 分段函数 变限积分一元积分学的几何应用定积分表达和计算平面图形的面积 上下两个函数包围的面积 极坐标表达式包围的成的扇形面积（理解公式） 用定积分表达和计算旋转体的体积 曲边梯形绕x轴旋转一周所得到的旋转体的体积 曲边梯形绕y轴旋转一周所得到的旋转体的体积 平面曲线弧长 旋转曲面的表面积 平面曲边提醒的坐标公式 一元积分的物理应用总路程变力沿直线做功提取物体做功 静水压力 细杆质心 🚗积分不等式积分不等式 中值定理 夹逼准则 积分法 积分不等式 函数单调性 拉格朗日中值定理 泰勒公式 积分法 多元微分法基本概念 平面点集的基本概念 内点 外点 边界点 极限（函数从任意方向趋近，目前只用来证明不可导） 连续 偏导数（偏导数的定义） 可微（可微的公式） 偏导数的连续性（在瑕点处定义法求，在非瑕点处公式求） 多元函数求导规则 链式求导规则 隐函数存在定理（一元函数和二元函数） 题型 复合函数求偏导问题 隐函数求偏导（隐函数求导后能确定变量关系问题） 逆问题（由偏导逆求原函数） 多元函数的极最值 概念 无条件极值 二元函数取极值的必要条件（一阶偏导存在且取极值，导数为0） 二元函数取极值的充分条件（对函数求三个偏导，记住公式） 条件极值和拉格朗日乘数法（记住公式） 题型 无条件极值（只给出了变量关系式，没有其他关系） 闭区域边界上的最值（变量关系式，和其他关系式） 闭区域上的最值（边界内为无条件极值，边界上为条件极值） 二重积分概念 几何背景（曲顶柱体的体积） 性质 求区域面积 可积函数必有界 积分的线性性质（积分拆开） 积分的可加性 积分的保号性（积分的绝对值小于绝对值的积分） 二重积分的估值定理（积分的介值定理） 二重积分的中值定理 对称性 普通对称性（被积函数值在对称区间抵消） 轮换对称性（积分值和用什么字母表示无关，时常互换后前后相加） 计算 直角坐标系下的计算法 上下型（从上往下画直线，先交写上限，后交写下限） 左右型（从左往右画直线，先交写上限，后交写下限） 极坐标下的计算（在划定范围的时候可以直接将xy转换为rcos，rsin） 极点在区域之外 极点在区域边界上 极点在区域内部 极坐标系和直角坐标系的选择（满足以下使用极坐标） 是否为f(x^2+y^2)f(y/x)等形式 看积分区域是否为圆或者圆的一部分 极直互化 积分次序（当先求积分中存在不可积分时候，画图交换积分次序） 用二重积分处理一元积分的问题（累次积分和乘积：利用积分符号不变性） 常微分方程微分方程的概念 微分方程（导数和自变量关系方程） 常微分方程（位置函数是一元函数） 微分方程的阶（方程中所含导数阶数） 微分方程的解（带入方程是方程成立的函数） 微分方程的通解（独立常数的个数等于微分方程的阶数） 初始条件和特解（确定常数的通解） 一阶微分方程的求解 可分离变量型（xy的微分可以直接移动到等式两边） 可化为变量可分离型 dy/dx=f(ax+by+c) 齐次微分方程（可化为y/x） 一阶线性微分方程（y`+py=q）有通解公式，记住推导过程 伯努利方程 二阶可降阶微分方程的求解（y的二阶导，一阶导，y，x） 缺少y（替换一阶导，二阶导） 缺少x 一阶导替换，二阶导数替换为含p导数（变形为一阶线性微分方程） 通过通解公式求解得到一阶导 再对一阶导积分 高阶线性微分方程的求解 概念 二阶变系数线性微分方程，非齐次方程 二阶常系数微分方程 解的结构（二阶） 齐次方程的两个解线性组合为齐次方程的通解 非齐次方程的特解和齐次方程的通解组合为非齐次方程的通解 二阶常系数齐次线性微分方程的通解（记住公式） 二阶常系数非齐次线性微分方程的特解 n阶常系数齐次线性微分方程的解 其他技巧 把y的微分方程化为x的微分方程 变换方程把微分变量化为复合函数 特解中指数系数和特征方程的关系","link":"/2023/01/17/%E6%95%B0%E5%AD%A6/"},{"title":"史纲","text":"政治 通读 背景 大事件考点 土地法 会议 著作","link":"/2023/10/11/%E6%94%BF%E6%B2%BB%E5%8F%B2%E7%BA%B2/"},{"title":"马原","text":"政治 哲学 物质观意识观 物质观 物质：物质是标志客观实在的哲学范畴，物质的唯一特性是客观实在性，它存在于人的意识外，为人的意识所反映 抽象维度：物质无非是各种物的总和，而这个概念就是从这一总和中抽象出来的-归纳了各种具体物质形态的共性 客观实在维度：从万千具体事物形态抽象出来的共性就是客观实在性，是物质的唯一特性（运动是物质的根本属性）、 物质和运动 运动是物质的存在方式和根本属性 物质是一切运动变化和发展过程的主题和承担者 物质运动互相不可以分隔-无运动的物质：形而上学，没有物质的运动：唯心主义 运动和静止 静止是特殊的运动，包括空间位置和根本性质 运动是无条件的绝对的，而静止是有条件的，相对的 静止是运动的衡量尺度，运动和静止相互依赖渗透和包含 物质运动和时空 时间特点：一维性 空间特点：三维性 时空特点： 时间空间是物质运动的存在形式，物质运动与时空的不可分割证明了时间空间的客观性。 具体物质形态的时空是有限的，整个物质世界的时空是无限的 物质运动的时空的客观实在性是绝对的，物质运动的时空的具体特性是相对的（一方面，时间和空间的具体特性随着物质形态的不同而不同；另一方面，时间和空间具体特性随物质运动速度的变化而变化-相对论。）。 世界的物质统一性 物质是世界的本原，世界的本原只有这一个 世界的统一性在于它的物质性 物质世界的统一性是多样性的统一，不是单一的，无差别的统一 世界的物质统一性体现在人类社会统一与物质： 人类社会是物质世界的组成部分 人们谋取物质资料的时间活动虽然有意识指导，但任然是以物质力量改造物质力量的活动，即物质性的活动 物质资料的生产方式是人类社会存在和反战的基础，体系那人类社会的物质性 意识观意识的本质：是客观世界的主管印象，内容上是客观的，形式上是主观的，是客观内容和主管现实的统一。意识是特殊的物质，人脑的机能和属性，意识是物质的产物，但又不是物质本身。 意识产生的因素： 劳动是决定性因素 语言是重要因素也是意识的物质外壳 意识的能动作用 意识活动具有目的性和计划性 意识活动具有创造性 意识具有指导时间改造客观世界的作用 意识具有调控人的行为和生理活动的作用 意识是人类所独有的，不等于物质本身 物质和意识的作用 物质决定意识，意识对物质具有反作用-能动作用，这种作用可以是超前的，滞后的，同步的？ 意识和人工智能 人工智能是对人脑组织结构和思维运行机制的模仿 不能超过，替代人类智能： 人类意识是知情意的统一体，AI只是对人类的理性智能的模拟，不具备情感信念意志等人类意识形式 社会性是人的意识所固有的本质属性 人类的自然语言是思维的物质外壳和意识的现实形式，AI难以理解自然语言的真实含义 发挥主观能动性和尊重客观规律相统一 尊重客观规律是发挥主观能动性的前提 实践是客观规律性和主管能动性统一的基础，是发挥人的主观能动性的基本途径 只有充分发挥主观能动性，才能正确认识和利用客观规律 人于自然关系 唯物辩证法 事物得联系和发展 联系的四个特点（多条扑克） 客观性：事物的联系是事物本省所固有的，不是主观臆想 普遍性： 任何事物内部的不同部分和要素相互联系 任何事物不是独立存在 整个世界是互相联系的整体 事物的普遍联系是通过中介来实现的，通过中间性的联系和过度环节实现的 多样性： 条件性： 条件对事物发展和人的活动具有支持或者制约作用 条件是可以改变的，人们通过努力可以创造出事物发展所需要的条件 改变和创造条件不是任意的，必须尊重事物的发展的客观规律 联系发展的基本环节 原因和结果：解释事物引起和被引起的关系 的区分即使确定又是不确定的 相互作用互为因果 原因结果相互渗透，结果在原因之中，原因表现在结果之中 复杂多样 现象本质：解释事物的内在联系和外在表现 现象：是事物的外部联系和表面特征，人们可以通过感官感知 本质：事物内在联系和根本性质 本质决定现象：现象表现本质，本质藏在事物内部，只有通过理性思维才能把握 必然偶然：解释事物产生发展和衰亡的不同趋势 必然： 偶然： 区别：必然产生于事物内部的根本矛盾，稳定一般；偶然产生于非根本矛盾外部条件，不稳定个别的 联系：必然存在偶然之中，通过大量的偶然表现出来，是必然的表现形式和补充，两者一定情况下可以互相转化 现实可能：反映事物的过去现在和将来的关系 现实：当下事物的客观存在，标志事物的当前情况 可能：事物的潜在趋势 现实可能可以相互转化 内容和形式：内部要素和结构及表现方式的关系 内容决定形式，形式反作用于内容 内容和形式相互依赖，不可分割 可能性和不可能性：在现实中是否有依据 现实可能性和抽象可能性：根据是否充分 事物的发展和变化（新事物旧事物） (1)发展的概念： 前进的、上升的运动。 (2)发展的实质：新事物的产生和旧事物的灭亡。 (3)新事物不可战胜的原因： ① 新事物有新的要素、结构和功能，适应已经变化了的环境和条件。 ② 新事物是在旧事物的“母体”中孕育成熟的， 对旧事物进行了辩证否定和扬弃。 ③在社会历史领域内，新事物符合人民群众的利益和要求。 (4)事物发展的过程性：一切事物都有其产生、发展和转化为其他事物的历史，都有它的过去、现在和未来。“世界不是既成事物的集合体，而是过程的集合体”。 三大规律对立统一规律 矛盾同一性与斗争性及其在事物发展中的作用 同一性和斗争性是矛盾的两种基本属性。 同一性：矛盾双方相互依存、相互贯通的性质和趋势。相互依存是指矛盾着的对立面相互依存，互为存在的前提， 并共处于一个统一体中；相互贯通是指矛盾着的对立面相互贯通，在一定条件下可以相互转化。 斗争性： 矛盾着的对立面相互排斥、相互分离的性质和趋势。可以分为对抗性矛盾和非对抗性矛盾两种基本形式。 同一性对于事物发展的作用： 矛盾双方利用对方的发展使自己获得发展。 矛盾双方相互吸取有利于自身的因素而得到发展。 矛盾双方向着对立面转化而得到发展。 斗争性在事物发展中的作用： 促使矛盾双方力量对比发生变化，为对立面的转化、事物的质变创造条件。 是一种矛盾统一体向另一种矛盾统一体过渡的决定力量。 矛盾的同一性和斗争性的关系： 矛盾着的对立面又斗争、又同一，由此推动事物的发展。有条件的、相对的同一和无条件的、绝对的斗争相结合， 构成了事物的矛盾运动，推动着事物的发展。 矛盾的普遍性和特殊性及其相互关系 矛盾的普遍性:矛盾存在于一切事物发展过程的始终,即“矛盾无处不在,矛盾无时不有”。 矛盾的特殊性:具体事物在其运动中的矛盾及每一矛盾的各个方面都有其特点。具体问题具体分析是马克思主义活的灵魂。 矛盾的普遍性和特殊性是辩证统一的:矛盾的共性是无条件的、绝对的,矛盾的个性是有条件的、相对的。任何现实存在的事物的矛盾都是共性和个性的有机统一,**共性寓于个性之中,**没有离开个性的共性,也没有离开共性的个性。 矛盾的不平衡性 矛盾不平衡性原理是指是矛盾特殊性原理的延申。 内部和外部矛盾的关系：内因是事物存在和发展的根据，外因是事物发展变化的条件，外因通过内因起作用 主要矛盾:矛盾体系中处于支配地位、对事物发展起决定作用的矛盾。 次要矛盾:矛盾体系中处于从属地位、对事物发展起次要作用的矛盾。 矛盾的主要方面:一对矛盾中处于支配地位,起着主导作用的一方,事物的性质是由主要矛盾的主要方面所决定的。 矛盾的次要方面:处于被支配一方。 两点论和重点论的统一:看问题既要全面地看,又要看主流、大势、发展趋势。 量变质变规律 质:一事物区别于其他事物的内在规定性。 量:事物的规模、程度、速度等可以用数量关系表示的规定性。 度:保持事物质的稳定性的数量界限,即事物的限度、幅度和范围。度的两端叫关节点或临界点,超出度的范围,此物就转化为他物。 量变与质变: 量变体现了事物发展的渐进性和连续性。 质变体现了事物发展的渐进性和连续性的中断。 量变和质变的辩证关系: 量变是质变的必要准备。 质变是量变的必然结果。 量变和质变是相互渗透的。量变质变规律体现了事物发展的渐进性和飞跃性的统一。 量变必然引起质变 量变过程中的部分质变还是量变，质变过程中量的扩张本质上还是质变 否定之否定规律 肯定因素:维持现存事物存在的因素。 否定因素:促使现存事物灭亡的因素。 辩证否定观: 否定是事物的自我否定,是事物内部矛盾运动的结果。 否定是事物发展的环节,是旧事物向新事物的转变,是从旧质到新质的飞跃。只有经过否定,旧事物才能向新事物转变。 否定是新旧事物联系的环节,新事物孕育产生于旧事物,新旧事物是通过否定环节联系起来的。 辩证否定的实质是“扬弃”,即新事物对旧事物既批判又继承,既克服其消极因素又保留其积极因素。 主客观辩证法 客观辩证法:是客观事物或客观存在的辩证法。 主观辩证法:是指人类认识和思维运动的辩证法。 两者关系:客观辩证法与主观辩证法在本质上是统一的,但在表现形式上却是不同的。主观辩证法是客观辩证法的反映。它们不是决定与被决定的关系,也不是源与流的关系。唯物辩证法既包括客观辩证法也包括主观辩证法,体现了唯物主义、辩证法、认识论的统一。 认识论 实践观 实践的本质：人类能动的改造世界的客观物质性活动 实践的基本特征：客观实在性，自觉能动性和社会历史性 实践的基本结构： 主体客体中介三基本要素 实践主体和客体相互作用关系-实践认识价值关系 实践是最基本关系 两个子系统：物质性工具系统，语言符号系统 实践的基本类型： 物质生产实践 社会政治实践 科学文化实践 实践对认识的决定作用 实践是认识的来源 实践是认识发展的动力 实践是认识的目的 实践是检验真理性的唯一标准 认识观 认识的本质：在实践基础上主体对客体的能动反映 两个对立路线： 物到感觉到思想：唯物主义反映论 思想感觉到物：唯心主义先验论 旧唯物主义和辩证唯物主义： 直观反映论 能动反映论 认识的过程和规律 第一次飞跃：实践到认识 感性认识：感官直接感受到的，认识的初级阶段，直接性，有不深刻的局限性 理性认识：借助抽象思维，关于事物本质，全体内部联系和事物自身规律认识，高级阶段，抽象和间接性特点 感性和理性认识的辩证关系： 感性认识有待发展和深化为理性认识 理性认识依赖于感性认识，感性认识是理性认识的基础 感性认识和理性认识相互渗透和包含 感性认识向理性认识飞跃的条件： 获得丰富的感性材料 对感性材料进行加工，由表及里 第二次飞跃：认识到实践 重要性： 认识世界的目的是改造世界 认识的真理性只有在事件中才能检验和发展 实践：从实际出发，理论和实际相结合，将理论转化为改造社会和自然的物质力量 实践中非理性因素的作用 非理性因素：主体的情感和一直，对于人的然是有激活驱动和控制作用 理性因素：指人的理性只管，理性思维能力 真理观 真理是标志者主观和客观相符合的哲学范围，对客观事物和规律的正确反映 真理的特征 客观性：首要问题，真理的本质属性：内容是客观的标准是客观（真理是认识，主观范畴-内容客观，形式主观） 一元性：真理只有一个，客观性决定了一元性 绝对性（正确的无限性）：真理标志主客观统一，是绝对的，承认客观性就是承认绝对性 相对性（具体认识正确的有限性）：正确认识有限度，不完善，任何真理都是主观对客观事物近似正确即相对正确的反映 真理的绝对性和相对性的辩证统一 相互依存 相互包含：真理的而绝对性寓于真理的相对性之中，真理的相对性包含表现绝对性。无数相对真理的总和构成绝对真理；真理永远处于相对到绝对转化的过程中。 真理和谬误 谬误：是对客观事物及其发展规律的歪曲反映 真理谬误关系：真理谬误在一定范围的对立是绝对的，超出一定范围两者会相互转化。真理总是同谬误相比较而存在，相斗争而发展。 真理和谬误是绝对对立的 [x] 在确定的对象和范围内，真理和谬误的对立是绝对的 实践标准的的确定性和不确定性 实践是检验真理的唯一标准： 是由真理的本性和实践的特点决定的。真理的本性要求主观和客观相符合。实践具有直接现实性的特点，能够把一定的认识、理论变成直接的、实实在在的现实，把主观的东西变为客观的东西，并看其是否符合客观 实践检验标准的确定性与不确定性：实践标准的确定性即绝对性是指实践作为检验真理标准的唯一性。实践标准的确定性或绝对性，由实践标准的客观性和唯一性所决定。实践标准的不确定性即相对性是指一定历史阶段上的具体实践具有局限性，实践检验真理是一个过程，而不是一次完成的。 实践是检验真理的唯一标准，并不排斥逻辑证明的作用。逻辑证明是对实践标准的重要补充，但不是检验真理的标准。逻辑证明中使用的逻辑法则，也是在实践中产生的，必须经过实践的检验才能获得真理性。 真理和价值 价值：体现的是主体和客体之间的一种特定关系， 表现为人与满足其某种需要的客体之间的意义关系。 价值的基本特性：主体性、客观性、多维性和社会历史性。 价值评价及其特点： 其一， 评价以主客体的价值关系为认识对象；其二， 评价结果与评价主体直接相关；其三， 评价结果的正确与否依赖于对客体状况和主体需要的认识。价值评价有科学与非科学之别，评价具有主观性， 但并不是一种主观随意的认识活动，只有正确反映价值关系的评价才是正确的评价。 价值观与核心价值观： 马克思主义价值观以绝大多数人的利益为是非、善恶、美丑的评价标准，归根结底以社会的进步和人类的彻底解放为标准。 真理与价值在实践中的辩证统一： 任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。一方面， 价值尺度必须以真理为前提。另一方面，人类自身需要的内在尺度， 推动着人们不断发现新的真理。基于实践的具体性和历史性，真理尺度与价值尺度的统一也是具体的和历史，真理尺度和价值尺度是辩证统一的 唯物史观 ​ 社会存在和社会意识社会存在社会存在是社会生活的物质方面,主要包括: 物质生产方式一社会历史发展的决定力量,是生产力和生产关系的统一。 地理环境一社会发展的影响因素。自然地理环境是人类社会生存和发展永恒的、必要的条件,是人们生活和生产的自然基础。 人口因素一社会发展的影响因素。坚持人与自然和谐共生。其一,当今世界出现的生态问题,并不单纯是自然系统内平衡关系的严重破坏,而是人与自然关系的严重失衡。其二,只有尊重自然规律,才能有效防止在开发利用自然时走弯路 社会意识社会意识是社会生活的精神方面,是社会存在的反映。在社会意识形式,存在社会意识形态和非意识形态的区分: 社会意识形态一道德、政治法律思想、艺术、哲学、宗教等。 非意识形态一自然科学、语言学等 辩证统一 社会存在决定社会意识:社会存在是社会意识内容的客观来源,社会意识是社会物质生活过程及其条件的主观反映;社会意识是人们进行社会物质交往的产物;随着社会存在的发展,社会意识也相应地或早或迟地发生变化和发展。 社会意识依赖于社会存在,又有其相对独立性。其一,社会意识与社会存在发展的不完全同步性和不平衡性。其二,社会意识内部各种形式之间的相互影响及各自具有的历史继承性。其三,社会意识对社会存在的能动的反作用,这是社会意识相对独立性的突出表现。 社会发展的动力历史发展的两大根本动力 第一大根本动力:生产力与生产关系及其矛盾运动。 生产力:是人类社会生活和全部历史的基础,具有客观现实性和社会历史性。 生产力三要素:劳动资料、劳动对象、劳动者。其中,劳动资料中的生产工具,是区分社会经济时代的客观依据。而劳动者是生产力中最活跃的因素,所以,人才资源是第一资源。 科学技术是生产力中的重要因素:科学技术是知识形态的生产力。在现代,科学技术对于生产发展的作用越来越大,日益成为生产发展的决定性因素。 生产关系:人们在物质生产过程中形成的不以人的意志为转移的经济关系。生产关系是社会关系中最基本的关系,政治关系、家庭关系、宗教关系等其他社会关系,都受生产关系的支配和制约。在生产关系中,生产资料所有制(即生产资料归谁所有)是最基本的、决定性的,它构成全部生产关系的基础。它是区分不同生产方式、判定社会经济结构性质的客观依据。 生产力与生产关系辩证统一:生产力决定生产关系,而生产关系又反作用于生产力。 第二大根本动力:经济基础与上层建筑及其矛盾运动。 经济基础:由社会一定发展阶段的生产力所决定的生产关系的总和,是制度化的生产关系。 上层建筑:包括政治上层建筑(国家政权、军队、警察等)和观念上层建筑(即意识形态)。在整个上层建筑中,政治上层建筑居于主导地位,国家政权是它的核心。 经济基础与上层建筑辩证统一:经济基础决定上层建筑,上层建筑反作用于经济基础,二者相互影响、相互作用。 历史发展的其他动力 阶级斗争:社会基本矛盾在阶级社会中的直接表现,是阶级社会发展的直接动力。阶级斗争根源于社会经济关系的冲突。 革命:阶级斗争的最高形式,是社会形态的质变。革命的根本问题是国家政权问题。 改革:是在同一社会形态内,实现该社会形态的自我发展和自我完善。改革是解决社会主义社会基本矛盾的根本手段。 科学技术:科技革命是推动经济和社会发展的强大杠杆。科技革命会引起生产方式、生活方式和思维方式的深刻变革。但注意,科学技术像一把双刃剑,既能通过促进经济社会发展造福人类,同时也可能会带来一些消极后果,有时会“表现为异己的、敌对的和统治的权力”。因此要正确认识和运用科学技术。 社会形态的更替 社会形态：社会形态包括社会的经济形态、政治形态和意识形态,是三者历史的、具体的统一。 社会形态更替的统一性和多样性 统一性:社会形态按总体历史进程(五大社会形态)依次更替。 多样性:不同的民族可以超越一种或几种社会形态而跳跃式地向前发展。 社会形态更替的必然性和人们的历史选择性 必然性:社会形态依次更替的过程和规律是客观的,是社会基本矛盾运动的结果。 人们的历史选择性:第一,社会发展的客观必然性造成了一定历史阶段社会发展的基本趋势,为人们的历史选择提供了基础、范围和可能性空间。第二,社会形态更替的过程也是一个主观能动性与客观规律性相统一的过程。第三,人们的历史选择性归根结底是人民群众的选择性。 社会形态更替的前进性与曲折性革 前进性:五种社会形态依次演进的基本趋势,其历史过程是一个“扬弃”的过程。 曲折性:社会前进过程中所出现的反复、停滞和倒退现象。但历史车轮前进的总趋势是不可改变的,它所呈现的曲折,必将以社会的巨大进步来补偿。 人类普遍交往与世界历史的形成和发展 交往是人类实践活动的重要组成部分,对社会生活有着重要的影响。第一,促进生产力的发展。第二,促进社会关系的进步。第三,促进文化的发展与传播。 唯物史观视域中的“世界历史”是指各民族、国家通过普遍交往,打破孤立隔绝的状态,进入相互依存、相互联系的世界整体化的历史。生产方式的发展变革是世界历史形成和发展的基础。普遍交往是世界历史的基本特征。“人类命运共同体”的提出,是我们党站在世界历史的高度思考人类的未来与前途取得的成果。 人的观点唯物史观考察历史创造者的原则 立足于现实的人及其本质来把握历史的创造者。 现实的人:基于自身需要和社会需要而从事一定实践活动的、处于一定社会关系中的、具有能动性的人。 人的本质:人的本质是社会关系的总和。 立足于整体的社会历史过程来探究谁是历史的创造者。 从社会历史发展的必然性入手来考察和说 从人与历史关系的不同层次来考察谁是历史的创造者。坚持“人们自己创造自己的历史”的观点。与唯心史观划分了界限。 人民群众 人民群众是一个历史范畴 人民群众(质):一切对社会历史发展起推动作用的人。 人民群众(量):社会人口中的绝大多数。 最稳定的主体部分:始终是从事物质资料生产的劳动群众及其知分子。(特定时期可以包含剥削阶级) 人民群众创造历史 人民群众是社会物质财富的创造者。 人民群众是社会精神财富的创造者。 人民群众是社会变革的决定力量。 人民群众是历史的创造者,人民群众的总体意愿和行动代表了历史发展的方向,人民群众的社会实践最终决定历史发展的结局。但是,人民群众创造历史的活动受到一定社会历史条件的制约。经济条件对于人民群众创造历史的活动有着首要的、决定性的影响。一定历史阶段所达到的生产力水平是人民群众创造历史的物质基础和前提。精神文化条件也是制约人民群众创造历史活动的重要因素。 个人在社会历史中的作用 历史人物:一定历史事件的主要倡导者、组织领导者或思想理论、科学文化的重要代表人物。历史人物对历史发展有着深刻影响,甚至有时能够决定个别历史事件的结局,从而导致历史发生这样或那样的重大变化。从其发挥作用的性质来看,历史人物有些起推动历史前进的进步作用,有些起阻碍历史前进的反动作用 杰出人物:是历史人物中对推动社会历史发展作出重要贡献或起重要作用的人。新的历史任务往往是由杰出人物首先发现或提出来的。先进阶级的政治代表人物,特别是无产阶级的领袖人物所提出的思想能够成为社会变革的先导。杰出人物会因其智慧、性格因素对社会进程产生影响,但这些作用仅仅是历史进程中的偶然现象。 普通个人:属于人民群众范畴,对社会发展有或大或小的贡献,其总和构成了人民群众创造历史的活动。 群众、阶级、政党、领袖的关系正确认识和处理群众、阶级、政党、领袖的关系。首先,群众是划分为阶级的。其次,阶级通常是由政党领导的。最后,政党是由领袖来主持的。群众、阶级、政党、领袖环环相扣、相互依存,构成一个有机整体,任何时候都不应该把它们割裂开来。坚持“两个确立”,做到“两个维护”。 政治经济学 科学社会主义社会主义的发展和规律 科学社会主义的直接思想来源：","link":"/2023/08/24/%E6%94%BF%E6%B2%BB%E9%A9%AC%E5%8E%9F/"},{"title":"数据结构和算法","text":"学习笔记脑图：阿里云盘分享 (aliyundrive.com) 绪论数据结构（三要素） 逻辑结构 存储结构 数据的运算 数据的运算：施加在数据的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。 五个特征 有穷性：执行有穷步后结束，每一步都在有穷时间内完成 确定性：算法必须具备明确定义的运算，每一一步都有确切的定义，不会有二义性 可行性：有效执行，得到确定结果 输出：算法产生的一个或者多个特定关系的量 输入：零个或者多个输入 效率的度量时间复杂度： 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法所花费的时间与其中语句的执行次数成正比例， 空间复杂度： 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少bytes的空间，因为这个也没大大意义，所以空间复杂度算的是变量的个数。例如：一个动态分配开辟的一个动态数组为O(N)，一个变量的空间复杂度O(1)。 线性表线性表的定义：线性表是具有相同数据类型的n个数据元素的有限数列。","link":"/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"title":"包装类和字符串","text":"JS 正则表达式：正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来 正则对象语法：var 变量 = new RegExp(&quot;正则表达式&quot;, &quot;匹配模式&quot;); 123// 这个正则表达式可以来检查一个字符串中是否含有avar reg = new RegExp(&quot;a&quot;);console.log(reg); // /a/ 使用typeof检查正则对象，会返回object 1console.log(typeof reg); // object 正则方法正则表达式的方法：test() 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false 123456var result = reg.test(&quot;abd&quot;);console.log(result); // trueresult = reg.test(&quot;hgf&quot;);console.log(result); // falseresult = reg.test(&quot;Abd&quot;);console.log(result); // false 在构造函数中可以传递一个匹配模式作为第二个参数，可以是 i ignoreCase，忽略大小写 g global，全局匹配模式 123reg = new RegExp(&quot;a&quot;,&quot;i&quot;);result = reg.test(&quot;Abd&quot;);console.log(result); // true 正则语法使用字面量来创建正则表达式，语法：var 变量 = /正则表达式/匹配模式; 使用字面量的方式创建更加简单；使用构造函数创建更加灵活 123reg = /a/i;result = reg.test(&quot;Abd&quot;);console.log(result); // true 使用|表示或者的意思 1234// 创建一个正则表达式，检查一个字符串中是否有a或b或creg = /a|b|c/i;result = reg.test(&quot;Abcd&quot;);console.log(result); // true []里的内容也是或的关系：[abc] == a|b|c 123reg = /[abc]/i;result = reg.test(&quot;bcd&quot;);console.log(result); // true [a-z]任意小写字母 [A-Z]任意大写字母 [A-z]任意字母 [0-9]任意数字 [^ ]除了: 12345reg = /[^a]/; // 除了a以外的字符result = reg.test(&quot;a&quot;);console.log(result); // falseresult = reg.test(&quot;b&quot;);console.log(result); // true 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 n* 匹配任何包含零个或多个 n 的字符串。 n? 匹配任何包含零个或一个 n 的字符串。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,Y} 匹配包含 X 到Y 个 n 的序列的字符串。 n{X,} 匹配包含至少 X 个 n 的序列的字符串。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符 n 的字符串。 ?^n 匹配任何其后没有紧接指定字符 n 的字符串。 元字符以下是将图片中的内容转换为Markdown格式的表格： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单字字符。 \\W 查找非单字字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NUL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数xxx 规定的字符。 \\xdd 查找以十六进制数 dd规定的字符。 \\uxxxx 查找以十六进制数xxxx规定的 Unicode 字符。 和方法的结合1234567891011121314151617181920212223242526272829// split和正则表达式结合var reg = /[0-9]/;var str = '让3我们4荡起5双桨';result = str.split(reg);// 将字符串按照其中数字分组document.write(result);//让,我们,荡起,双桨// search和正则表达式var reg = /[A-z]/;var str = '让3a我e荡起fef双桨';result = str.search(reg);//搜索字符串中字母的位置document.write(result);//2// match和正则表达式var reg = /[A-z]/g;var str = '让3a我e荡起fef双桨';result = str.match(reg);//提取字符串中字母,g使用全局,提取所有的字母document.write(result);//a,e,f,e,f(返回的是数组)// replace和正则表达式var reg = /[A-z]/g;var str = '让3a我e荡起fef双桨';result = str.replace(reg,'@');//使用@替换字符串中字母document.write(result);//让3@我@荡起@@@双桨","link":"/2024/05/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"3-浮动","text":"CSS浮动 浮动浮动简介通过浮动可以使一个元素向其父元素的左侧或右侧移动 使用float属性来设置于元素的浮动 none 默认值，元素不浮动 left 元素向左浮动 right 元素向右浮动 浮动特点 浮动元素会完全脱离文档流，不再占据文档流中的位置 设置浮动以后，元素会向父元素的左侧或右侧移动 浮动元素默认不会从父元素中移出 1234567891011121314151617&lt;style&gt; .box1 { width: 100px; height: 100px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 浮动元素向左或向右移动时，不会超过前边的浮动元素（先来后到的顺序） 1234567891011121314151617181920212223242526&lt;style&gt; .box1 { width: 200px; height: 200px; background-color: orange; float: left; } .box2 { width: 200px; height: 200px; background-color: red; float: left; } .box3 { width: 200px; height: 200px; background-color: yellow; float: left; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 浮动元素不会超过上边的浮动的兄弟元素，最多就是和它一样高 1234567891011121314151617181920212223242526&lt;style&gt; .box1 { width: 300px; height: 300px; background-color: orange; float: left; } .box2 { width: 400px; height: 400px; background-color: red; float: left; } .box3 { width: 300px; height: 300px; background-color: yellow; float: right; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移 12345678910111213141516171819202122232425262728 &lt;style&gt; /* 不浮动 */ .box1 { width: 200px; height: 200px; background-color: orange; }/* 向左浮动 */ .box2 { width: 200px; height: 200px; background-color: aqua; float: left; } /* 不浮动 */ .box3 { width: 300px; height: 300px; background-color: rgb(34, 31, 31); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&lt;/body&gt; 浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以可以利用浮动来设置文字环绕图片的效果 浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，通过浮动可以制作一些水平方向的布局 脱离文档流的特点块元素： 块元素不再独占页面的一行 脱离文档流以后，块元素的宽度和高度默认都被内容撑开 12345678&lt;style&gt; .box1{ background-color: aqua; /* 浮动后 hello从原本占一样 变为hello文本长度 */ float: left; }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;hello&lt;/div&gt; 行内元素: 行内元素脱离文档流以后会，特点和块元素一样 脱离文档流之后的特点很像行内块元素，不过存在一些差异","link":"/2024/03/23/%E6%B5%AE%E5%8A%A8/"},{"title":"测试","text":"软件测试（英语：Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出之间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 测试基础软件是控制计算机硬件的工具 软件产生过程： 软件测试：使用技术手段验证软件是否满足使用需求 软件测试目的：减少软件缺陷，保证软件质量 主流技术 功能测试：测试主要验证程序的功能是否满足需求 自动化测试：使用代码或者工具代替手工，对项目进行测试 接口测试：使用代码或者工具验证程序中的接口是否访问正常 性能测试：模拟多人使用软件，查找服务器缺陷 常见的测试分类按照测试阶段划分： 按照代码可见度划分： 模型质量模型：衡量一个优秀软件的维度 功能： 功能数量 功能能否正确实现 错误处理情况 性能： ​ 兼容性： 易用性： 简介 友好 流畅 美观 可靠性： 安全性： 传输加密 存储加密 可移植性： 数据迁移 可维护性 测试流程 测试用例为测试项目而设计的执行文档 测试用例的作用： 防止漏测 实施测试的标准 用例设计编写格式 用例编号 用例标题 项目/模块 优先级 前置条件 测试步骤 测试数据 预测结果 用例编号：项目_模块_编号 用例标题：预测结果（测试点） 模块：所属项目或者模块 优先级：表示用例的重要程度或者影响力p9——p4（p0最高） 前置条件：要执行此条用例，有哪些前置条件 测试步骤：描述操作步骤 测试数据：操作用的数据，没有的话为空 预测结果：期望得到的结果 联系： 测试设计等价类划分法 解决穷举场景 实例：账号限制为6-10位自然数 步骤 描述 描述 明确要求 限制为6-10位自然数 限制为6-10位自然数 划分有效等价和无效等价 有效8位自然数 无效3位自然数，12位自然数，8位非自然数，空 提取数据编写用例 12345678 123，123456789012 案例 ： 要求： 区号：空号或者是三位数字 前缀码：非0且非1开头的三位数字 后缀码：四位数字 适用场景针对：需要有大量数据测试输入，但是美哦有办法穷举测试的地方 输入框 下拉列表 单选复选框 典型代表：页面的输入框类测试 边界值分析法 解决边界限制问题 边界范围节点 上点：边界上的点（正好等于） 离点：距离上点最近的点（刚好大于，刚好小于） 内点：范围内的点（区间范围内的数据） 有关范围限制，最多7条用例 边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类） 优化后的： 步骤 明确要求 确定有效和无效等价（类型） 确定边界范围值 提取数据编写测试用例 总结 单个输入框，常用的方式：等价类+边界 123在等价类的基础上对有边界范围的测试数据输入的地方（重点关注边界）常见词语描述：大小，尺寸,重量，，最大，最小，至多，至少典型代表：有边界范围的输入框类测试 判定表法 条件依赖关系 定义：是一种以表格形式表达条件逻辑判断的工具 组成： 条件桩：列出问题中的所有条件，列出条件的次序无关紧要 动作桩：列出 问题中可能采取的操作，操作的排列顺序没有约束 条件项：列出条件对应的取值，所有可能情况下的真假值 动作项：列出条件项的，各种取值情况下应该采取的动作结果 案例： 验证：若用户欠费或者关机，则不允许主被叫功能的测试 规则: 判定表中贯穿条件项和动作项的一列就是一条规则 假设有n个条件, 每个条件的取值有两个(0,1),全组合有2的n次方种规则 步骤 明确需求 分析条件桩，动作桩，画判定表 提取数据，编写用例 案例： 使用场景 有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系 判定表一般适用于条件组合数量比较少的情况（比如4个条件以下） 123456提示:多条件之间有依赖关系，使用判定表来进行测试覆盖。判定表一般适合4个以内条件依赖关系如果条件超过4个，就不适合覆盖所有条件，应采用(正交法)来解决 场景法 根据实际的应用场景，来测试业务用例，可以使用场景法 1234561、开始-&gt;验证银行不成功-&gt;结束2、开始-&gt;验证银行卡成功-&gt;密码错误3次-&gt;结束3、开始-&gt;验证银行卡成功-&gt;密码验证成功-&gt;账户余额不足-&gt;结束4、开始-&gt;验证银行卡成功-&gt;密码验证成功&gt;账户余额验证成功-&gt;取款金额不正确-&gt;结束5、开始-&gt;验证银行卡成功-&gt;密码验证成功&gt;账户余额验证成功-&gt;取款金额正确-&gt;ATM机余额不足-&gt;结束6、开始-&gt;验证银行卡成功-&gt;密码验证成功-&gt;账户余额验证成功-&gt;取款金额正确-&gt;ATM机余额充足-&gt;取款成功-&gt;结束 错误推荐法 当项目用例执行完毕，且BUG修复完成，离上线还有一段时间，在那段时间中可使用错误推荐法复测主要业务或者未覆盖的功能 缺陷管理用例执行 说明：执行结果与用例的的期望结果不一致，为缺陷 缺陷介绍✔定义软件在使用过程中存在的任何问题都叫软件的缺陷，简称bug ✔判定标准 软件未实现需 求(规格)说明书中明确要求的功能-少功能 软件 出现了需求(规格)说明书中指明不应该出现的错误-功能错误 软件实现的功 能超出需求(规格)说明书指明的范围多功能 软件未实现需 求(规格)说明书中虽未明确指明但应该实现的要求-隐性功能错误 软件难以理解， 不易使用，运行缓慢,用户体验不好-不易使用 缺陷核心内容 缺陷提交要素 缺陷类型 用例 ✔缺陷编写缺陷报告实例： 缺陷的跟踪流程： 编写 验证 关闭 提交缺陷的注意事项： 可重现：缺陷可以复现、 唯一性：一个缺陷上报一个问题 规范性：符合公司或者项目要求 ✔缺陷管理工具禅道 地址：https://demo.zentao.net/ 流程图 特点 使用流程： 禅道管理缺陷登录软件 创建缺陷： 验证和关闭缺陷： 缺陷标题分析描述测试数据+实际结果（预测结果） 输入不正确的取款金额 结果取款成功（预期：取款失败，提示：不是正确金额） web常用标签HTML:https://smashdog1.gitee.io/2022/03/25/html/ CSS:css进阶 - Hexo (gitee.io) JavaScript:JavaScript - Hexo (gitee.io) 项目实战项目介绍 项目背景 传智作为一个IT教育机构，拥有子级开发实际运营的产品 将开发和运营的技术作为授课的内容，对于学院而言学到的都是一手的真是案例和实际经验 产品定位 一款汇集科技咨询，技术文章和回答交流的用户移动终端产品 用户通过该产品，可以获取最新的科技资讯，发表或者学习技术文章，讨论交流技术问题 项目目标 研发并上线运营头条产品 从实际的产品技术中孵化Python人工智能，Python数据分析，PythonWeb，测试，运维等课程案例 产品功能架构 用户端：APP，用户可以查询资料，文章内容，进行回答讨论交流 自媒体运营平台：PC网站，自媒体用户可以管理文章，评论，查看分析粉丝数据 系统后台：PC网，内部运营管理系统 ⭐发项目功能测试 测试对象 完成黑马头条web登录功能测试 完成黑马头条web发布文章功能测试 登录需求-1 输入正确的中国手机号(11位) 当文本框失去焦点的时候验证， 红色为失败，绿色为成功 点击发送验证码 如果手机号文本框状态为绿色， 弹出“点击按钮进行验证”; 如果手机号文本框为红色， 提示手机号不正确 点击按钮进行验证 拖拽图形 到指定位置,按钮消失; 拖拽图形未到指定位置， 晃动提醒，滑块回到初始位置; 超过5次, 提示尝试过多,请点击重试; 登录需求-2 输入验证码 正确的验证码, 并“勾选我已阅读并同意”,点击登录，进入系统; 错误的验证码， 并“勾选我已阅读并同意’”,点击登录,提示验证码错误; 正确的验证码, 未“勾选我已阅读并同意”,点击登录,提示请勾选; 点击登录 手机号、 验证码都为绿色，勾选“我已阅读并同意”，登录成功 开始测试 分析需求跳转到分析 提取测试点 设计用例 登录 滑块 非功能 用例评审执行用例缺陷管理测试报告","link":"/2023/01/26/%E6%B5%8B%E8%AF%95/"},{"title":"滚轮和键盘事件","text":"JS滚轮和键盘事件 滚轮事件onmousewheel、DOMMouseScrollonmousewheel：鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性 DOMMouseScroll：在火狐中使用DOMMouseScroll来绑定滚动事件，注意该事件需要通过addEventListener()函数来绑定 event.wheelDelta、event.detailevent.wheelDelta：可以获取鼠标滚轮滚动的方向：向上滚（120），向下滚（-120），这个值我们不看大小，只看正负 event.detail：wheelDelta这个属性火狐中不支持，在火狐中使用event.detail来获取滚动的方向：向上滚（-3），向下滚（3） return false、event.preventDefault()当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，这是浏览器的默认行为 如果不希望发生，则可以使用return false来取消默认行为 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false，需要使用event来取消默认行为 但是 IE8 不支持event.preventDefault()这个玩意，如果直接调用会报错 1234567891011121314151617181920212223242526272829303132333435363738394041window.onload = function() { var box1 = document.getElementById(&quot;box1&quot;); box1.onmousewheel = function(event) { event = event || window.event; // alert(event.wheelDelta); // IE/内置：120/-120；Chrome/Edge：150/-150；Firefox：undefined/undefined // alert(event.detail); // IE/内置/Chrome/Edge：0/0；Firefox：-3/3; // 当鼠标滚轮向下滚动时，box1变长 // 当鼠标滚轮向上滚动时，box1变短 if (event.wheelDelta &gt; 0 || event.detail &lt; 0) { box1.style.height = box1.clientHeight - 10 + &quot;px&quot;; } else { if (box1.clientHeight - 10 &gt; 0) { box1.style.height = box1.clientHeight + 10 + &quot;px&quot;; } } // 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false，需要使用event来取消默认行为 // 但是IE8不支持event.preventDefault()这个玩意，如果直接调用会报错 event.preventDefault &amp;&amp; event.preventDefault(); // 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动 // 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 return false; }; // 兼容addEventListener bind(box1, &quot;DOMMouseScroll&quot;, box1.onmousewheel);}function bind(obj, eventStr, callback) { if (obj.addEventListener) { obj.addEventListener(eventStr, callback, false); } else { // this是谁由调用方式决定 // callback.call(obj) obj.attachEvent(&quot;on&quot; + eventStr, function(){ // 在匿名函数中调用回调函数 callback.call(obj); }); }} 效果 键盘事件onkeydown按键被按下 如果一直按着某个按键不松手，则事件会一直触发 连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生 onkeyup按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document 键盘事件属性 可以通过keyCode来获取按键的编码，通过它可以判断哪个按键被按下 除了keyCode，事件对象中还提供了几个属性altKey、ctrlKey、shiftKey 这个三个用来判断alt、ctrl和shift是否被按下，如果按下则返回true，否则返回false &lt;练习：键盘移动div&gt; 12345678910111213141516171819202122232425262728293031// 定义速度var speed = 10;var box1 = document.getElementById(&quot;box1&quot;);// 绑定键盘响应事件document.onkeydown = function(event) { event = event || window.event; // 按ctrl加速 speed = event.ctrlKey ? 30 : 10; // console.log(event.keyCode); // 左：37；上：38；右：39；下：40 switch (event.keyCode) { // 左移 case 37: box1.style.left = box1.offsetLeft - speed + &quot;px&quot;; break; // 上移 case 38: box1.style.top = box1.offsetTop - speed + &quot;px&quot;; break; // 右移 case 39: box1.style.left = box1.offsetLeft + speed + &quot;px&quot;; break; // 下移 case 40: box1.style.top = box1.offsetTop + speed + &quot;px&quot;; break; default: break; } return false;} 效果","link":"/2024/05/21/%E6%BB%9A%E8%BD%AE%E5%92%8C%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"},{"title":"线性代数","text":"math 行列式行列式的基本概念和性质基本概念 逆序和逆序数 余子式和代数余子式 特殊高阶行列式 对角 上三角 下三角 逆三角 范德蒙行列式 分块行列式 行列式计算性质 行列式降阶 行列式等于行列式某行元素与对应的代数余子式之极的和 行列式一样的元素和另一行的代数余子式之积的和为0 行列式化简 行列式和其转置行列式相等 对调两行行列式行列式改变符号 某行有公因子可以提到行列式外 可以拆分 行列式某行倍数加到另一行，行列式不变 行列式计算矩阵矩阵的基本概念和特殊矩阵 矩阵就是一个列表 同型矩阵（m，n相对）矩阵相等（所有元素都一样） 伴随矩阵 特殊矩阵 矩阵的运算和性质 αβ的计算 初等变换求逆矩阵 矩阵转置逆矩阵 ⭐矩阵的秩 r（ab） = r（a）b是可逆的矩阵 矩阵等价AB 两个同型矩阵，A经过有限次初等变换后变换为B，称AB等价 定理1 等价的充分必要条件条件是秩相等 定理2 同型的充分必要条件是存在可逆矩阵PQ，PAQ= B 题型 矩阵运算和矩阵行列式运算（注意向量计算） 矩阵的幂矩阵 相似对角化 利用零幂矩阵 将矩阵化成向量形式 分块矩阵 归纳法 初等变化和初等矩阵（初等矩阵的变化就是对矩阵的行列操作） 逆矩阵的计算和证明 判断矩阵可逆的方法 定义 行列式不为0 求逆矩阵 公式 伴随矩阵 初等变换 向量向量概念运算 向量（有大小又有方向的量） 向量的单位化（向量除以向量的模） 向量的内积 向量的运算 三则运算 内积运算 零向量和任何向量都正交 线性相关和线性表示 线性相关（向量组中至少有一个向量可以由其他向量线性表示） 线性表示（向量可由其他向量表示） 等价 线性无关组和秩等价两个同阶向量组的每个向量可以相互线性表示则等价 极大线性无关组向量组中秩的个数个无关向量组成的向量组 秩 矩阵的秩=列（行）向量组的秩 维数相同的向量组ab，a可以由b表示，则a的秩不大于b的秩（a的自由向量要小于b的） 等价的向量组秩相等，反之不对（等价矩阵要求同型） 矩阵和向量的关系 题型向量组的相关性向量的线性表示向量组等价和向量组的秩 求向量组的一个极大线性无关组，并用无关组表示 线性方程组齐次线性方程组线性方程组的解的定理 方程组的解的结构 线性方程组的通解 方程组的解的扩展理论 题型方程组的理论证明 线性方程组的解的结构和性质 齐次线性方程组的解 非齐次线性方程组的通解 线性方程组的理论证明 方程组的公共解和方程组同解 特征向量和特征方程特征值和特征向量基本概念 施密特正交 特征值和特征向量 相似的矩阵 特征值相等 特征向量为p^-1a 任何特征值都对应无数个特折向量，但其线性无关的特征向量不超过其重数 实对称矩阵的重根特征向量可以正交也可以不正交 矩阵对角化 题型 求矩阵的特征值和特征向量 公式法 定义法 关联矩阵 逆矩阵 伴随矩阵 特征值和特征向量的性质 矩阵相似的判断 先判断特征方程是否相等，不相等则相似 进行判断 都可相似对角化，则相似 一个可以相似对角化，不相似 都不可以相似对角化，看重根对应的线性无关特征向量 非实对称矩阵的对角化 实对称矩阵的对角化 矩阵的幂次 特征值法求未知矩阵 已知两特征向量，利用不同特征值特征向量正交，得另一特征向量 特征值特征向量的命题证明 “绝境之下”，如何求解矩阵的特征值？ - 知乎 (zhihu.com) 二次型二次型基本概念和基本型 正定矩阵和正定二次型 题型 二次型概念 二次型的标准型 使用配方法时候如果只有x1x2这种可以使用平方差 含参二次型问题 正定二次型的判别和证明","link":"/2023/09/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"2-盒子模型","text":"CSS盒子模型 盒模型文档流（normalflow）“文档流”指的是页面元素按照它们在HTML文档中的顺序自然排列的方式。 在文档流中，块级元素（如 &lt;div&gt;、&lt;p&gt;、&lt;h1&gt; 等）从上到下垂直堆叠，而行内元素（如 &lt;span&gt;、&lt;a&gt; 等）则在同一行水平排列，直到遇到换行符或空间不足导致换行。 文档流中的布局规则 垂直堆叠：当一个块级元素位于另一个块级元素下方时，它们之间会有一定的垂直间距，这个间距通常是由元素的边距（margin）、内边距（padding）和边框（border）决定的。 水平对齐：行内元素会在同一行内水平排列，当行内元素超出容器宽度时，它们会自动换行。 元素尺寸：在文档流中，元素的尺寸（高度、宽度）可以根据内容自动调整，也可以通过CSS显式设定。 常见的脱离文档流的方法: 浮动（float）：使用 float 属性可以让元素向左或向右浮动，这样它们就不会按照文档流正常堆叠。 绝对定位（position: absolute）：绝对定位的元素可以放置在任意位置，而不受文档流的影响。 相对定位（position: relative）：相对定位的元素仍然在文档流中，但它可以根据偏移量进行移动。 Flexbox（弹性盒子）：Flexbox是一种用于创建灵活、响应式布局的方法，它可以让子元素根据父容器的大小进行伸缩和排列。 Grid（网格布局）：Grid布局是一种二维布局系统，它可以更容易地控制元素的位置和大小。 块元素 块元素会在页面中独占一行 默认宽度是父元素的全部（会把父元素撑满） 默认高度是被内容撑开（子元素） 行内元素 行内元素不会独占页面的一行，只占自身的大小 行内元素在页面中左向右水平排列（书写习惯一致） 如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列 行内元素的默认宽度和高度都是被内容撑开 行内块元素 行内显示： 行内块元素像行内元素一样在同一行内显示，不会独占一行。 多个行内块元素可以在同一行内水平排列，直到行满后自动换行。 可设置尺寸： 行内块元素可以设置宽度（width）和高度（height）等尺寸属性。 这使得行内块元素在布局时更加灵活，因为它们既可以作为行内元素使用，又可以控制其大小和位置。 垂直居中： 行内块元素可以利用 vertical-align 属性来垂直对齐文本基线或上下边缘。 这一点与纯行内元素不同，因为后者只能通过变换行高来间接影响垂直位置。 边距折叠： 当行内块元素之间有垂直方向上的重叠时，它们之间的外边距（margin）会发生折叠现象，即两个相邻的外边距会合并为一个较大的外边距。 盒子模型将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置 每一个盒子都由一下几个部分组成： 内容区（content） 内边距（padding） 边框（border） 外边距（margin） 内容区（content）内容区是盒子模型的中心，它呈现了盒子的主要信息内容，这些内容可以是文本、图片等多种类型 元素中的所有的子元素和文本内容都在内容区中 width和height 设置排列内容区的大小 width 设置内容区的宽度 height 设置内容区的高度 边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部 注意：边框的大小会影响到整个盒子的大小 border-width边框的宽度：默认 3px border-top-width 上边框的宽度 border-right-width 右边框的宽度 border-bottom-width 下边框的宽度 border-left-width 左边框的宽度 border-color 边框的颜色：默认使用 color 的颜色值 border-top-color 上边框的颜色 border-right-color 右边框的颜色 border-bottom-color 下边框的颜色 border-left-color 左边框的颜色 border-style边框的样式：没有默认值，必须指定 border-top-style 上边框的样式 border-right-style 右边框的样式 border-bottom-style 下边框的样式 border-left-style 左边框的样式 不论是border-width 、 border-color 、border-style 还是其衍生出来的属性写法，都可以指定每个方向的边框情况 设定几个值就决定了对应方向的宽度、颜色或样式 四个值：上 右 下 左 三个值：上 左右 下 两个值：上下 左右 一个值：上下左右 其实不管设置几个值，只要记住：其顺序是按顺时针方向设置的，剩下的可以由矩形的对称性推导出来 border：简写属性，通过该属性可以同时设置边框所有的相关样式，并且没有顺序要求 border-top 上边框的宽度、颜色和样式 border-right 右边框的宽度、颜色和样式 border-bottom 下边框的宽度、颜色和样式 border-left 左边框的宽度、颜色和样式 123.box1 { border: 10px red solid;} 内边距(padding）内边距，也叫填充，是内容区和边框之间的空间 padding-top 上内边距 padding-right 右内边距 padding-bottom 下内边距 padding-left 左内边距 padding 内边距的简写属性，可以同时指定四个方向的内边距，规则和边框中属性值设置一样 注意：内边距的设置会影响到盒子的大小，背景颜色会延伸到内边距 外边距（margin）外边距，也叫空白边，位于盒子的最外围，是添加在边框外周围的空间。空白边使盒子之间不会紧凑地连接在一起，是 CSS 布局的一个重要手段 注意：外边距不会影响盒子可见框的大小，但是外边距会影响盒子的位置和占用空间 一共有四个方向的外边距： 1margin-top 上外边距 设置正值，元素自身向下移动 设置负值，元素自身向上移动 1margin-right 右外边距 设置正值，其右边的元素向右移动 设置负值，其右边的元素向左移动 上述说法并不准确，对于块元素，设置margin-right不会产生任何效果 1margin-bottom 下外边距 设置正值，其下边的元素向下移动 设置负值，其下边的元素向上移动 上述说法并不准确，对于块元素，会有垂直方向上的边距重叠问题（后面会细说） 1margin-left 左外边距 设置正值，元素自身向右移动 设置负值，元素自身向左移动 元素在页面中是按照自左向右的顺序排列的，所以默认情况下 如果我们设置的左和上外边距则会移动元素自身 而设置下和右外边距会移动其他元素 水平方向布局元素在其父元素中水平方向的位置由以下几个属性共同决定 margin-left border-left padding-left width padding-right border-right margin-right 一个元素在其父元素中，水平布局必须要满足以下的等式 1margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父元素的宽度 以上等式必须满足，如果相加结果使等式不成立，则称为过渡约束 则等式会自动调整调整的情况： 如果这七个值中没有auto的情况，则浏览器会自动调整margin-right值以使等式满足 100 + 0 + 0 + 200 + 0 + 0 + 0 = 800 ==&gt; 100 + 0 + 0 + 200 + 0 + 0 + 500 = 800 如果这七个值中有auto的情况，则会自动调整auto值以使等式成立 这七个值中有三个值可以设置为auto ：width、margin-left、maring-right 如果某个值为 auto，则会自动调整auto的那个值以使等式成立200 + 0 + 0 + auto + 0 + 0 + 200 = 600 ==&gt; 200 + 0 + 0 + 400 + 0 + 0 + 200 = 800 auto + 0 + 0 + 200 + 0 + 0 + 200 = 600 ==&gt; 400 + 0 + 0 + 200 + 0 + 0 + 200 = 800 200 + 0 + 0 + 200 + 0 + 0 + auto = 600 ==&gt; 200 + 0 + 0 + 200 + 0 + 0 + 400 = 800 如果宽度为auto，则宽度会调整到最大，其他auto的外边距会自动设置为 0 auto + 0 + 0 + auto + 0 + 0 + 200 = 600 ==&gt; 0 + 0 + 0 + 600 + 0 + 0 + 200 = 800 200 + 0 + 0 + auto + 0 + 0 + auto = 600 ==&gt; 200 + 0 + 0 + 600 + 0 + 0 + 0 = 800 auto + 0 + 0 + auto + 0 + 0 + auto = 600 ==&gt; 0 + 0 + 0 + 800 + 0 + 0 + 0 = 800 如果外边距都为auto，则auto的外边距会自动均分以使等式成立 auto + 0 + 0 + 200 + 0 + 0 + auto = 600 ==&gt; 300 + 0 + 0 + 200 + 0 + 0 + 300 = 800 垂直方向布局元素溢出子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出 使用overflow/overflow-x/overflow-y属性来设置父元素如何处理溢出的子元素 可选值：visible/hidden/scroll/auto visible 溢出内容会在父元素外部位置显示，默认值 hidden 溢出内容会被裁剪，不会显示 scroll 生成两个滚动条，通过滚动条来查看完整的内容 auto 根据需要生成滚动条 边距折叠垂直外边距的重叠（折叠）：相邻的垂直方向外边距会发生重叠现象 兄弟元素兄弟元素间的相邻，垂直外边距会取两者之间的较大值（两者都是正值） 特殊情况： 如果相邻的外边距一正一负，则取两者的和 如果相邻的外边距都是负值，则取两者中绝对值较大的 父子元素父子元素间相邻外边距，子元素会传递给父元素（上外边距） 行内元素的盒模型 行内元素不支持设置宽度和高度 123456.s1 { /* 行内元素设置了宽高也没用，不会生效 */ width: 100px; height: 100px; background-color: yellow;} 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局 行内元素可以设置border，垂直方向的border不会影响页面的布局 行内元素可以设置margin，垂直方向的margin不会影响页面的布局 display用来设置元素显示的类型 inline将元素设置为行内元素 block 将元素设置为块元素 inline-block 将元素设置为行内块元素行内块，既可以设置宽度和高度又不会独占一行 table将元素设置为一个表格 none元素不在页面中显示 visibility用来设置元素的显示状态 visible默认值，元素在页面中正常显示 hidden元素在页面中隐藏不显示，但是依然占据页面的位置 123456.s1 { margin: 100px; background-color: yellow; display: block; visibility: hidden;} 盒子大小默认情况下，盒子可见框的大小由内容区、内边距和边框共同决定 box-sizing用来设置盒子尺寸的计算方式（设置 width 和 height 的作用） 12345678.box { width: 200px; height: 200px; background-color: yellow; border: 10px red solid; /* box-sizing: content-box; */ box-sizing: border-box;} 可选值： content-box 默认值，宽度和高度用来设置内容区的大小 border-box 宽度和高度用来设置整个盒子可见框的大小 width和height指的是内容区、内边距和边框的总大小 轮廓outline用来设置元素的轮廓线，用法和border一模一样 轮廓和边框不同点是，轮廓不会影响到可见框的大小 边框 123456.box { width: 200px; height: 200px; background-color: yellow; border: 10px red solid;} 轮廓 123456.box { width: 200px; height: 200px; background-color: yellow; outline: 10px red solid;} 可以很明显看到outline与border的区别 我们一般不会直接这么设置轮廓，而是下面这种场景 123.box:hover { outline: 10px red solid;} 从上面的动态图也可以很清晰地看出，outline属性并没有改变盒子的布局 阴影 box-shadow属性用于在一个元素的框架周围添加阴影效果 你可以设置多个由逗号分隔的效果 一个盒状阴影由相对于元素的 X 和 Y 的偏移量、模糊和扩散半径以及颜色来描述 box-shadow用来设置元素的阴影效果，阴影不会影响页面布局 123456.box { width: 200px; height: 200px; background-color: yellow; box-shadow: 10px 10px orange;} 1box-shadow: 10px 10px 5px orange; 1box-shadow: 10px 10px 5px rgba(0, 0, 0, 0.2); 第一个值-水平偏移量：设置阴影的水平位置 正值向右移动 负值向左移动 第二个值-垂直偏移量：设置阴影的垂直位置 正值向下移动 负值向上移动 第三个值-阴影的模糊半径 第四个值-阴影的颜色 圆角 border-radius属性使一个元素的外边框边缘的角变圆 你可以设置一个半径来做圆角，或者设置两个半径来做椭圆角 border-radius 用来设置圆角，圆角设置的是圆的半径大小 border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 1border-radius: 20px;","link":"/2024/03/23/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"},{"title":"线程和事件机制","text":"JS线程和事件机制 进程和线程 进程： 程序的一次执行,它占有一片独有的内存空间 可以通过windows任务管理器查看进程 线程： 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 进程和线程： 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程:主线程 –&gt;进程启动后自动创建 一个进程中也可以同时运行多个线程:此时这个程序是多线程运行的 多个进程之间的数据是不能直接共享的 –&gt;内存相互独立(隔离) 线程池(thread pool):保存多个线程对象的容器,实现线程对象的反复利用 JS是单线程运行的 , 但使用H5中的 Web Workers可以多线程运行 浏览器是多线程运行的 单进程和多进程的浏览器: 单进程 firefox 旧ie 多进程 chrome 新版ie 浏览器内核 支撑浏览器运行的最核心的程序 主流浏览器内核 Chrome,Safari:[webkit] firefox:[Gecko] IE:[Trident] 360等国产双核浏览器:[Trident+webkit] 内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析(拆解) dom/css模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制 分线程 定时器模块 : 负责定时器的管理 网络请求模块 : 负责服务器请求(常规/Ajax) 事件响应模块 : 负责事件的管理 定时器是定时执行的吗1234567891011121314151617&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;启动定时器&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById('btn').onclick = function () { var start = Date.now() console.log('启动定时器前...') setTimeout(function () { console.log('定时器执行了', Date.now()-start) //定时器并不能保证真正定时执行,一般会延迟一丁点 }, 200) console.log('启动定时器后...') // 做一个长时间的工作 for (var i = 0; i &lt; 1000000000; i++) { //会造成定时器延长很长时间 ... } }&lt;/script&gt;&lt;/body&gt; 定时器不能保证真正定时执行 一般会延迟一点(在可以接受的范围),也可能延迟很久(不能接受) 定时器回调函数是在分线程执行? 在主线程执行的, JS是单线程的 定时器是如何实现的? 事件循环模型 JS是单线程执行的单线程执行的代码 setTimeout()的回调函数是在主线程执行的 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行 1234567891011121314151617181920// 如何证明JS执行是单线程的setTimeout(function () { //4. 在将[timeout 1111]弹窗关闭后,再等一秒 执行此处 console.log('timeout 2222') alert('22222222') }, 2000) setTimeout(function () { //3. 过了一秒后 打印 timeout 1111并弹窗,此处如果不将弹窗关闭,不会继续执行上方222 console.log('timeout 1111') alert('1111111') }, 1000) setTimeout(function () { //2. 然后打印timeout() 00000 console.log('timeout() 00000') }, 0) function fn() { //1. fn() console.log('fn()') } fn()//---------------------- console.log('alert()之前') alert('------') //暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时 console.log('alert()之后') 流程结果: 先打印了[fn()],然后马上就打印了[timeout() 00000] 过了一秒后 打印 timeout 1111并弹窗,此处如果不将弹窗关闭,不会继续执行上方222 在将[timeout 1111]弹窗关闭后,再等一秒 执行此处 问:为何明明写的是2秒,却关闭上一个弹窗再过一秒就执行? 解:并不是关闭后再计算的,而是一起计算的,alert只是暂停了主线程执行 JS代码分类和执行的基本流程代码分类: 初始化代码 回调代码(作为参数传递给另一个函数的函数代码。) js引擎执行代码的基本流程 先执行初始化代码: 包含一些特别的代码 回调函数(异步执行) 设置定时器 绑定事件监听 发送ajax请求 后面在某个时刻才会执行回调代码 js单线程模式的原因JavaScript 是一种单线程的语言，这意味着在任何给定的时间点，JavaScript 只能执行一个任务。这种设计选择主要是出于以下原因： 简单性: JavaScript 最初是为了在浏览器环境中运行而设计的。为了简化实现，JavaScript 采用了单线程模型，这样开发者就不需要担心多线程编程中的复杂问题，比如同步和死锁。 一致性: 单线程模型保证了脚本执行的一致性和可预测性。这使得开发者能够更容易地理解和调试他们的代码。 资源限制: 当JavaScript最初设计时，浏览器环境的资源相对有限。为了避免过多占用系统资源，单线程模型可以确保浏览器性能不受影响。 异步编程: 尽管JavaScript本身是单线程的，但它通过事件循环机制支持非阻塞I/O操作，这使得它能够高效地处理异步任务，如HTTP请求、DOM事件和定时器等。这使得JavaScript能够在不阻塞主线程的情况下处理后台任务。 DOM操作: 浏览器的DOM（文档对象模型）是共享资源，多个线程同时修改DOM可能会导致冲突。单线程模型可以避免这种情况发生。 尽管JavaScript是单线程的，但通过使用事件循环、回调函数、Promise、async/await等机制，它能够有效地处理异步操作。这些技术允许JavaScript在等待长时间运行的操作完成时继续执行其他任务，从而提高了整体的响应性和性能。 事件循环模型概念 javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。 单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。 非阻塞: 而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务(没有挂起直接执行相当于阻塞了主线程的执行)，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。 单线程是必要的: 也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，需要进行各种各样的dom操作。 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。 当然，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web workers技术。这项技术号称可以让javaScript成为一门多线程语言。 然而，使用web workers技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。 可以预见，未来的javascript也会一直是一门单线程的语言。 提到javascript的另一个特点是“非阻塞”，javascript引擎到底是如何实现的这一点呢？ 答案就是——event loop（事件循环）。 浏览器中js引擎事件循环机制执行栈： 当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域、上层作用域的指向、方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈(执行栈是管理这些执行上下文的一种机制。)。 事件队列（Task Queue）: JS引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务,当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。 被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 以上的事件循环过程是一个宏观的表述，实际上因为异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task） Web Workers此处只做简略了解,详见Web Workers H5规范提供了js分线程的实现, 取名为: Web Workers 相关API Worker: 构造函数, 加载分线程执行的js文件 Worker.prototype.onmessage: 用于接收另一个线程的回调函数 Worker.prototype.postMessage: 向另一个线程发送消息 不足 worker内代码不能操作DOM(更新UI) 不能跨域加载JS 不是每个浏览器都支持这个新特性 斐波那契数列12345678910111213141516&lt;body&gt;&lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;&gt;&lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 1 1 2 3 5 8 f(n) = f(n-1) + f(n-2) function fibonacci(n) { return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) //递归调用 } // console.log(fibonacci(7)) var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value var result = fibonacci(number) alert(result) }&lt;/script&gt; 当我运行此行代码,传入计算数值为50左右(有的甚至更低),整个页面就会卡住好久的时间不能操作(计算结束后才会弹窗,但是未弹窗的这段时间用户并不能进行操作) 使用Web Workers主线程: 123456789101112131415161718192021222324&lt;body&gt;&lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;&gt;&lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var input = document.getElementById('number') document.getElementById('btn').onclick = function () { var number = input.value //创建一个Worker对象 var worker = new Worker('worker.js') // 绑定接收消息的监听 worker.onmessage = function (event) { //此处变成回调代码,会在初始化工作完成后才会进行 console.log('主线程接收分线程返回的数据: '+event.data) alert(event.data) } // 向分线程发送消息 worker.postMessage(number) console.log('主线程向分线程发送数据: '+number) } // console.log(this) // window&lt;/script&gt;&lt;/body&gt; 分线程: 12345678910111213141516//worker.jsfunction fibonacci(n) { return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) //递归调用}console.log(this)this.onmessage = function (event) { var number = event.data console.log('分线程接收到主线程发送的数据: '+number) //计算 var result = fibonacci(number) postMessage(result) console.log('分线程向主线程返回数据: '+result) // alert(result) alert是window的方法, 在分线程不能调用 // 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面}","link":"/2024/08/11/%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"},{"title":"网络协议","text":"q前端学习路线: 前端学习路线 (gitee.io) 【干货】前端学习路线分享！写了个网站帮助你学习前端！_哔哩哔哩_bilibili http协议http基本知识HTTP（HyperText Transfer Protocol）超文本传输协议 超文本：文本指图片，视频，压缩包等，超文本指文字，图片，视频等的混合体最关键有超链接，能从一个超文本跳转到另一个超文本。HTML就是最常见的超文本。 HTTP常见状态码： 1xx：提示信息，协议处理的中间状态，实际使用少 2xx：表示服务器成功处理了客户端的请求 3xx：表示客户端的请求资源发生了变动，需要客户端用新的URL从新发送请求获取资源，重定向。 4xx：表示客户端请求的报文有错误，错误码。 5xx：表示客户端请求报文正确，但是服务器处理内部发生了错误，属于服务端的错误码。 http报文 Host：客户端发送请求时，用来指定服务器的域名 Content-Length:服务器返回数据时候,表名回应的数据长度 Connection:常用于客户端要求服务器使用TCP持久连接,一边其他请求复用 Content-Type:用于服务器回应时候,告诉客户端,本次数据是什么格式 Content_Encoding:表示服务器返回的数据使用了什么压缩格式 请求方法: 序号 方法 描述 1 GET 请求指定页面讯息,并返回 2 HEAD 类似get,不过返回的响应中没有具体的内容,用于获取报头 3 POST 向指定资源提交数据进行处理请求(提交表单或者上传文件),数据被包含在请求体中. 4 PUT 从客户端想服务器传送的数据取代指定的文档内容 5 DELETE 请求服务器删除指定的页面 6 CONNECT 7 OPTIONS 允许客户端查看服务器的性能 8 TRACE 回显服务器收到的请求,用于测试或者判断 GET和POST都是安全等幂吗 安全指请求方法会破坏服务器上的资源 幂等指多次执行相等的操作,结果都是相同的 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。","link":"/2023/12/02/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"title":"7-背景 雪碧图与渐变","text":"CSS背景,雪碧图与渐变 背景参数 background-color 设置背景颜色 background-image 设置背景图片 如果背景图片大小小于元素，则背景图片会自动在元素中平铺将元素铺满 如果背景图片大小大于元素，则背景图片一部分会无法完全显示 如果背景图片大小等于元素，则背景图片会直接正常显示 background-repeat 设置背景图片的重复方式 repeat 默认值，背景图片沿着 x 轴和 y 轴双方向重复 repeat-x 背景图片沿着 x 轴方向重复 repeat-y 背景图片沿着 y 轴方向重复 no-repeat 背景图片不重复 background-position 设置背景图片的位置 通过top left right bottom center几个表示方位的词来设置背景图片的位置：使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是center 通过偏移量来指定背景图片的位置：水平方向偏移量、垂直方向变量 background-clip 设置背景的范围 border-box 默认值，背景会出现在边框的下边 padding-box 背景不会出现在边框，只出现在内容区和内边距 content-box 背景只会出现在内容区 background-origin 背景图片的偏移量计算的原点 border-box 背景图片的变量从边框处开始计算 padding-box 默认值，background-position从内边距处开始计算 content-box 背景图片的偏移量从内容区处计算 background-size 设置背景图片的大小 第一个值表示宽度，第二个值表示高度；如果只写一个，则第二个值默认是auto cover 图片的比例不变，将元素铺满 contain 图片比例不变，将图片在元素中完整显示 background-attachment 背景图片是否跟随元素移动 scroll 默认值，背景图片会跟随元素移动 fixed 背景会固定在页面中，不会随元素移动 简写： backgound 背景相关的简写属性，所有背景相关的样式都可以通过该样式来设置并且该样式没有顺序要求，也没有哪个属性是必须写的 注意 background-size必须写在background-position的后边，并且使用/隔开background-position/background-size background-origin background-clip 两个样式，orgin要在clip的前边 练习（背景按钮）12345678910111213141516171819202122232425 &lt;style&gt; a:link{ /* a是行内元素不支持背景，转换为块元素支持。 */ display: block; width: 93px; height: 29px; background-image: url('./exercise/img/link.png'); } a:hover{ /* a是行内元素不支持背景，转换为块元素支持。 */ display: block; width: 93px; height: 29px; background-image: url('./exercise/img/hover.png'); } a:active{ /* a是行内元素不支持背景，转换为块元素支持。 */ display: block; width: 93px; height: 29px; background-image: url('./exercise/img/active.png'); } &lt;/style&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 效果： 在刚进入网页的时候，只加载了link一张图，当达到触发条件的时候才会加载剩下两张，所以第一次点击的时候会出现突然发白的现象。 雪碧图解决图片闪烁的问题： 可以将多个小图片统一保存到一个大图片中，然后通过调整background-position来显示响应的图片 这样图片会同时加载到网页中就可以有效的避免出现闪烁的问题 这个技术在网页中应用十分广泛，被称为CSS-Sprite，这种图我们称为雪碧图 雪碧图的使用步骤： 先确定要使用的图标 测量图标的大小 根据测量结果创建一个元素 将雪碧图设置为元素的背景图片 设置一个偏移量以显示正确的图片 雪碧图的特点： 一次性将多个图片加载进页面，降低请求的次数，加快访问速度，提升用户的体验 1234567891011121314151617181920&lt;style&gt; a:link { display: block; width: 93px; height: 29px; background: url(&quot;./exercise/img/btn.png&quot;); /* 默认值，可以不设置 */ background-position: 0 0; } a:hover { /* 设置水平方向的一个偏移量；注意是向左移动，所以是负值 */ background-position: -93px 0; } a:active { /* 设置水平方向的一个偏移量；注意是向左移动，所以是负值 */ background-position: calc(-93px * 2) 0; }&lt;/style&gt; 线性渐变通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果 渐变是图片，需要通过background-image来设置 线性渐变，颜色沿着一条直线发生变化 linear-gradient() 12# 红色在开头，黄色在结尾，中间是过渡区域background-image: linear-gradient(red, yellow); 线性渐变的开头，我们可以指定一个渐变的方向 to left to right to bottom to top deg deg 表示度数 turn 表示圈 1background-image: linear-gradient(45deg, red, yellow); repeating-linear-gradient() 可以平铺的线性渐变（默认状况下和上图一样） 1background-image: repeating-linear-gradient(red, yellow); 1background-image: repeating-linear-gradient(red 0px, yellow 50px); 径向渐变radial-gradient() 径向渐变（放射性的效果） 1background-image: radial-gradient(red, yellow); 默认情况下，circle和ellipse是自动适配盒子的，我们也可以手动指定径向渐变的形状 形状 circle 圆形 ellipse椭圆 1background-image: radial-gradient(circle, red, yellow); 也可以指定渐变的位置 位置 top right left center bottom 1background-image: radial-gradient(at top, red, yellow); 当然，除了上述值，还可以指定像素 12background-image: radial-gradient( at 50px 100px, red 50px, yellow 100px); 大小 closest-side 近边 farthest-side 远边 closest-corner 近角 farthest-corner 远角 1background-image: radial-gradient(100px 60px, red, yellow); 同时对其形状/大小和位置进行指定 radial-gradient(形状/大小 at 位置, 颜色 位置, 颜色 位置, 颜色 位置) 1background-image: radial-gradient(circle at 50px 100px, red 50px, yellow 100px); 1background-image: repeating-radial-gradient(circle at 50px 100px, red 50px, yellow 100px); 总结：径向渐变的渐变方向以圆心为起点，往四周扩散的；同一半径上的颜色是渐变的，同一圆周上的颜色是一致的 练习（电影卡片）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;style&gt; .outer { width: 240px; margin: 40px auto; /* 设置影音 */ box-shadow: 0 0 10px rgb(0, 0, 0.3); } .img-wrapper img { width: 100%; } .info { padding: 0 21px; } /* 设置标题 */ .info .title { color: #717171; font-size: 18px; margin: 13px 0 15px 0; } /* 设置分类 */ .info .category { color: #acaaaa; font-size: 14px; } .info .category::before { content: &quot;\\f02d&quot;; /* font-family: 'Font Awesome 5 Brands'; */ font-family: &quot;Font Awesome 5 Free&quot;; font-weight: 900; margin-right: 4px; color: gray; } /* 设置简介 */ .info .intro { margin: 18px 4px; color: #acaaaa; font-size: 14px; line-height: 20px; } .star-wrapper { border-top: 1px solid #e9e9e9; height: 20px; padding: 10px; color: #ddd; } .star { float: left; } .star-wrapper .light { color: #b9cb41; } .fa-weibo { float: right; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 外部包裹的容器 --&gt; &lt;div class=&quot;outer&quot;&gt; &lt;!-- 图片容器 --&gt; &lt;div class=&quot;img-wrapper&quot;&gt; &lt;img src=&quot;./img/10/1.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 内容区容器 --&gt; &lt;div class=&quot;info&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; 动画电影 &lt;/h2&gt; &lt;h3 class=&quot;category&quot;&gt; 动画 &lt;/h3&gt; &lt;p class=&quot;intro&quot;&gt; 这个是迪士尼动画,非常好看,讲述的是一个公主的故事 &lt;/p&gt; &lt;/div&gt; &lt;!-- 评分容器 --&gt; &lt;div class=&quot;star-wrapper&quot;&gt; &lt;ul class=&quot;star&quot;&gt; &lt;li class=&quot;fas fa-star light&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star light&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star&quot;&gt;&lt;/li&gt; &lt;li class=&quot;fas fa-star&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;fab fa-weibo&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 效果：","link":"/2024/03/07/%E8%83%8C%E6%99%AF/"},{"title":"8-表格","text":"CSS表格和表单 表格网页中我们也需要使用表格，我们通过table标签来创建一个表格 在table中使用tr表示表格中的一行，有几个tr就有几行 在tr中使用td表示一个单元格，有几个 td就有几个单元格 rowspan 纵向的合并单元格 colspan 横向的合并单元格 12345678910111213141516171819202122232425262728&lt;table border=&quot;1&quot; width=&quot;50%&quot; align=&quot; center&quot;&gt; &lt;!--在table中使用tr表示表格中的一行，有几个tr就有几行--&gt; &lt;tr&gt; &lt;!--在tr中使用td表示一个单元格，有几个td就有几个单元格--&gt; &lt;td&gt;A1&lt;/td&gt; &lt;td&gt;B1&lt;/td&gt; &lt;td&gt;C1&lt;/td&gt; &lt;td&gt;D1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A2&lt;/td&gt; &lt;td&gt;B2&lt;/td&gt; &lt;td&gt;C2&lt;/td&gt; &lt;!--rouspan 纵向的合并单元格--&gt; &lt;td rowspan=&quot;2&quot;&gt;D2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;AB&lt;/td&gt; &lt;td&gt;B3&lt;/td&gt; &lt;td&gt;C3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A4&lt;/td&gt; &lt;td&gt;B4&lt;/td&gt; &lt;!-- colspan横向的合并单元格 --&gt; &lt;td colspan=&quot;2&quot;&gt;C4&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 长表格可以将一个表格分成三个部分： 头部 thead 主体 tbody 底部 tfoot th 表示头部的单元格 表格的样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 &lt;style&gt; table { width: 50%; margin: 0 auto; border: 1px black solid; /* border-spacing：指定边框之间的距离；边框之间虽然没有距离了，但是实际上是两条边框的和，看起来是变粗了 */ /* border-spacing: 0; */ /*border-collapse:collapse；设置边框的合并；真正的将两条边框合并成一条边框 */ border-collapse: collapse; /* 默认情况下元素在td中是垂直居中的，可以通过vectical-align来修改 */ vertical-align: middle; text-align: center; } /* 如果表格中没有使用tbody而是直接使用tr，那么浏览器会自动创建一个tbody，并且将tr全都放到tbody中 所以说，tr不是table的子元素 */ tbody tr:nth-child(odd) { background-color: rgb(211, 216, 188); } td { border: 1px black solid; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;孙悟空&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;花果山&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;猪八戒&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;28&lt;/td&gt; &lt;td&gt;高老庄&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;沙和尚&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;38&lt;/td&gt; &lt;td&gt;流沙河&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;唐僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;女儿国&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;孙悟空&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;花果山&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;猪八戒&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;28&lt;/td&gt; &lt;td&gt;高老庄&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;沙和尚&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;38&lt;/td&gt; &lt;td&gt;流沙河&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;唐僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;女儿国&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;唐僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;女儿国&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;孙悟空&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;花果山&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;猪八戒&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;28&lt;/td&gt; &lt;td&gt;高老庄&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;沙和尚&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;38&lt;/td&gt; &lt;td&gt;流沙河&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;唐僧&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;16&lt;/td&gt; &lt;td&gt;女儿国&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 表单表单 在现实生活中表单用于提交数据 在网页中也可以使用表单，网页中的表单用于将本地的数据提交给远程的服务器 form 的属性 action：表单要提交的服务器的地址 文本框注意：数据要提交到服务器中，必须要为元素指定一个name属性值 1文本框&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; 密码框1密码框&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; 提交按钮1&lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; 单选框像这种选择框，必须要措定一个value属性，value属性最终会作为用户填写的值传递给服务器 123单选框&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;a&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;hello&quot; value=&quot;b&quot; checked /&gt; 多选框1234多选框&lt;input type=&quot;checkbox&quot; name=&quot;test&quot; value=&quot;1&quot; /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;test&quot; value=&quot;2&quot; /&gt;&lt;input type=&quot;checkbox&quot; name=&quot;test&quot; value=&quot;3&quot; checked /&gt; 下拉列表123456下拉列表&lt;select name=&quot;haha&quot;&gt; &lt;option value=&quot;i&quot;&gt;选项一&lt;/option&gt; &lt;option value=&quot;ii&quot; selected&gt;选项二&lt;/option&gt; &lt;option value=&quot;iii&quot;&gt;选项三&lt;/option&gt;&lt;/select&gt; 按钮12345678910&lt;!-- 提交按钮 --&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;!-- 重置按钮 --&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;!-- 普通按钮 --&gt;&lt;input type=&quot;button&quot; value=&quot;按钮&quot; /&gt;&lt;br /&gt;&lt;br /&gt;&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt; 上面两种写法实际上效果是一致的，区别在于： input是自闭合标签，不需要&lt;/input&gt;就能结束；button不是自闭合标签，跟一般标签一样是成对出现的 button因为不是自闭合标签，所以使用起来更灵活，可以嵌套其他的标签","link":"/2024/03/08/%E8%A1%A8%E6%A0%BC/"},{"title":"软件工程","text":"​ 采用工程的概念、原理、技术和方法来开发与维护软件,把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，经济的开发出高质量的软件并维护它。 软件工程概述软件工程概念：​ 采用工程的概念、原理、技术和方法来开发与维护软件,把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，经济的开发出高质量的软件并维护它。 软件生命周期： 软件过程 阶段间具有顺序性和依赖性。 推迟实现的观点。 质量保证的观点每个阶段必须完成规定的文档;每个阶段结束前完成文档审查，及早改正错误。 ![改进后的瀑布模型](../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20230228100926099.png 增量模型优缺点:优点: 短时间内可提交完成部分功能 逐渐增加产品功能, 用户适应产品快。 缺点: 增量构件划分以及集成困难。 容易退化为边做边改模型。 螺旋模型优缺点: .优点: 利于把软件质量作为软件开发目标。 减少测试 维护和开发不分开 缺点: 风险估计困难 可行性研究可行性研究目的​ 用最小的代价在最小的时间内确定问题是否能够解决。(5%-10%) 可行性研究内容和目的可行性研究步骤： 复查系统规模和目标。对问题定义阶段初步确定的规模和目标进行肯定或改正并列出对目标系统的约束和限制。 研究目前正在使用的系统。了解现有系统能做什么，而不花费过多时间分析怎么实现这些功能。 导出新系统的高层逻辑模型。现有物理系统》现有逻辑模型》目标逻辑模型》目标物理系统 进一步定义问题。分析员和用户一起再次复查系统。前四个步骤构成一个循环。 导出和评价供选择的解法技术角度排除不可行方案操作可行性排除用户不能接受方案经济可行估算成本和收益 推荐行动方针。给出是否继续的结论 草拟开发计划。制定进度表开发人员、计算机资源分析估计每阶段成本、下阶段详细分析 书写文档提交审查。 数据流图系统流程图： 是一种描绘物理系统的图，用图形符号以黑盒子形式描绘物理系统的各部件，表达数据在系统各部件之间流动的情况。而不是对数据进行加工处理的控制过程。 常用符号： 数据流图(DFD)： 描述信息流和数据从输入到输出过程所经受的变换。没有任何具体物理部件,只是描绘数据在软件中流动和被处理的逻辑过程。 常用符号： 数据流图画法: 确定系统输入输出、源点以及终点 画系统顶层数据流图用加工将输入输出数据连接起来，给加工、数据等命名. 自顶向下分解，画出分层数据流图将加工细分，细分成几个数据流图表示. 数据字典数据字典： 是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。 1.数据字典的内容:数据流、数据流分量(数据元素)、数据存储、处理。 2.定义数据的方法:由数据元素组成数据的方式:顺序、选择、重复、可选 数据字典例题: 1234567891011电话号码= [校内电话|校外电话]校内电话=非零数字+三位数字非零数字=[1|2|3|4|5|6|7|8|9]三位数字= 3{数字}3数字=[0|1|2|3|4|5|6|7|8|9]校外电话=[本市电话|外地电话]本市电话=0 +八位非零开头数字八位非零开头数字=非零数字+七位数字七位数字= 7{数字}7外地电话=0+三位区码+八位非零开头数字三位区码=三位数字 需求分析 需求分析的任务和阶段需求分析任务： 确定对系统的综合要求 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 其中综合要求有： E-R图绘制分析建模 模型是指为了理解事物二队十五做出的一种抽象的，对事物的一种无歧义的书面描述 模型分类： 数据模型: (实体-联系图) :描绘数据对象及数据对象之间的关系。 功能模型: ( 数据流图):描绘数据在系统中流动时被处理的逻辑过程，指明系统具有的变换数据的功能。 行为模型: (状态转换图) :描绘系统的各种行为模式在不同状态间转换的方式。 实体联系图(E-R图) 实体:描述数据对象。 属性:描述数据对象的性质。 联系:描述数据对象之间的交互方式。 对一联系1:1 对多联系1:M 多对多联系M:N 表示方式 ​ 实例： 状态转换图 状态:系统的行为模式，包括初态、终态、中间状态。 事件:是指在某个特定时刻发生的事情， 即对系统从一个状态转换到另一个状态的事件抽象。 表示方式 初态:实心圆在一张状态图中只能有一个初态 终态:同心圆，内为实心●而终态可以有0至多个。 状态:圆角矩形 其他图形工具 层次方框图：表示方式:用树形结构的一系列矩形描绘数据的层次结构。 优点:随着结构的逐步精细对数据结构的描绘也越来越详细。 Warnier图表示方式:用树形结构描绘信息的层次结构。 优点:可以表明信息的逻辑组织。可以表明某类信息出现的条件或是否重复出现。 IPO图表示方式:是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。 优点:简略描绘系统主要算法。 总体设计 设计过程设计过程包括系统设计阶段和结构设计阶段： 系统设计阶段： 设想供选择的方案: 数据流图出发，将处理分组抛弃行不通分组。 选取合理的方案:上一步方案选取低、中、高成本三种方案 推荐最佳方案:推荐最佳方案，制定详细实现计划 结构设计阶段： 功能分解:对数据流图进一步细化，进行功能分解。可以用IPO图等工具描述细化后每个处理的算法。 设计软件结构:层次图或结构图描绘软件结构。或数据流图导出软件结构。 设计数据库 制定测试计划 书写文档 审查和复审 设计原理 模块化：模块:能够单独命名，由边界元素限定的程序元素的序列，是构成程序的基本构件。模块化:把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。 抽象:抽出事务的本质特性而暂时不考虑它们的细节。 逐步求精:逐步揭露出底层细节。Miller法则:注意力集中在(7+2)上 信息隐藏与局部化：信息隐藏:指一个模块内包含的信息对于不需要这些信息的模块来说，是不能访问的。主要是指模块的实现细节。局部化:指把一些关系密切的软件元素物理地放得彼此靠近，它有助于实现信息隐藏。 模块独立：模块独立性:是模块化、抽象、信息隐蔽和局部化概念的直接结果。模块独立是好设计的关键，设计是决定软件质量的关键环节。度量标准:耦合、内聚 耦合是对一个软件结构内不同模块之间互连程序的度量。耦合强度取决于模块接口的复杂程度、通过接口的数据等耦合性越高，模块独立性越弱。耦合分类(程度从低-&gt;高):无直接耦合=》数据耦合=》标记耦合(特征耦合)=》控制耦合=》外部耦合=》公共耦合 内聚是用来度量一个模块内部各个元素彼此结合的紧密程度的。.内聚分类(程度从低-&gt;高):偶然内聚=》逻辑内聚=》时间内聚=》过程内聚=》通信内聚=》顺序内聚=》功能内聚 同其它模块强耦合的模块意味着弱内聚;强内聚模块意味着与其它模块间松散耦合 软件设计目标:高内聚、低耦合 启发规划 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇入和扇出应适当深度:表示软件结构中控制的层数。宽度:软件结构内同一个层次上的模块总数的最大值。扇出:一个模块直接控制(调用)的模块数目，扇出过大意味着模块过分复杂。一般一个设计的好的典型系统的平均扇出是3或4，扇出的上限是5到9。扇入:指有多少上级模块调用它，扇入大说明上级模块共享该模块的数目多。好的软件结构顶层扇出比较高，中层扇出比较少，底层扇入到公共的实用模块中，即底层模块有高扇入。 模块的作用域应该在控制域之内作用域:指受该模块内一个判定影响的所有模块的集合。控制域:是这个模块本身以及所有直接或间接从属于它的模块的集合。 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 结构设计图形工具 层次图：用方框和连线表示，连线表示上下层的调用关系 HIPQ图：层次图加编号 结构图：不仅描述调用关系，还描述传递的信息和调用的方式 箭头代表调用过程中传递的信息，尾部空心代表数据，实心代表控制信息 结构化设计方法（面向数据流设计方法） 交换流:由输入，变换中心和输出三部分组成 事物流： ​ 详细设计详细设计的任务目的目的： 确定怎样具体的实现所要求的系统。得出对目标的精确描述 详细设计任务: 过程设计:即设计软件体系结构中所包含的每个模块的实现算法。 数据设计:设计软件数据结构。 接口设计:设计软件内部各模块之间的接口 结构程序设计只使用三种基本的控制结构就能够实现任何单入口单出口的程序 扩充的控制结构： Do-case多分支和Do-UNRTIL循环 人机界面设计人机界面设计:是接口设计的一个重要的组成部分。 设计人机界面过程常遇到的4个问题: 系统响应时间重要属性:长度和易变性 用户帮助设施 出错信息处理 命令交互 人机界面设计指南： 一般交互指南 信息显示指南 数据输入指南 过程设计工具程序流程图： 盒图（N-S）：出于要有一种不允许违背就够程序设计精神的图形工具的考虑 PAD图：它用二位树形结构的图来显示程序的控制流，将这种图翻译成车光绪代码比较容易 判定表：当算法中包含多重嵌套的条件选择时判定表却能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。 组成: 左上部列出所有条件，左下部是所有可能的动作。右上部是表示各种条件组合，右下部是和每种条件组合相对应的动作。 判定树： 是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。 PDL:过程语言也叫伪代码 程序复杂度的定量度量 程序复杂度定量度量:定量的度量详细设计模块的质量。 McCabe方法将程序图转化为程序流程图再计算复杂度。 计算方法: 流图中的区域数等于环形复杂度 流图G的环形复杂度V(G)=E-N+2， E是流图中边的条数，N是结点数。 流图G的环形复杂度V(G)=P+1,其中，P是流图中判定结点的数目。 V(G)","link":"/2022/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"title":"计算机网络","text":"计算机网络 参考视频 基础英特网概述网络、互联网与因特网 网络(Network)是由若干结点(Node）和连接这些节点的链路(Link)组成的 ·多个网络还可以通过路由器连接起来，这样就形成了一个更大覆盖范围更大的网络即互联 因特网（Internet）是世界上最大的互联网络，用户数以亿计，互连的网络树以百万计 因特网发展的三个阶段 1969年：从单个网络ARPANET(Advanced Research Project Agency)向互联网发展 1969年，第一个分组交换网ARPANET 70年代中期，研究多种网络之间的互联 1983年，TCP/IP协议成为ARPANET的标准协议（因特网诞生时间） 1985年：逐步建成三级结构的因特网 1985年，NSF围绕6个大型计算机建设NSFNET（主干网、地区网和校园网） 1990年，ARPANET任务完成，正式关闭 1991年，美国政府将因特网主干网交给私人公司经营，并开始对接入因特网的单位收费 1993年：逐步形成了多层次ISP结构的因特网 1993年，NSFNET逐渐被若干个商用因特网主干网替代；政府机构不再负责因特网运营，让各种因特网服务提供者ISP来运营 1994年，万维网WWW技术促使因特网迅猛发展 1995年，NSFNET停止运作，因特网彻底商业化 因特网的组成 边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。","link":"/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"9-过度和动画","text":"CSS表格 过渡（transition） 通过过渡可以指定一个属性发生变化时的切换方式 通过过渡可以创建一些非常好的效果，提升用户的体验 属性值 transition-property：指定要执行过渡的属性 多个属性间使用,隔开； 如果所有属性都需要过渡，则使用all关键字； 大部分属性都支持过渡效果； 注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡； transition-duration：指定过渡效果的持续时间 时间单位：s 和 ms（1s=1000ms） transition-delay：过渡效果的延迟，等待一段时间后在执行过渡 transition-timing-function：过渡的时序函数 linear匀速运动 ease 默认值，慢速开始，先加速后减速 ease-in 加速运动 ease-out 减速运动 ease-in-out 先加速后减速 cubic-bezier()来指定时序函数 https://cubic-bezier.com ```steps() 1234567891011121314151617 分步执行过渡效果，可以设置第二个值： - `end`，在时间结束时执行过渡（默认值） - `start`，在时间开始时执行过渡`transition`：可以同时设置过渡相关的所有属性- 只有一个要求，如果要写延迟，则两个时间中第一个是持续时间，第二个是延迟时间**示例**```css/* transition: margin-left 2s 1s; */transition-property: margin-left;transition-duration: 2s;transition-delay: 1s; 几种过渡效果对比 linear匀速运动 1transition-timing-function: linear; ease 默认值，慢速开始，先加速后减速 1transition-timing-function: ease; ease-in 加速运动 1transition-timing-function: ease-in; ease-out 减速运动 1transition-timing-function: ease-out; ease-in-out 先加速后减速 1transition-timing-function: ease-in-out; cubic-bezier()来指定时序函数 1transition-timing-function: cubic-bezier(0.17, 1.79, 0.68, -0.69); steps()分步执行过渡效果 12/* transition-timing-function: steps(2, end); */transition-timing-function: steps(2); 1transition-timing-function: steps(2, start); 实战米兔1234567891011121314.mitu{ width: 132px; height: 271px; margin: 40px auto; background-image: url('./img/bigtap.png'); /* 确定初始的位置 */ background-position: 0, 0; /* 三次转换 */ transition: 0.3s steps(3);}.mitu:hover{ /* 移动到的最终的位置 */ background-position: -396px 0;} 动画动画和过渡类似，都是可以实现一些动态的效果，不同的是 过渡需要在某个属性发生变化时才会触发 动画可以自动触发动态效果 设置动画效果，必须先要设置一个关键帧，关键帧设置了动画执行每一个步骤 123456789@keyframes test { from { margin-left: 0; } to { margin-left: 900px; }} animation-name 指定动画的关键帧名称 animation-duration：指定动画效果的持续时间 animation-delay：动画效果的延迟，等待一段时间后在执行动画 animation-timing-function：动画的时序函数 animation-iteration-count 动画执行的次数 infinite 无限执行 animation-direction 指定动画运行的方向 normal 从from向to运行，每次都是这样，默认值 reverse 从to向from运行，每次都是这样 alternate 从from向to运行，重复执行动画时反向执行 alternate-reverse 从to向from运行，重复执行动画时反向执行 animation-play-state 设置动画的执行状态 running 动画执行，默认值 paused 动画暂停 animation-fill-mode 动画的填充模式 none 动画执行完毕，元素回到原来位置，默认值 forwards 动画执行完毕，元素会停止在动画结束的位置 backwards 动画延时等待时，元素就会处于开始位置 both 结合了forwards和backwards 练习米兔123456789101112131415161718192021&lt;style&gt; .mitu { width: 132px; height: 271px; margin: 40px auto; background-image: url('./img/bigtap.png'); /* 确定初始的位置 */ /* 三次转换 */ animation: run 0.3s steps(3); } @keyframes run { form { background-position: 0, 0; } to { background-position: -396px 0; } }&lt;/style&gt; 效果同上","link":"/2024/03/09/%E8%BF%87%E5%BA%A6%E5%92%8C%E5%8A%A8%E7%94%BB/"},{"title":"1-选择器","text":"CSS选择器,继承性,优先级和长度单位 准备常见的字符集： 【Web前端HTML5&amp;CSS3】01-前端简介 - VectorX - 博客园 (cnblogs.com) 网页基本知识: 【Web前端HTML5&amp;CSS3】03-字符实体与语义标签 - VectorX - 博客园 (cnblogs.com) CSS语法和选择器样式表内联样式(行内样式) 在标签内部通过style属性来设置元素的样式 1&lt;p style=&quot;color:red;font-size:60px;&quot;&gt;内联样式（行内样式）&lt;/p&gt; 开发时候尽量不要使用 内部样式表 将样式编写到head中的style标签里然后通过 css 的选择器来选中元素并为其设置各种样式可以同时为多个标签设置样式，并且修改时只需要修改一处即可。内部样式表更加方便对样式进行复用 123456&lt;style&gt;p{ color:green; font-size:50px;}&lt;/style&gt; 外部样式表 可以将 css 样式编写到一个外部的 CSS 文件中，然后通过link标签来引入外部的 CSS 文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; /&gt; 选择器css选择器通配选择器（Universal selector） 选择页面中所有的元素 123* { color: red;} 元素选择器（Type selector） 根据标签名选中指定的元素 1234567p { color: red;}h1 { color: green;} 类选择器（Class selector） 根据元素的class属性选中一组元素 123456.blue { color: blue;}.size { font-size: 20px;} class是一个标签的属性，它和id类似，不同的是class: 可以重复使用， 可以通过class属性来为元素分组， 可以同时为一个元素指定多个class属性 ID 选择器（ID selector） 根据元素id属性值选中元素 123#red { color: red;} 属性选择器（Attribute selector） 1234567891011121314151617181920#选择含有指定属性的元素p[title] { color: orange;}#选择含有指定属性和属性值的元素p[title=&quot;e&quot;] { color: orange;}#选择属性值以指定值开头的元素p[title^=&quot;e&quot;] { color: orange;}#选择属性值以指定值结尾的元素p[title$=&quot;e&quot;] { color: orange;}#选择属性值中含有某值的元素p[title*=&quot;e&quot;] { color: orange;} 复合选择器 交集选择器和并集选择器区别_笔记大全_设计学院 (python100.com) 并集选择器 选中同时复合多个条件的元素() 1234#选中所有class为box和p标签的元素.box, p { font-size: 20px;} 选择的是所有选择器(.box和p) 交集选择器 选中符合条件的元素 123.box span.article { font-size: 20px;} 选中.box中带有.article的span元素 关系选择器子元素选择器（Child combinator） 选中指定父元素的指定子元素 123div.box &gt; p &gt; span { color: orange;} 后代元素选择器（Descendant combinator） 选中指定元素内的指定后代元素 123div span { color: skyblue;} 兄弟元素选择器（Sibling combinator） 选择下一个兄弟 123456789#选中第一个&lt;p&gt;元素紧跟着一个同级的&lt;span&gt;元素时p + span { color: red;}#选中&lt;p&gt;元素后面的所有同级&lt;span&gt;元素p ~ span { color: red;} 伪类选择器伪类（不存在的类，特殊的类） 用来描述一个元素的特殊状态，例如：第一个子元素，被点击的元素 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child() 选中第 n 个子元素 n：第 n 个，n 的范围 0 到正无穷 2n 或 even：选中偶数位的元素 2n+1 或 odd：选中奇数位的元素 123456789101112131415161718192021222324/* ul下所有li，黑色 */ul &gt; li { color: black;}/* ul下第偶数个li，黄色 */ul &gt; li:nth-child(2n) { color: yellow;}/* ul下第奇数个li，绿色 */ul &gt; li:nth-child(odd) { color: green;}/* ul下第一个li，红色 */ul &gt; li:first-child { color: red;}/* ul下最后一个li，黄色 */ul &gt; li:last-child { color: orange;} 123456789101112131415161718192021&lt;style&gt; /* 把没访问过的链接用特殊颜色标记出来 */ a:link { color: aqua; } /* 把已经访问过的链接用特殊颜色标记 */ a:visited { color: azure; } /* 鼠标经过时链接变色 */ a:hover { color: black; } /* 鼠标按下还未弹起的时候变换的特殊颜色 */ a:active { color: blue; }&lt;/style&gt; 伪元素选择器伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置） ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 元素的开始 ::after 元素的最后 ::before和::after 必须结合content属性来使用 1234567891011121314151617181920212223242526/* 段落首字母设置大小为30px */p::first-letter { font-size: 30px;}/* 段落第一行设置为黄色背景 */p::first-line { background-color: yellow;}/* 段落选中的部分变绿色 */p::selection { background-color: green；;}/* div前加上内容 */div::before { content: &quot;BEFORE&quot;; color: red;}/* div后加上内容 */div::after { content: &quot;AFTER&quot;; color: blue;} 选择器练习小游戏 三特性和其他css的三特性层叠性相同选择器设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。层叠性的主要解决冲突的问题 层叠性原则： 样式冲突，遵循就近原则，那个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 继承性为一个元素设置的样式，同时也会应用到它的后代元素上继承是发生在祖先后后代之间的，继承的设计是为了方便开发。 利用继承，可以将一些通用的样式（css中子标签会继承父标签的某些样式，如文本颜色和字号），统一设置到共同的祖先元素上。这样只需设置一次即可让所有的元素都具有该样式 注意，并不是所有的样式都会被继承： 比如背景相关的，布局相关等的这些样式都不会被继承。 优先级 相同选择器，遵循层叠原则 不同选择器，按照权重来 ​ 选择器 权重 继承 0，0，0，0 元素标签选择器 0，0，0，1 类/伪类选择器 0，0，1，0 id选择器 0，1，0，0 行内样式表 1，0，0，0 important ∞ 1background-color: rgba(0, 0, 0, 0.3) !important; 使用important声明的属性优先级最高 注意： 如果继承的优先级为0，如果标签定义有样式表，则优先级高于其继承父标签的样式表 1234567891011121314 &lt;style&gt; #father { color: aqua; } p { color: azure; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 权重的叠加： 比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的） 选择器的累加不会超过其最大的数量级，类选择器再高也不会超过 ID 选择器 如果优先级计算后相同，此时则优先使用靠下的样式 长度单位 百分比：可以将属性值设置为相对于其父元素属性的百分比，可以使子元素跟随父元素的改变而改变 px：像素点 em：参考是父元素的font-size（1em = &lt;self&gt;.font-size），具有继承的特点。如果自身定义了font-size按照自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值 rem：css3新单位，相对于根元素html的font-size（1em = &lt;root&gt;.font-size），不会像em那样，依赖于父元素的字体大小，而造成混乱","link":"/2024/03/23/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"黑苹果使用","text":"黑苹果显卡温度检测（配合sensei使用）【黑苹果】让AMD显卡正常显示温度 | 给A卡添加温度传感器驱动_哔哩哔哩_bilibili 黑苹果下amd显卡关闭显卡智能启停高温夏天 显卡风扇不转怎么办？双系统（windows+macOS）下给显卡降降温_哔哩哔哩_bilibili oc引导更换机型三码OC引导快速更换三码和机型教程_哔哩哔哩_bilibili oc引导屏蔽不支持的硬盘黑苹果屏蔽三星981或者镁光2200等不支持的硬盘方法_哔哩哔哩_bilibili 黑苹果cpu睿频（配合cpus使用）黑苹果下CPU睿频，让黑苹果更加完美黑苹果CPU变频睿频日志，一招解决CPU频率不正确，无法变频-CPU黑苹果睿频解决卡顿现象黑果CPU变频日志睿频教程_哔哩哔哩_bilibili","link":"/2023/01/18/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%BD%BF%E7%94%A8/"},{"title":"JS面向对象高级","text":"JS面向对象高级 对象创建模式Object构造函数模式 方法：先创建空的Object对象，再动态添加属性方法 适用：起始时候不确定对象内部数据 缺点：语句太多 12345678910111213141516// 先创建一个空Object对象var p = new Object()// 此时候内部数据还是不确定的p = {}// 动态添加属性方法p.name = '小明'p.age = 18p.setName = function (name) { this.name = name}// 执行p.setName('小红')console.log(p)console.log(p.name)console.log(p.age) 对象字面量模式 方法：使用{}创建对象,同时指定方法属性 适用：起始时候对象内部数据是确定的 缺点：如果创建多个对象,有重复代码 123456789101112// 对象字面量模式var p = { name: '小明', age: 18, setName: function (name) { this.name = name }}// 测试console.log(p.name,p.age)p.setName('小红')console.log(p.name,p.age) 工厂模式 方法：通过工厂函数动态创建对象并且返回 适用：需要创建多个对象 缺点：对象没有一个具体的类型,都是Object类型 123456789101112function createPerson(name, age) { var p = { name: name, age: age, setName: function (name) { this.name = name } } return p}var p1 = createPerson('小明', 18)var p2 = createPerson('小红', 20) 自定义函数构造 方法: 自定义构造函数, 通过new创建对象 适用: 需要创建多个类型确定的对象,与上方工厂模式有所对比 缺点: 每个对象都有相同的数据, 浪费内存 12345678910111213141516171819202122//定义类型function Person(name, age) { this.name = name this.age = age this.setName = function (name) { this.name = name }}var p1 = new Person('Tom', 12)p1.setName('Jack')console.log(p1.name, p1.age)console.log(p1 instanceof Person)function Student (name, price) { this.name = name this.price = price}var s = new Student('Bob', 13000)console.log(s instanceof Student)var p2 = new Person('JACK', 23)console.log(p1, p2) 构造函数+原型的组合模式 方法: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用: 需要创建多个类型确定的对象 放在原型上可以节省空间(只需要加载一遍方法) 123456789101112//在构造函数中只初始化一般函数function Person(name, age) { this.name = name this.age = age}Person.prototype.setName = function (name) { this.name = name}var p1 = new Person('Tom', 23)var p2 = new Person('Jack', 24)console.log(p1, p2) 继承模式原型链继承方法: 定义父函数构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的实例对象赋值给子类型的原型(通过访问父类型的实例对象找到父类型原型中的函数) 创建子类型的对象:可以通过访问[子类型的原型]-&gt;[父类型的实例]-&gt;[父类型的原型]调用父类型的方法 123456789101112131415161718192021222324252627// 定义父类型构造函数function Father(){ this.fatherProp = '父类属性'}// 在父类型的原型添加父类型的方法Father.prototype.fatherMethod = function(){ console.log('父类方法')}// 定义子类型构造函数function Child(){ this.childProp = '子类属性'}// 将子类型的原型指向父类型的一个实例Child.prototype = new Father()// 让子类型的原型的constructor指向子类型// 父类型的实例没有constructor,会在父类型的原型上找到,返回的是父类型的constructor指向的是父类型Father()Child.prototype.constructor = Child// 子类型添加自己的方法Child.prototype.childMethod = function(){ console.log('子类方法')}// 创建子类型实例var child = new Child()// 子类型实例调用父类型方法child.fatherMethod() 借用构造函数继承(假的) 方法: 定义父类型构造函数 定义子类型构造函数 在子类型构造函数中调用父类型构造 关键: 在子类型构造函数中通用call()调用父类型构造函数 作用: 能借用父类中的构造方法,但是不灵活 1234567891011121314function Person(name, age) { this.name = name this.age = age}function Student(name, age, price) { //此处利用call(),将 [Student]的this传递给Person构造函数 Person.call(this, name, age) // 相当于: this.Person(name, age) /*this.name = name this.age = age*/ this.price = price}var s = new Student('Tom', 20, 14000)console.log(s.name, s.age, s.price) [Person]中的this是动态变化的,在[Student]中利用[Person.call(this, name, age)]改变了其this指向,所以可以实现此效果 组合继承(原型链+构造函数) 利用原型链实现对父类型对象的方法继承 利用super()借用父类型构建函数初始化相同属性 12345678910111213141516171819202122function Person(name, age) { this.name = name this.age = age}Person.prototype.setName = function (name) { this.name = name}function Student(name, age, price) { Person.call(this, name, age) // 为了得到属性 this.price = price}Student.prototype = new Person() // 为了能看到父类型的方法Student.prototype.constructor = Student //修正constructor属性Student.prototype.setPrice = function (price) { this.price = price}var s = new Student('Tom', 24, 15000)s.setName('Bob')s.setPrice(16000)console.log(s.name, s.age, s.price)","link":"/2024/08/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"css基础","slug":"css基础","link":"/tags/css%E5%9F%BA%E7%A1%80/"},{"name":"BFC和高度塌缩","slug":"BFC和高度塌缩","link":"/tags/BFC%E5%92%8C%E9%AB%98%E5%BA%A6%E5%A1%8C%E7%BC%A9/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"JS基础","slug":"JS基础","link":"/tags/JS%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Date","slug":"Date","link":"/tags/Date/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"},{"name":"Hexo搭建配置","slug":"Hexo搭建配置","link":"/tags/Hexo%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"JS作用域","slug":"JS作用域","link":"/tags/JS%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"JS函数","slug":"JS函数","link":"/tags/JS%E5%87%BD%E6%95%B0/"},{"name":"JS数组","slug":"JS数组","link":"/tags/JS%E6%95%B0%E7%BB%84/"},{"name":"JS构造函数","slug":"JS构造函数","link":"/tags/JS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"JS原型对象","slug":"JS原型对象","link":"/tags/JS%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"},{"name":"JS流程控制","slug":"JS流程控制","link":"/tags/JS%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"JS简介","slug":"JS简介","link":"/tags/JS%E7%AE%80%E4%BB%8B/"},{"name":"JS运算","slug":"JS运算","link":"/tags/JS%E8%BF%90%E7%AE%97/"},{"name":"JS高级","slug":"JS高级","link":"/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"css预处理","slug":"css预处理","link":"/tags/css%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"Less","slug":"Less","link":"/tags/Less/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQl","slug":"MySQl","link":"/tags/MySQl/"},{"name":"前端基础","slug":"前端基础","link":"/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"SaSS","slug":"SaSS","link":"/tags/SaSS/"},{"name":"预处理","slug":"预处理","link":"/tags/%E9%A2%84%E5%A4%84%E7%90%86/"},{"name":"hexo主题配置","slug":"hexo主题配置","link":"/tags/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"cactus","slug":"cactus","link":"/tags/cactus/"},{"name":"call","slug":"call","link":"/tags/call/"},{"name":"apply","slug":"apply","link":"/tags/apply/"},{"name":"arguments","slug":"arguments","link":"/tags/arguments/"},{"name":"弹性盒","slug":"弹性盒","link":"/tags/%E5%BC%B9%E6%80%A7%E7%9B%92/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"grid","slug":"grid","link":"/tags/grid/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"hexo使用","slug":"hexo使用","link":"/tags/hexo%E4%BD%BF%E7%94%A8/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"poems","slug":"poems","link":"/tags/poems/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Excel操作","slug":"Excel操作","link":"/tags/Excel%E6%93%8D%E4%BD%9C/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"包装类","slug":"包装类","link":"/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"变形","slug":"变形","link":"/tags/%E5%8F%98%E5%BD%A2/"},{"name":"平移","slug":"平移","link":"/tags/%E5%B9%B3%E7%A7%BB/"},{"name":"定时延时","slug":"定时延时","link":"/tags/%E5%AE%9A%E6%97%B6%E5%BB%B6%E6%97%B6/"},{"name":"字体","slug":"字体","link":"/tags/%E5%AD%97%E4%BD%93/"},{"name":"JS对象","slug":"JS对象","link":"/tags/JS%E5%AF%B9%E8%B1%A1/"},{"name":"定位","slug":"定位","link":"/tags/%E5%AE%9A%E4%BD%8D/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"政治","slug":"政治","link":"/tags/%E6%94%BF%E6%B2%BB/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"浮动","slug":"浮动","link":"/tags/%E6%B5%AE%E5%8A%A8/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"背景","slug":"背景","link":"/tags/%E8%83%8C%E6%99%AF/"},{"name":"雪碧图与渐变","slug":"雪碧图与渐变","link":"/tags/%E9%9B%AA%E7%A2%A7%E5%9B%BE%E4%B8%8E%E6%B8%90%E5%8F%98/"},{"name":"表格","slug":"表格","link":"/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"过度","slug":"过度","link":"/tags/%E8%BF%87%E5%BA%A6/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"面向对象","slug":"面向对象","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"study","slug":"study","link":"/categories/study/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"ES6","slug":"前端/JavaScript/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/ES6/"},{"name":"JavaScript进阶","slug":"前端/JavaScript进阶","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%9B%E9%98%B6/"},{"name":"tech","slug":"tech","link":"/categories/tech/"},{"name":"flask","slug":"后端/flask","link":"/categories/%E5%90%8E%E7%AB%AF/flask/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"jQuery","slug":"前端/JavaScript/jQuery","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/jQuery/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"python","slug":"计算机基础/python","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/python/"},{"name":"网络协议","slug":"前端/网络协议","link":"/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"软件工程","slug":"计算机基础/软件工程","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"pages":[{"title":"about","text":"TODOLIST","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"search","text":"","link":"/search/index.html"}]}