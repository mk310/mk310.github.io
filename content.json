{"posts":[{"title":"CSS基础","text":"css(Cascading Style Sheets)层叠样式表 准备常见的字符集： 【Web前端HTML5&amp;CSS3】01-前端简介 - VectorX - 博客园 (cnblogs.com) 网页基本知识: 【Web前端HTML5&amp;CSS3】03-字符实体与语义标签 - VectorX - 博客园 (cnblogs.com) CSS语法和选择器样式表内联样式(行内样式) 在标签内部通过style属性来设置元素的样式 1&lt;p style=&quot;color:red;font-size:60px;&quot;&gt;内联样式（行内样式）&lt;/p&gt; 开发时候尽量不要使用 内部样式表 将样式编写到head中的style标签里然后通过 css 的选择器来选中元素并为其设置各种样式可以同时为多个标签设置样式，并且修改时只需要修改一处即可。内部样式表更加方便对样式进行复用 123456&lt;style&gt;p{ color:green; font-size:50px;}&lt;/style&gt; 外部样式表 可以将 css 样式编写到一个外部的 CSS 文件中，然后通过link标签来引入外部的 CSS 文件 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; /&gt; 选择器css选择器通配选择器（Universal selector） 选择页面中所有的元素 123* { color: red;} 元素选择器（Type selector） 根据标签名选中指定的元素 1234567p { color: red;}h1 { color: green;} 类选择器（Class selector） 根据元素的class属性选中一组元素 123456.blue { color: blue;}.size { font-size: 20px;} class是一个标签的属性，它和id类似，不同的是class: 可以重复使用， 可以通过class属性来为元素分组， 可以同时为一个元素指定多个class属性 ID 选择器（ID selector） 根据元素id属性值选中元素 123#red { color: red;} 属性选择器（Attribute selector） 1234567891011121314151617181920#选择含有指定属性的元素p[title] { color: orange;}#选择含有指定属性和属性值的元素p[title=&quot;e&quot;] { color: orange;}#选择属性值以指定值开头的元素p[title^=&quot;e&quot;] { color: orange;}#选择属性值以指定值结尾的元素p[title$=&quot;e&quot;] { color: orange;}#选择属性值中含有某值的元素p[title*=&quot;e&quot;] { color: orange;} 复合选择器 交集选择器和并集选择器区别_笔记大全_设计学院 (python100.com) 交集选择器 选中同时符合多个条件的元素(同时符合多个选择器的元素) 1234#选中所有class为box并且p标签的元素.box p { font-size: 20px;} 并集选择器 选中同时复合多个条件的元素() 1234#选中所有class为box和p标签的元素.box, p { font-size: 20px;} 关系选择器子元素选择器（Child combinator） 选中指定父元素的指定子元素 123div.box &gt; p &gt; span { color: orange;} 后代元素选择器（Descendant combinator） 选中指定元素内的指定后代元素 123div span { color: skyblue;} 兄弟元素选择器（Sibling combinator） 选择下一个兄弟 123456789#选中第一个&lt;p&gt;元素紧跟着一个同级的&lt;span&gt;元素时p + span { color: red;}#选中&lt;p&gt;元素后面的所有同级&lt;span&gt;元素p ~ span { color: red;} 伪类选择器伪类（不存在的类，特殊的类） 用来描述一个元素的特殊状态，例如：第一个子元素，被点击的元素 :first-child 第一个子元素 :last-child 最后一个子元素 :nth-child() 选中第 n 个子元素 n：第 n 个，n 的范围 0 到正无穷 2n 或 even：选中偶数位的元素 2n+1 或 odd：选中奇数位的元素 123456789101112131415161718192021222324/* ul下所有li，黑色 */ul &gt; li { color: black;}/* ul下第偶数个li，黄色 */ul &gt; li:nth-child(2n) { color: yellow;}/* ul下第奇数个li，绿色 */ul &gt; li:nth-child(odd) { color: green;}/* ul下第一个li，红色 */ul &gt; li:first-child { color: red;}/* ul下最后一个li，黄色 */ul &gt; li:last-child { color: orange;} 123456789101112131415161718192021&lt;style&gt; /* 把没访问过的链接用特殊颜色标记出来 */ a:link { color: aqua; } /* 把已经访问过的链接用特殊颜色标记 */ a:visited { color: azure; } /* 鼠标经过时链接变色 */ a:hover { color: black; } /* 鼠标按下还未弹起的时候变换的特殊颜色 */ a:active { color: blue; }&lt;/style&gt; 伪元素选择器伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置） ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 元素的开始 ::after 元素的最后 ::before和::after 必须结合content属性来使用 1234567891011121314151617181920212223242526/* 段落首字母设置大小为30px */p::first-letter { font-size: 30px;}/* 段落第一行设置为黄色背景 */p::first-line { background-color: yellow;}/* 段落选中的部分变绿色 */p::selection { background-color: green；;}/* div前加上内容 */div::before { content: &quot;BEFORE&quot;; color: red;}/* div后加上内容 */div::after { content: &quot;AFTER&quot;; color: blue;} 选择器练习小游戏","link":"/2024/01/10/CSS%E5%9F%BA%E7%A1%80/"},{"title":"English","text":"define 简单句简单句的核心（主谓宾）简单句核心构成谓语分类 实义 不及物动词（动作能由主语独立完成）vi—主谓 及物动词（动作不能由主语独立完成）vt 主谓宾 主谓双宾语 主谓宾补 The spooks call it &quot;open source intelligence&quot; 无实义 主系（联系作用）表 系动词 解释 be动词 只有单独使用的时候才是 get become turn go grow 变得 look sound smell taste fell 感官动词 seem apppear/keep remain/prove 好像 保持 简单句核心变化谓语动词时态 一般时态 一般过去时：谓语动词–did 一般现在时：谓语动词-do/does 一般将来时：谓语动词-will do am/is/are going to do (现在的将来要发生的事情) 过去将来时：谓语动词-would do was/were going to do (过去的将来要发生的事情，一般前面有个过去时共同出现) 进行时态 过去进行时：谓语动词-was/were doing 现在进行时：谓语动词-am/is/are doing 将来进行时：谓语动词-will be doing 完成时态：一件事情完成的结果 - have done（1全部完成 可以和一般过去时互换 2部分完成） 过去完成时：谓语动词-had done （过去之前发生的事情） By 2020 they had finished 30% of the research. 现在完成时：谓语动词-have/has done(现在之前发生的事情) For the most part,the reponse has been favorable 将来完成时：谓语动词-will have done Relaxation will be in front of smell-television, and digital age will have arrived. 完成进行时 ：某个时间之前，强调一件事情进行的过程 现在完成进行时：谓语动词-have/has been doing 角度相同 表示之前 表示之前 两种时态 have/has done have/has been doing 强调不同 前调结果（做完与否都可以）We have not won the match 强调过程We have been working hard for several months 过去完成进行时：had been doing 将来完成进行时：will have been doing 谓语动词情态 情态动词+动词原型 谓语动词最多只有现在时，过去时两种时态 现在时 过去时 must — can could will would shall should may might 使用过去时可以使预期更加委婉 情态动词的人称变化无 情态动词变否定：直接加not，变疑问：谓语动词提前 情态动词表示情态 we must also act with caution. 情态动词表示推测 Such searchs can take years 三种时态 情态动词+do 情态动词+be doing 情态动词+have done 其他情态动词词组 have to ought to 谓语动词语态主动语态（主语是动作发出者） 被动语态（主语是动作接收者） 被动语态的构成：be（被动的时间）+ done（被动的动作） 被动语态和时态的结合： 意识 例子 这些评论家过去被遗忘 These critics were forgotten. 这些评论家现在被遗忘 These critics are forgotten. 这些评论家现在的将来被遗忘 These critics will be forgotten. 这些评论家过去的将来被遗忘 These critics would be forgotten. 这些评论家现过去正在被遗忘 These critics were being forgotten. 这些评论家现在正在被遗忘 These critics are being forgotten. 这些评论家过去已经被遗忘 These critics had been forgotten. 这些评论家现在已经被遗忘 These critics have been forgotten. 否定 实义动词变否定 do/does/did +not + 动词原形 助动词情态动词变否定 助动词和情态动词+not 如果同时有两个动词否定not放到第一个动词后面 each animal feels it is not being cheated. 强调do/does/did +动词原形 Although the figure may vary,analysts do agree on another matter 技巧（通过谓语动词切分句子） 抓住谓语动词，抓住句子最核心的表述动作和内容 通过定位谓语动词，找到复杂多变的主语 通过谓语动词的数量，判断长难句中包含几件事情 The same dramatic technological changes that have provided marketers with more(and more deverse) communications choices have also increased the risk that passionate consumers will voice their opinions in quicker,more visible,and much more damaging ways. 主语/宾语/表语的变化名词代词The process is nature selection. 非谓语动词doing(谓语动词只能一个，非谓语动词可以多个) 有动词后再加动词使用非谓语 Suffering is ineviteable.(作主语) Americans stopped takeing prosperity for granted.(做宾语) 非谓语动词 to doto decide is to kill off all possibilities but one(主语) It take sb. some to do sth.（it形式主语，to do主语） They may then decide to go elsewhere.(宾语) The decisions made it more difficult for states to collect sales tax on certain online puerchases. 使用it做形式宾语，句子放在末尾：句子后有补语或者句子过长 The trick is to direct these funds better.(表语) 并列多个从句Science and technology would cure all the ill of humanity. 并列连词 表达含义 and 和 both … and 和 not only but also 不但而且 选择连词 含义 or 或者（二选一） either or 或者（同上） neither nor 既不也不（两者都不选） 简单句扩展","link":"/2023/06/12/English/"},{"title":"Flask实战-QA平台","text":"Flask 基本平台搭建QA（项目名称） blueprint auth.py(作者蓝图,关于作者的视图) qa.py(问答蓝图) static(静态文件) template(网页模板) app.py(主程序) config.py(数据配置文件,防止相互引用) exts.py(扩展) models.py(模型文件) 1234567891011121314151617181920212223app.pyfrom flask import Flaskimport configfrom exts import dbfrom models import UserModelfrom blueprints.qa import bp as qa_bpfrom blueprints.auth import bp as auth_bpapp = Flask(__name__)# 绑定配置文件app.config.from_object(config)db.init_app(app)# 将引入的blueprint绑定app.register_blueprint(qa_bp)app.register_blueprint(auth_bp)@app.route(&quot;/&quot;)def hell(): return &quot;hello&quot;if __name__ == &quot;__main&quot;: app.run() 12345678910qa.pyfrom flask import Blueprint# 问答网页在首页,前缀只需要根路径bp = Blueprint(&quot;qa&quot;,__name__,url_prefix=&quot;/&quot;)@bp.route(&quot;/&quot;)def index(): pass 12345678910auth.pyfrom flask import Blueprint# /authbp = Blueprint(&quot;auth&quot;,__name__,url_prefix=&quot;/auth&quot;)@bp.route(&quot;/login&quot;)def login(): pass 1234567modeles.pyfrom exts import dbclass UserModel(db.model): pass 123456exts.py# 扩展插件from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() User模型创建现在models中设置好 123456789101112models.pyfrom exts import dbfrom datetime import datetimeclass UserModel(db.Model): __tablename__ = &quot;user&quot; id = db.Column(db.Integer,primary_key = True,autoincrement=True) username = db.Column(db.String(100),nullable = False) password = db.Column(db.String(100), nullable=False) email = db.Column(db.String(100), nullable=False,unique = True) # 账号加入时间 join_time = db.Column(db.DateTime,default = datetime.now) 在config.py中设置好数据库连接信息 12345678910111213# MySQl所在的主机名HOSTNAME = &quot;127.0.0.1&quot;#MySQl监听的端口号PORT = &quot;3306&quot;#连接MySQl的用户名是用户自己设置的USERNAME = &quot;root&quot;#连接数据库的密码PASSWORD = &quot;1111&quot;# 数据库中创建的数据库名称DATABASE = &quot;qa&quot;DB_URI = &quot;mysql+pymysql://{}:{}@{}:{}/{}?charset=utf8mb4&quot;.format(USERNAME,PASSWORD,HOSTNAME,PORT,DATABASE)SQLALCHEMY_DATABASE_URI = DB_URI 然后在app.py中操作flask_migrate连接和更新数据库 网页文件和静态文件准备注册功能邮箱验证功能安装flask邮箱支持 1pip install falsk-mail 表单验证","link":"/2023/11/15/Flask%E5%AE%9E%E6%88%98-QA%E5%B9%B3%E5%8F%B0/"},{"title":"JavaScript","text":"基本知识浏览器执行js浏览器分成两部分 渲染引擎和js引擎 渲染引擎：用来解析html和css，称为内核。chrome的内核为blink js引擎：js解释器，读取网页中的js代码，对其处理后运，Chrome的为v8 js组成 ECMAScript是标准化的编程语言，标准语法 DOM(Document Object Model，文档对象模型),处理可扩展标记语言的标准编程接口，通过DOM提供的接口可以对页面上的各种元素进行操作。 BOM（Browser Object Model，浏览器对象模型），提供独立于内容的。可以和浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，如弹出框，控制浏览器跳转，获取分辨率。 js三种书写位置 行内式 1&lt;input type=&quot;button&quot; value=&quot;button&quot; onclick=&quot;(alert('提示'))&quot;&gt; 内嵌式 123&lt;script&gt; alert('提示')&lt;/script&gt; 外部引用 在头部使用链接引用js文件 js注释 单行注释/注释内容/ 多行注释/*注释内容*/ js输入输出 方法 描述 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 变量声明变量12345&lt;script&gt; // 声明变量 var age;//var（variablle）声明变量的关键词 var age = 18;//变量初始化&lt;/script&gt; 使用变量获取输入12345&lt;script&gt; // 声明变量 var age = prompt('your name');//var（variablle）声明变量的关键词alert(age) //输出&lt;/script&gt; 声明多个变量123456&lt;script&gt; //（只需要第一个`var`） var name = 'liu' age = 18 address = 'sw'&lt;/script&gt; 变量命名规则 数据类型javascript是一种弱类型语言，不用提前声明变量的类型，在程序运行过程中，类型会被自行锁定。 简单数据类型(值类型) 数据类型 描述 默认值 number 数字型，包括整型和浮点型 0 boolean 布尔型 false string 字符串 “” undefined 声明变量但是没有给值 undefined null 空 null isNaN()函数判断变量是否是数字型的 字符串类型字符串转义符 转义符 描述 \\n 换行符 \\\\ 斜杠 \\‘ 单引号 \\t tab缩进 \\b 空格 \\“ 双引号 字符串长度1alert(name.length)//length属性返回字符串的长度 字符串拼接 字符串可以通过➕相加 通过浏览器中打印变量值的颜色判断数据类型 从上到下依次为 数字型 字符串 布尔型 为定义 空 数据类型转换转换为字符串 方法 描述 案例 toString() 转为字符串 num.toString() String()强制类型转换 转为字符串 String(num) 加号拼接字符串 和字符串拼接的结果都是字符串 num + “字符串” 转换为数字型parseInt 方法 描述 案例 parseInt(string) 将string类型转为整数类型，后有单位舍去 parseInt(“12”) parseFloat(string) 将string类型转为浮点数类型 parseFloat(“12”) Number() 将string类型转为数值型 Number(‘12’) js隐式转换(- * /) 通过运算符 ‘12’ +12 转换为布尔型 方法 描述 案例 Boolean() 其他类型转换为布尔类型函数 Boolean(“true”) 0,NaN,null,undefined等会被转为空，其他的转为true 运算符浮点数的精度问题浮点数的最高精度是17小数，但是子啊进行算数计算时候精度不如整数。 递增（减）运算符123var age;age++; //后置递增运算符++age; //前置递增运算符 比较运算符 符号 描述 案例 == 判等号（会转型），默认转换字符型为数字型 18 = ‘18’ true === !== 要求等号的两边的数值和 18 = ‘18’ false 逻辑运算符逻辑运算符是对布尔值进行运算的符号，返回值也是布尔值 符号 描述 &amp;&amp; 逻辑与，要求条件全部成立 || 逻辑或，要求条件至少一个成立 ! 逻辑非，条件反置 逻辑中断（当有多个表达式时候，左边的表达式值可以确定结果时，就不在继续运算右边的表达式的值） 例如逻辑与计算0&amp;&amp;123当计算到0时候，由于是与计算，必定返回0，所以123不必计算 赋值运算符 符号 描述 案例 = 直接赋值 var age = 10; +=，-= 加减后赋值 var age = 10; age+=5; 先加后赋值 *=，/=，%= 乘除取模后赋值 var age = 2 ; age*=5;先乘后赋值 运算符优先级 流程控制和分支结构流程控制 顺序结构 分支结构 循环结构 if分支语句1234567&lt;script&gt; if (条件表达式) { //执行语句1 } else { //执行语句2 }&lt;/script&gt; 多分支语句1234567891011&lt;script&gt; if (条件表达式1) { //执行语句1 } else if (条件表达式2) { //执行语句2 } else if (条件表达式3) { //执行语句3 } else { //执行语句4 }&lt;/script&gt; 三元表达式12345&lt;script&gt; var age = 10; var result = age &gt; 5 ? '大于' : '小于'; alert(result)&lt;/script&gt; switch语句123456789101112&lt;script&gt; switch(表达式){ case value1: //执行语句1 break; case value2: //执行语句2 brek; default: //执行语句3 }&lt;/script&gt; 表达式和value相等的情况是值和数据类型类型全等的时候 for循环123for (初始化变量;条件表达式;操作表达式) { //循环体} 初始化变量 用var声明一个变量 通常是作为计数器使用 条件表达式 决定每一次寻汗是否继续执行 是终止的条件 操作表达式 每次循环后执行的代码 常用于计数器变量更新 断点调试：05-断点调试_哔哩哔哩_bilibili while循环123while (条件表达式) { //循环体} 先执行条件表达式，如果结果为true，则执行循环体代码。 do while 123do {//循环体}while (条件表达式) continue 跳过本次循环 break 结束循环 数组数组就是一组数据的集合，存储在单个变量下的方式 123var arr = Array()//创建一个新的空数组var arr = [] var arr = [1,2,3]//数组中的数据类型不限 数组元素可以通过下标访问 数组长度使用数组的length属性来表示 12var num = [1,2,3];var len = num.length; 数组新增元素 修改数组长度 数组的长度是可以读写的，直接修改array.length可以直接修改数组长度 增加索引号的可直接添加元素 12var num = ['1', '2', '3']num[3] = 'new' 翻转数组num.reverse() 函数函数就是封装了一段可以重复执行的代码块，通过此代码块可以实现大量代码的重复使用 12345&lt;script&gt; function functionName(value1,value2){ //代码}&lt;/script&gt; 函数形参和实参个数不匹配形参：定义函数时候的变量 实参：调用时候使用的变量 123456789&lt;script&gt; function getSum(n1,n2){ console.lgo(n1+n2);}//按照形参形式取前两个实参getSum(1,2,3);//第二个新参无对应，类型为undefinedgetSum(1)&lt;/script&gt; 函数返回值如果函数没有设定返回值，默认返回undefined arguments的使用1234567&lt;script&gt; function test(){ console.log(arguments);}tset(1,2,3);&lt;/script&gt; arguments存储所有传入的实参，输出数据： 1Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ] 输出数据为伪数组，伪数组不是真正意义上的数组，只有函数才有arguments对象（只能在函数中使用），而且每个函数都内置（不用定义） 具有数组的length属性 按照索引的方式进行存储 没有真正数组的一些方法 pop(),push() 可以按照数组的方式来遍历伪数组 函数的声明方式 关键字function声明函数 函数表达式 12345&lt;script&gt; var functionName = function(value1,value2){ //表达式 };&lt;/script&gt; 作用域作用域：代码名字在某个范围内起作用和效果，只要是变量就有作用域 全局作用域：全局变量 局部作用域：局部变量 预解析js引擎执行js氛围两步：预解析和代码执行 预解析js引擎会把js里面所有的var 和function提升到当前作用域的最前面 代码执行 按照代码的书写顺序从上往下执行 预解析分为 变量预解析（变量提升）和函数预解析（函数提升） 变量提升就是把所有的变量声明提升到当前作用域的最前面，不提升赋值操作 1234567alert(num);var num = 10;//实际执行代码var num;// num没有赋值，所以输出类型为undefinedalert(num);num = 10; 函数提升把所有的函数声明提升到作用域最前面 js对象对象：一个具体的事物，js对象是一组无序的相关属性和方法的集合 创建对象的三种方法利用字面量创建 1234567891011121314151617&lt;script&gt; var person ={ //属性 name: 'mike', age:18, // 方法 act: function(){ alert('hello there'); } } //调用属性的方法1 alert(person.name); //调用属性的方法2 alert(person['name']); //调用方法 person.act(); &lt;/script&gt; 利用new Object创建 1234567var ldh = new Object();ldh,name='liu';ldh.age = 18;ldh.sex = 'male';ldh.sing = function(song){ alert(song)} 构造函数创建对象 123456789101112131415function Star(name,age,sex){ //属性 this.name = name; this,age = age; this.sex = sex; //方法 this.sing = function (song){ alert(song) }}var ldh = new Star('liu',18,'female');//调用属性alert(ldh.name)//调用方法ldh.sing('thing'); 遍历对象1234for(var k in ldh){ console.log(k); console.log(ldh[k]);} 内置对象内置对象就是js自带的一些对象，供开发者使用，提供一些常用的或者是基本必要的功能。 查阅文档： MDN Web Docs (mozilla.org) Math对象Math - JavaScript | MDN (mozilla.org) 常用数学方法 对象 描述 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入 Math.abs() 绝对值 Math.max()/Math.min() 最大值 最小值 Math.random()随机数，返回一个随机的0～1的浮点数 日期对象1234&lt;script&gt; var date = new Date(); alert(date);&lt;/script&gt; 数字型'2019, 11, 01' 字符串'2019-11-01 8:8:8' 常用方法 格式化日期时分秒12345678910111213141516&lt;script&gt; function getTime() { var time = new Date(); //得到年份 var h = time.getHours(); h = h &lt; 10 ? '0' + h : h; //得到月份 var m = time.getMinutes(); m = m &lt; 10 ? '0' + m : m; //得到秒 var s = time.getSeconds(); s = s &lt; 10 ? '0' + s : s; return h + ':' + m + ':' + s;}alert(getTime());&lt;/script&gt; Data总的毫秒数（时间戳）现在的日期距离1970年一月一日总的毫秒数 12345678910&lt;script&gt; var date = new Date(); //第一种方法 console.log(date.valueOf()); console.log(date.getTime()); //第二种方法 var date1 = +new Date(); //返回的就是总的毫秒数 //第三种方法（h5新增方法） console.log(Date.now());&lt;/script&gt; 倒计时实例 123456789101112131415161718&lt;script&gt; function countDown(time) { var nowTime = + new Date();//返回当前时间总的毫秒数 var inputTime = +new Date(time);//返回用户输入时间总的毫秒数 var inputTime = inputTime - nowTime; sec = inputTime / 1000;//总的秒数 var day = parseInt(sec / 60 / 60 / 24);//返回天数 day = day&lt;10?'0'+day:day; var hour = parseInt(sec / 60 / 60 % 24);//返回小时 hour = hour&lt;10?'0'+hour:hour; var minute = parseInt(sec / 60 % 60);//返回分钟 minute = minute&lt;10?'0'+minute:minute; var second = parseInt(sec % 60);//返回秒数 second = second&lt;10?'0'+second:second; return day + '天' + hour + '小时' + minute + '分钟' + second + '秒';//返回倒计时 } console.log(countDown('2024-1-1 18:00:00'));&lt;/script&gt; 数组对象创建数组的两种方法 利用字面量方法 1var arr = [1,2,3] 利用new Array() 1var arr = new Array(2);//创建了一个空的数组，数组中含有两个空元素，数组长度为2 检测是否为数组的两种方式 使用instanceof 1234var arr = [];//定义一个数组var obj = {};//定义一个对象console.log(arr instanceof Array);//返回trueconsole.log(obj instanceof Array);//返回false 使用arr.isArray() 优先使用第一种方法，第二种方法是h5新增，ie9以上才支持。 添加删除数组元素 方法 描述 返回值 push(value1,value2…) 末尾添加一个或者多个元素，注意修改元数组 返回新的长度 pop() 删除数组尾部的一个元素，一次只能删除一个 返回删除的元素的值 unshift(value1,value2…) 在数组前面添加元素 返回新的长度 shift() 删除数组的第一个元素，数组长度减一 返回删除的元素的值 数组排序 方法 描述 是否支持修改原数组 reverse() 颠倒数组中元素的顺序 改变原来的数组 返回新数组 sort() 对数组中的元素进行排序 改变原来的数组 返回新数组 sort方法 12345var arr = [1,2,3,4,7,6];arr.sort(function(a,b){ return b-a;//降序排列})alert(arr)// 默认升序排列 数组索引方法 方法 描述 返回值 indexOf() 数组中查找给定元素的第一个索引 如果存在，返回索引号否则返回-1 lastindexOf() 在数组中的最后一个索引 如果存在，返回索引号否则返回-1 1indexOf('要查找的字符',[起始的位置]);//lastindex()也是如此 🌟数组去重案例算法：拿着旧数组去新数组去查询新数组，如果改元素在新数组中则添加，否则不添加。 12345678var arr = [1,3,5,7,8,3,3,1];var newArr = [];for(i=0;i&lt;arr.length;i++){ if(newArr.indexOf(arr[i])===-1){ newArr.push(arr[i]); }} console.log(newArr) 数组转换为字符串 使用tostring()方法 使用join(分隔符) 字符串类型本来基本数据类型是没有属性和方法的，对象才有属性和方法 基本包装类型：把简单的数据类型包装成为了复杂数据类型，这样基本数据类型就有了属性和方法了，js中有三个特殊的引用类型： String Number Boolean 123456789var str = 'andy';console.log(str.length);//生成临时变量，用存储对象Stringvar temp = new String('andy');//将生成的对象赋值给strstr = temp;//销毁临时变量temp = null; 根据字符返回位置方法同数组的返回下标。数组 根据位置返回字符 方法 描述 使用 charAt(index) 返回指定位置的字符 str.charAt(0) charCodeAt(index) 获取指定位置字符的ascll编码 str.charCodeAt(0) str[index] 回去指定位置字符 h5，ie8以上支持 拼接截取字符串 方法 描述 concat(str1,str2…) 多用于链接两个或者多个字符串，等效于字符串相加，更常用字符串相加 substr(start,length) 从start位置开始，length取的是整数 slice(start,end) 从start开始，到end位置，end取不到 substring(start,end) 从start开始，截取到end位置，基本和slice相似，但是不接受负值 字符串转换为数组12var str = 'red,blue,green';alert(str.split(',')); //以，为分割符将字符串分割为数组 复杂数据类型和简单数据类型 简单数据类型 是存放在栈里的，里面直接开辟一个空间存放值 复杂数据类型 首先在栈里放地址 十六进制表示 ，然后这个地址指向堆里的数据 简单数据类型传递值，复杂类型传递的是存储堆中的地址 web Apiweb Api是浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) DOM（Document Object Model,文档对象模型），是W3C组织推荐的处理HTML的标准编程接口 DOM树 文档：一个页面就是一个文档，DOM中使用document表示 元素：页面中的所有标签都是元素，DOM中使用element表示 节点：网页中所有内容都是节点（标签，属性，文本，注释），使用node表示 DOM把以上内容都看作是对象 获取页面元素 根据ID 12345&lt;div id=&quot;time&quot;&gt;2019&lt;/div&gt;&lt;script&gt; //因为HTML文档是从上往下加载的，所以先得有标签，所以我们script写在标签下 var time = document.getElementById('time'); //返回的是一个元素对象&lt;/script&gt; 根据标签名 12345678910111213&lt;div&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/div&gt;&lt;script&gt; //返回的是 获取过来的元素对宪法的集合 以伪数组的形式存在 var lis = document.getElementsByTagName('li'); //如果该标签只有一个或者0个，则返回一个伪数组或者空的伪数组console.log(lis);&lt;/script&gt; 还可以获取某个元素（父元素）内部所有指定标签名的子元素 12345678910111213&lt;ol&gt; &lt;li&gt;1&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // element.getElementsByTagName(); var ol = document.getElementsByTagName('ol'); //注意得到的ol是伪数组，使用下标访问为数组中的元素对象 var li = ol[0].getElementsByTagName('li'); console.log(li);&lt;/script&gt; H5新增方法 根据类名返回 1element.getElementByClassName('box');//返回对象集合 根据选择器返 1234//返回第一个对象var li = document.querySelector('li')//标签选择器var vav = document.querySelector('#nav')//id选择器//使用querySelectorAll('选择器')；返回指定选择器的所有元素对象集合","link":"/2022/06/14/JavaScript/"},{"title":"MySQL","text":"MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 https://blog.csdn.net/qq_48584557/article/details/130456706 MySQl安装和基本使用安装教程：MySQL 8.0保姆级下载、安装及配置教程（我妈看了都能学会）_哔哩哔哩_bilibili 使用Mariadb，安装需要设置编码为UTF-8，管理用户设置为root，密码设置为1111 下载地址：Download MariaDB Server - MariaDB.org MySQL的数据类型 类型 描述 int 整型 bigint 长整型 float 浮点型 double 浮点型 datetime 日期类型 timestamp 日期类型（可存储时间戳） char 定长字符 varchar 不定长字符 text 大文本，用于存储很长的字符内容 blob 字节数据类型，存储图片，音频等文件 建表操作语法1234567-- 删除表DROP TABLE IF EXISTS tabelename;-- 新建表creat tabel tablename( 字段名 类型 约束 (主键,非空,唯一,默认值) 字段名 类型 约束 (主键,非空,唯一,默认值))编码,存储引擎; 在SQL中，我们有如下约束: NOT NULL:指示某列不能存储NULL值。 UNIQUE :保证某列的每行必须有唯一的值。 PRIMARY KEY :NOT NULL和UNIQUE的结合。确保某列(或两个列多个列的结合)有唯一标识， 有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY :保证- 个表中的数据匹配另一 个表中的值的参照完整性。 CHECK :保证列中的值符合指定的条件。 DEFAULT :规定没有给列赋值时的默认值。 实例12345678910DROP TABLE IF EXISTS websites;CREATE TABLE websites( id int(11) NOT NULL AUTO_INCREMENT, name char(20) NOT NULL DEFAULT '' COMMENT ' 站点名称', url varchar(255) NOT NULL DEFAULT '', alexa int(11) NOT NULL DEFAULT '0' COMMENT '排名', sal double COMMENT '广告收入', country char(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY(id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入删除更新插入语句1INSERT INTO websites(NAME,url,alexa,sal,country)VALUES('腾讯','https://www.qq.com',18,1000,'CN'); 删除语句1DELETE FROM websites WHERE id = 2; 更新语句1UPDATE websites SET sal =NULL WHERE id =1; 基本select查询语句创建一个表 123456789101112131415161718192021222324252627282930313233DROP TABLE IF EXISTS websites;CREATE TABLE websites( id INT(11) NOT NULL AUTO_INCREMENT, name CHAR(20) NOT NULL DEFAULT '' COMMENT ' 站点名称', url VARCHAR(255) NOT NULL DEFAULT '', alexa INT(11) NOT NULL DEFAULT '0' COMMENT '排名', sal DOUBLE COMMENT '广告收入', country CHAR(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY(id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO websites VALUES (1,'Google', 'https ://www. goog1e.cm/','1',2000,'USA'), (2,'淘宝', 'https://www. taobao .com/','13',2050,'CN'), (3,'菜鸟教程','http://www. runoob.com/', '4689',0.0001, 'CN'), (4,'微博','http://weibo.com/', '20',50, 'CN'), (5,' Facebook', 'https://www. facebook .com/','3',500,'USA');CREATE TABLE If NOT EXISTS access_log ( aid INT(11) NOT NULL AUTO_INCREMENT, site_id INT(11) NOT NULL DEFAULT '0' COMMENT '网站id', COUNT INT(11) NOT NULL DEFAULT '0' COMMENT '访问次数', DATE DATE NOT NULL, PRIMARY KEY (aid) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO access_log (aid,site_id, COUNT, DATE) VALUES (1, 1, 45,'2016-05-10'), (2,3,100, '2016-05-13'), (3,1, 230, '2016-05-14'), (4, 2, 10, '2016-05-14'), (5,5,205, '2016-05-14'), (6,4,13, ' 2016-05-15'), (7,3,220, ' 2016-05-15'), (8,5,545, '2016-05-16'), (9,3,201, '2016-05-17'), (10, 88,9999, ' 2016-09-09'); 查找全部信息12-- 一般不使用*查找全部SELECT id ,NAME ,url,alexa,sal,country FROM websites 分页查询 mysql的分页查询是最优雅的 1234-- 从下标为2开始查找，查找三条SELECT * FROM websites LIMIT 2,3;-- 从最开始查找，查找三条SELECT * FROM websites LIMIT 3; distinct关键字 distinct用于返回唯一不同的值 12-- 返回多个相同的国家，distinct关键字合并相同的返回值SELECT distinct country FROM websites where语句 作为条件筛选，运算符：&gt;&lt;= , is NULL, is not NULL 因为在sql语句中null和任何东西相比较都是假，包括它本身 like in 逻辑条件and，or1234SELECT * FROM websites WHERE sal &gt;=0 AND sal &lt;=200;SELECT * FROM websites WHERE sal BETWEEN 0 AND 2000;SELECT * FROM websites WHERE sal &lt;5 OR sal IS null order by12-- 先按照sal升序排列，然后按照alexa降序排列SELECT * FROM websites ORDER BY sal ASC , alexa DESC; like和通配符模糊查找 12345-- 多个字符0多个字符SELECT * FROM websites WHERE NAME LIKE '%o%'-- 一个字符0多个字符SELECT * FROM websites WHERE NAME LIKE '_o%' in12-- 从国家是CN或者是CA选中SELECT * FROM websites WHERE country IN ('CN','CA') 别名12-- tt是websites的别名 销量是tt.sal的别名SELECT tt.sal &quot;销量&quot; FROM websites tt Group by分组查询 注意：分组的时候沙宣使用having 常见的几个组函数：max() min() avg() count() sum() 1SELECT AVG(sal) &quot;average&quot; FROM websites GROUP BY country HAVING average &gt; 1000 子查询 嵌套查询 1SELECT id FROM websites WHERE NAME IN (SELECT NAME WHERE sal &gt; 2001) 连接查询1234SELECT * FROM websites w JOIN access_log a -- 两表相关联ON w.id = a.site_id -- 关联条件WHERE sal &gt; 2000 -- 筛选条件 Null处理函数1ifull(date,'无') --如果数据为null 显示为无 经典练习","link":"/2023/02/24/MySQL/"},{"title":"Hexo博客搭建","text":"安装nodejs 官网下载 利用nodejs的包管理器npm安装国内镜像cnpm 1sudo npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm安装hexo 1sudo cnpm install -g hexo-cli 创建一个文件夹，然后进入文件夹中初始化hexo 1hexo init 安装hexo部署插件 1cnpm install --save hexo-deployer-git hexo基本命令 1234hexo new &quot;postname&quot; 创建新的博文hexo s 本地启动博客预览hexo clean 清除临时文件hexo g 生成网页文件 Hexo使用主题（例：cactus） 主题的样本网页网址：https://www.takuzen.me/hugo-theme-cactus/ 主题的github：GitHub - probberechts/hexo-theme-cactus. 主题的详细配置见文章 标准new post的开头 123456title: Hexo博客搭建tags:- hexo搭建配置categories:- Hexodate: 2022-01-02 13:08:14 md格式参见 Markdown 教程 | 菜鸟教程","link":"/2022/01/17/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"Linux基本命令","text":"linux命令是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。 操作系统 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，便于使用，作为中间人，连接软件和硬件 Linux文件和目录 /bin[重点] (/usr/bin、/usr/local/bin） 是Binarv的缩写，这个目录存放着最经常使用的命令。 /sbin (/usr/sbin、/usr/local/sbin) s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home[重点] 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root[重点] 该目录为系统管理员，也称作超级权限者的用户主目录。 /boot[重点] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了26内核中新出现的一个文件系线。 /tmp 这个目录是用来存放一些临时文件的。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media[重点] linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt[重点] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。 默认为空。 /usr/local[重点] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。 /var[重点] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。 包括各种日志文件。 /selinux[security-enhanced linux]360 SELinux是一种安全子系统，它能控制程序只能访问特定文件。 文件和文件夹操作12#终端命令格式command [-options] [parameter] cd(change diectory) 切换到文件夹 12345- cd /home 绝对路径，以根目录开头- cd admin 相对路径，不以根目录开头，以文件名开头- cd .. 返回上一级目录- cd ~ 回到自己家的的目录，/home/damiin- cd - 返回上一步进入的文件夹 pwd(print work diectory) 查看当前所在文件夹 ls(list) 查看目录内容 1234567- ls -l 显示详细列表- ls -lh把文件大小以人性化的方式显示（如比特转换为kb）- ls -a 显示所有的文件，包含隐藏文件，隐藏文件是以“.”开头的文件touch .123.txt 创建隐藏文件- ls -lah - ls /home la 查看home中隐藏的文件列表 123drwxrwxr-x d代表文件夹 -代表文件rwx（文件拥有者的权限） rwx（文件拥有的组的权限 ） r-x（其他用户的权限） 通配符 通配符 解释 * 代表人任意个字符 ？ 代表任意一个字符，至少是一个 [] 掉膘可以匹配字符组中的任意一个 [abc] 匹配abc中的任意一个 [a-f] 匹配a到f范围内的任意一个字符 配合通配符使用 12- ls *txt 查看当前文件夹下以txt结尾的所有文件- ls 1* 查看以1开头的文件 mkdir 如果有要创建的文件夹重名，不要内需创建 (make diectory) 创建文件夹（相对路径，当前目录下创建文件夹） 1234567891011- mkdir /home/admin/(绝对路径）- mkdir /home/admin 如果上级目录不存在，加上-p自动创建父目录、- mkdir a b 在当前目录创建多个文件夹- mkdir a/{c,d}在指定目录下创建多个文件夹- mkdir .abc 以.开头 创建隐藏目录- mkdir -p a1/b1/c1/d1 递归创建多个目录 touch 如果文件不存在，创建空文件。如果文件存在，修改文件的末次修改日期 12345- touch abc.txt 在当前目录下创建 如果指定了目录，必须保证上级目录存在- touch .abc 创建隐藏文件- gedit abc.txt使用记事本打开文本 rm 删除文件 1234567- rm a.txt 删除文件- rm -r abv 删除目录- rm -f 强制删除，忽略不存在的文件，没有提示- rm * 删除当前目录下的所有内容 ，不能删除隐藏文件 . 和 .. 删除不掉 cp复制 12cp a.txt b.txtcp ~/Document/readme.txt . #将家目录下的readme文件复制到当前目录中 mer 描述 -a 该选项通常在复制目录时候使用，它保留链接，文件属性，并递归分复制目录，总之保留文件原有的属性 -f 覆盖已经存在的目标文件而且不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有目录和文件，目标文件必须为一个目录名 -v 显示拷贝进度 mv移动 123- mv 1.txt 2.txt 重命名- mv 1.txt 目录/2.txt 查阅命令帮助信息123456command --help#例如rm --help#或者使用manman rm 使用man时候操作键 操作建 解释 空格 显示手册下一页 Enter 一次滚动手册的一页 b 回滚一页 r 前滚一页 q 退出 /word 搜索word字符串 其它命令行重定向echo 1echo hello linux #输出命令hello linux 重定向 &gt;和&gt;&gt; 12345命令/文件 将命令返回的数据写入文件中，若命令没有返回则文件为空 echo hello linux &gt; 1.txt #将hello linux写入文件 ls -lh &gt; 1.txt #将ls查看内容输出到文件中 把命令返回的结果输出到文件中，会覆盖之前的数据，默认情况命令返回的结果是显示在屏幕中 ls &gt;&gt; 1.txt 把命令返回的结果输出到文件中，追加的方式 管道linux允许一个命令的输出通过管道作为另外一个命令的输入 123ls -al/ 显示根目录下的文件ls -al/ | more 使用more命令分屏显示前面命令返回的结果ls -al/ | grep D 搜寻根目录文件中含有D的文件 find查找文件12find /home -name 1.txt 在/home 目录中查找文件名为1.txt的文件find /home -name '*txt' 在/home 目录中查找以txt结尾的文件 ln 链接 软链接 序号 命令 解释 1 ln -s 被链接的源文件 软链接名 软链接只记住文件名，指向文件名的文件，不会管文件内容，类似快捷方式 12使用软连接时候要使用绝对路径，方便移动文件后链接能够正常使用sudo ln -s /home/mk310/softlink.txt /home/softlink2 硬链接 和软连接相比少了个 -s选项 12345硬链接本身占空间，相当于把源文件复制一份，与源文件同步变化，不能给目录创建硬链接使用ll查看时，有一个数字在，代表有几个文件能同步发生变化ln 1.txt 1.hard_link Ubuntu的软件安装apt apt是Advanced Packing Tool，是Linux下的安装包管理工具 可以在终端中安装卸载更新 123456#安装软件sudo apt install software#卸载软件sudo apt remove software#更新已经安装的包sudo apt upgrade 文件内容命令 catconcatenate（连接合并）查看文件内容 12345678#显示全部内容cat 1.txt把文件的内容全部显示到屏幕中cat 1.txt 2. txtcat 1.txt 2.txt &gt; 3.txt把多个文件的内容合并到新的文件中cat -b 1.txt #显示文件内容的行数 more 1.txt #可以分屏显示 适合内容多的 查看操作和man相同 grep文本搜索LInux系统中grep命令是一个强大的文本搜索工具，grep允许对文本文件进行模式查找，如果找到匹配模式，grep打印包含模式的所有行 1grep [-选项] '搜索内容串' 文件名 在grep命令中输入字符串参数时候，最好引号扩起来 1grep 'a' 1.txt 选项 描述 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式 参数 描述 ^a 行首，搜寻以a开头的行：grep -n '^a' 1.txt end$ 行尾，搜寻以end结束的行：grep -n 'end$' 1.txt [Ss]igna[Ll] 行首行尾忽略大小写 . (点)匹配一个非换行符的字符; 匹配e和e之间有任意一个字符，可以匹配 eee，eae.eve，但是不匹配 ee，eaae; grep -n e.e’ 1.txt 远程管理命令关机重启 命令 描述 reboot 重新启动操作系统（不需要权限） shutdown -r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20:25 系统在今天的20:25关机 shutdown -h +10 系统在输入命令后十分钟自动关机 shutdown -c 取消关机 网卡信息命令 命令 释义 作用 ifconfig configure a network interface 查看和配置网卡配置信息 ping ip ping 检测到目标ip地址的连接是否正常 查看网卡对应的ip地址 ifconfig | grep inet 检测本地网卡是否正常 ping 127.0.0.1 SSh(secure shell)常见服务端口号列表： 服务 端口号 SSH服务器 22 web服务器 80 HTTPS 443 FTP 21 SSH简单使用 1ssh [-p port] user@remote uer是在远程服务器上的用户名 ，不指定默认就是当前用户 remote是远程机器的地址，可以是ip/域名，或者是别名 port是SSH Server监听的端口，如果不指定，默认22 使用exit退出当前用户的登录 ssh免密码登录 12345ssh-keygen #在.ssh文件夹下生成id_rsa 和 id_rsa.pub 文件ssh-copy-id mk310@172.168.0.109 #将授权文件送到远程服务器#之后不用输入密码就可以登录 配置别名 在.ssh/config中追加一下内容： 1234Host nickname HostName 192.168.0.101 User mk310 port 22 之后可以使用ssh nickname可以直接登录远程服务器 scpsecure copy 远程拷贝命令 123456789101112#将远程加目录下Desktop/1.py复制到本地目录下scp -P port user@remote:Desktop/1.py 1.py#把本地当前目录下的1.py文件复制到远程家目录下的Desktop/1.pyscp -P port 1.py user@remote:Desktop/1.py#加上-r可以传送文件夹#把当前目录下的demo文件夹复制到远程家目录下的Desktopscp -r demo user@remote:Desktop#把远程家目录下的Desktop 复制到当前目录下的demo文件夹中scp -r user@remote:Desktop demo 用户权限命令 who查看登陆用户信息 选项 描述 -q –count 只显示用户的登录账号和登录用户的数量 -u –heading 只列标题 chown修改文件/文件夹所有者 1sudo chown zhangsan python/ #将python文件所有者换为张三 chgrp 修改文件/文件夹所在组 1sudo chgrp -R zhangsan python/ #将python文件所在组换为张三，-R对文件夹递归操作 chmod修改文件权限 chmod修改文件权限有两种格式：字母法和数字法 1字母法：chmod u/g/o/a +/-/= rwx 文件 参数 描述 u user表示该文件的所有者 g group表示与该文件所有者一组的，即用户组 o other表示其他意外的人 a all表示这三者皆是 参数 描述 + 增加权限 - 减少权限 = 设定权限 参数 描述 r read 表示可以读取，没有r权限非可读 w write可写入权限 x excute可执行权限 数字法 参数 描述 r 代号4 w 代号2 x 代号1 - 代号0，不具备任何权限 1执行 chmod u = rwx,g = rx,o-f filename 相当于 chmod u = 7,g = 5,o = 4 filename 用户管理命令创建/设置密码/删除用户 序号 命令 作用 说明 01 useradd -m -g 组新建用户名 添加新用户 -m 自动建立用户家目录 -g指定用户所在的组，否则会建立一个和用户名同名的组 02 passwd 用户名 设置用户密码 普通用户可以直接用passwd修改 03 userdel -r 用户名 删除用户 -r 选项会自动删除家目录 04 cat /etc/passwd |grep 用户名 确认用户信息 新建用户信息保存在passwd文件 查看用户信息 序号 命令 解释 1 id username 查看用户UID和GID信息 2 who 查看当前所有登录的用户列表 3 whoami 查看当前登录用户的账户名 /etc/passwd存放的是用户信息： 用户名 密码（x表示加密） UID GID（组标识） 用户全名和本地账号 家目录 用户登录使用的Shell which查询命令在系统中的保存位置 /etc/passwd是用于保存用户信息的文件 /usr/bin/passwd是用于修改用户密码的程序 bin和sbin 在linux中大多数可执行文件保存在/bin /sbin /usr/bin /usr/sbin /bin（binary）是二进制执行文件目录，用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin （user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 su切换用户 序号 命令 作用 解释 1 su -username 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 2 exit 退出当前登录账户 系统信息命令时间date和cal 序号 命令 解释 1 date 查看系统当前时间 2 cal calendar 查看日历，-y选项可以查看一年的日历 磁盘信息 序号 命令 解释 1 df -h disk free 显示磁盘剩余空间 2 du -h 【目录名】 disk usage显示目录下的文件大小 进程信息 序号 命令 解释 1 ps aux process status 查看进程详细状况 2 top 动态显示运行中的进程并且进行排序 3 kill [-9] 进程代号 种植指定代号的进程 -9表示强行终止 ps默认只会显示当前用户通过终端启动的应用程序 选型 解释 a 显示终端上所有的进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 压缩命令 tar打包命令（没有压缩）12345678打包tar cvf a.txt *.txt解包tar xvf a.tar -C atar列出出档案内的名称tar tf tarName.tar tar很特殊，其参数前面可以使用-也可以不使用 参数 描述 -c 生成档案文档，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称 -t 列出档案中包含的文件 -x 解开档案文件 gzip文件压缩12345压缩打包后的文件gzip -r tarName.tar解压缩gzip -d tarName.tar.gz tar命令和gzip命令结合 1234一步打包压缩tar czf name.tar.gz *txt一步解压缩到指定文件夹tar xzf name name.tar.gz -C dciName bzip2文件压缩1234一步打包压缩tar cjf name.tar.gz *txt一步解压缩tar xjf name name.tar.gz -C dciName zip unzip 文件压缩1234压缩文件zip -r zname *txt将zname压缩到zz文件夹中unzip -d zz zname.zip 压缩率：zip&lt;gzip&lt;bzip2，zip最通用 其他命令编辑器Vim","link":"/2023/02/07/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"title":"cactus主题的使用配置","text":"创建标签页，分类页，搜索页以标签页为例子 1hexo new page tags 进入创建的tags文件夹中，将index.md中的title中添加type:tag 创建搜索页 1hexo new page search 进入创建的tags文件夹中，将index.md中的title中添加type:search.同时安装本地搜索插件 hexo-generate-search 1cnpm install hexo-generator-search --save 主题配置文件主要选项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139############################################################################### Content############################################################################### Link to a page that gives an overview of all your projects.# This can be an external link (e.g., to you GitHub profile) or to another# page within your website.#链接到giteeprojects_url: http://gitee.com# Set the page direction to RTL or LTR. default is LTR. (if you set it 'rtl', the 'vazir' font will be loaded.)#菜单栏在左（ltr），右（rtl）direction: ltr# Configure the navigation menu.# A pair 'Key: url' will result in a link to 'url' with the name 'Key' in the# navigation menu. Optionally, you can add translations for the 'Key' in# languages/*.yml#导航栏设置nav: home: / articles: /archives/ category: /categories/ tag: /tags/ search: /search/ about: /about/ projects: http://gitee.com/# Links to your social media accounts.# The keys should correspond to Fontawesome icon names# (see https://fontawesome.com/icons?d=gallery&amp;s=brands);# only 'mail' is an exception.#社交媒体账号social_links: github: http://gitee zhihu: https://zhuanlan.zhihu.com/ magnifying-glass: https://www.baidu.com/ mail: https://mail.qq.com/# Customize the overview with displaying a tagcloud on the index page.# Options: https://hexo.io/docs/helpers.html#tagcloud# 在首页显示文章，生成tag云tags_overview: true# Customize the overview with the most recent blog posts on the index page.# Options:# - show_all_posts: whether to show all available posts.# - post_count: whether to show only the x most recent posts.# - sort_updated: sort posts by last modification date instead of creation date.posts_overview: show_all_posts: false post_count: 5 sort_updated: true# Customize the archive view.# Options:# - sort_updated: sort posts by last modification date instead of creation date.# Note: this does not work together with pagination, since the pagination# plugin will sort pages by date of creation.#归档中的文章按照更新日期排序archive: sort_updated: true# Customize the article view.# Options:# - show_updated: show the last modification date.#显示修改日期post: show_updated: true# Customize the copyright years# Note: if start_year/end_year not provided, will use current year.copyright: start_year: 2018 end_year: 2023# Customize the 404 page# Options:# - enabled: whether to enable the 404 page (404.html).#定义404页error_404: enabled: true title: &quot;404 Page Not Found&quot; description: &quot;The page you are looking for might have been removed, had its name changed, or is temporarily unavailable.&quot;############################################################################### Look and Feel############################################################################### Customize the logo (i.e., the cactus) in the header.# Options:# - enabled: whether to show (true) or hide (false) the logo.# - width: width of the logo in pixel units# - height: height of the logo in pixel units# - url: where the logo can be found# - gravatar: whether to use your Gravatar as the logo# - grayout: whether to enable a hover effect on the logo# 图标显示logo: enabled: true width: 50 height: 50 url: /images/logo.png gravatar: false grayout: true# Customize the favicons.# Cactus supports a limited set of the three most important icons:# - desktop: The classic favion.ico file.# - android: A 192x192 PNG file.# - apple: A 180x180 PNG file.# These can be generated with http://realfavicongenerator.net/# Options:# - url: where the icon can be found# - gravatar: whether to create a favicon from your Gravatarfavicon: desktop: url: /images/favicon.ico gravatar: false android: url: /images/favicon-192x192.png gravatar: false apple: url: /images/apple-touch-icon.png gravatar: false# The color scheme that should be used to highlight codeblocks.# See source/css/_highlight for a list of all available color schemes.#代码高亮，样式在主题文件夹中highlight: idea# Set the color scheme.# Available color schemes are 'dark', 'light', 'classic' and 'white'.# Alternatively, add your own custom color scheme to source/css/_colors.# 页面显示颜色：黑色 灰色 米黄色 白色colorscheme: classic# Maximal width of the page in rem units.page_width: 48 Hexo基本信息配置站点名称语言 12345678# Sitetitle: Hexosubtitle: ''description: ''keywords:author: mk310language: zh-CNtimezone: '' gitee部署 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git branch: master repo: https://gitee.com/SmashDog1/SmashDog1 配置邮箱和用户名 12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 使用hexo d命令部署，然后会提示用户名和密码输入后上传成功","link":"/2023/01/17/cactus%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"},{"title":"css","text":"css(Cascading Style Sheets)层叠样式表 前言及代码规范123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p { color: red; font-size: 12px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 代码规范测试 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ⭐css基础选择器标签选择器12345678 /* 定义p标签的颜色和文字大小 */&lt;style&gt; /* 标签选择器 在样式表中声明p标签的属性 */ p { color: red; font-size: 12px; }&lt;/style&gt; 缺点：声明标签属性后，所有的p标签都会改变 类选择器(最常用)样式表定义 1234567/* 定义class='red'的标签的样式 */ &lt;style&gt; /* 类名不能使用标签关键字 */ .red { color: rgb(255, 0, 38); }&lt;/style&gt; html引用 123&lt;div class=&quot;red&quot;&gt; 类选择器&lt;/div&gt; 类名命名规范 CSS命名规则规范整理 - 走看看 (zoukankan.com) 类选择器-多类名123456789101112131415&lt;style&gt; .red { color: rgb(255, 0, 38); } .font32 { font-size: 32px; }&lt;/style&gt;&lt;body&gt; &lt;!--同时调用red 和 font32两个类的样式--&gt; &lt;div class=&quot;red font32&quot; &gt; 多类名 &lt;/div&gt;&lt;/body&gt; id选择器123456789101112/* 定义id='pink'的标签的样式 */ &lt;style&gt; #pink { color: pink; }&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;pink&quot; &gt; id选择器 &lt;/div&gt;&lt;/body&gt; 注意：id选择器同类选择器不同，只能调用一次，别人禁止使用,id应该是唯一的,经常和js搭配使用 通配符选择器12345&lt;style&gt; * { color: pink; }&lt;/style&gt; 声明了所有标签的属性 css文字属性字体系列1234567891011 &lt;style&gt; #font { font-family: &quot;微软雅黑&quot;; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;font&quot; &gt; id选择器 &lt;/div&gt;&lt;/body&gt; 注意：如果声明多个字体，顺序引用，避免目标计算机中缺少字体。由多个单词组成的字体名称用引号包裹。字体默认使用__微软雅黑__ 字体大小12345&lt;style&gt; #font { font-size: 32px; }&lt;/style&gt; 字体粗细12345&lt;style&gt; #font { font-weight: bold; }&lt;/style&gt; 也可以使用html中的文本属性来加粗字体 属性值 描述 normal 默认值（不加粗）400 bold 定义粗体 700 100-900 数字后面不跟单位 文字样式123456&lt;style&gt; #font { font-style: italic; 斜体 /*不是特殊字体用normal*/ }&lt;/style&gt; 字体复合属性12345&lt;style&gt; #font { font: font-style font-weight font-size/line-height font-family; }&lt;/style&gt; 各个属性的顺序不可改变 css文本属性文本颜色12345&lt;style&gt; #font { color: red; }&lt;/style&gt; 文本对齐只能设置水平对齐方式 123456&lt;style&gt; #font { /*本质是让盒子中文字位置变化,可选属性:right left center*/ text-align: center; }&lt;/style&gt; 文本装饰给文本添加上划线，下环线，删除线等 123456&lt;style&gt; #font { /* overline 上划线 underline 下划线 line-through 删除线 none 没有装饰*/ text-decoration: overline; }&lt;/style&gt; 文本缩进123456&lt;style&gt; p { /* em:当前文字的一个元素的大小 */ text-indent: 2em; }&lt;/style&gt; 文本行间距12345&lt;style&gt; p { line-height: 20px; }&lt;/style&gt; 声明文本行间距实际就是更改文本的上下间距 css的引入方式内部样式表12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; p { line-height: 20px; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;就是这样&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 内部样式表就是把所有的css写到style标签里，可以放置到html文件中的任何地方，一般放在head中 行内样式表123&lt;body&gt; &lt;p style=&quot;color: aqua;&quot;&gt;就是这样&lt;/p&gt;&lt;/body&gt; 在标签内使用style属性定义，适合修改简单的样式 外部样式表12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;address&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 将样式放在css文件中，然后在head中使用link引入css文件 属性 作用 rel 链接文档关系，stylesheet表示是样式表文件 href 定义外部样式表的url，可以是相对路径，也可以是绝对路径 路径相对路径 绝对路径 综合案例综合案例展示：新闻模版","link":"/2022/04/02/css/"},{"title":"css实例","text":"准备工作css属性书写顺序 页面布局整体思路 先确定页面的版心（可视区），由测量可知 分析页面中的行模块，以及每个航模块中的列模块（页面布局第一准则） 一行中的列模块经常浮动布局，线确定每个列的大小，之后确定列的位置（页面布局第二准则） 制作HTML，遵循先有结构，后有样式的原则 实例实现：阿里云盘分享 (aliyundrive.com) 子绝父相案例在li中添加em标签包含hot图标 12345678910&lt;li&gt; &lt;em&gt; &lt;img src=&quot;images/btn.png&quot; alt=&quot;&quot;&gt; &lt;/em&gt; &lt;img src=&quot;images/pic.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt;博客系统实战&lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt;•1132在学习 &lt;/div&gt;&lt;/li&gt; 子绝父相，em要使用绝对定位，li使用相对定位 123456789101112131415.box-bd ul li{ float: left; position: relative; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px;}.box-bd ul li em{ position: absolute; top: 0; right: 0;} 土豆网遮罩123456789101112131415161718192021222324252627&lt;style&gt; .box { /* 子绝父相 */ position: relative; width: 444px; height: 320px; margin: 30px auto; } .box img{ width: 100%; height: 100%; } .mask { position: absolute; top: 0; left: 0; display: none; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4) url(images/arr.png) no-repeat center; } .box:hover .mask{ display: block; }&lt;/style&gt;","link":"/2022/05/08/css%E5%AE%9E%E4%BE%8B/"},{"title":"css进阶","text":"Emmet语法快速生成html结构 需求 例子 方法 生成单个标签 生成div标签 div + tab键 生成多个相同的标签 生成三个div标签 div*3 生成父子关系的标签 ul标签 ul&gt;li 生成兄弟关系的标签 div 和 p标签 div+p 生成带有类/id标签 p 名demo/id two p.demo/p#two 生成div类名有顺序 生成demo1-demo5的标签 .demo$*5 标签中添加文本 div中文本 div{文本} 快速生成css结构关键字的首字母缩写 快速格式化代码调整文件中代码的空格，括号位置等，vscode中右键格式化文档 css复合选择器🌟后代选择器只改变父元素中的子元素 12345&lt;style&gt; ul li { color: aqua; }&lt;/style&gt; 上例中仅会改变ul中li标签的颜色，而不会改变ol中li标签的颜色 🌟子元素选择器12345&lt;style&gt; ul&gt;li { color: aqua; }&lt;/style&gt; 只会改变ul下一级的li标签的属性，而对于li的下一级标签属性无作用 🌟并集选择器并集选择器可以选择多组标签，同时为他们定义相同的样式。 123456&lt;style&gt; div, p { color: aqua; }&lt;/style&gt; p标签和div标签同时定义颜色 伪类选择器伪类选择器用于向某些选择器添加特殊效果，例如给链接添加特殊效果，或者选择第一个，第n个元素 123456789101112131415161718192021&lt;style&gt; /* 把没访问过的链接用特殊颜色标记出来 */ a:link { color: aqua; } /* 把已经访问过的链接用特殊颜色标记 */ a:visited { color: azure; } /* 鼠标经过时链接变色 */ a:hover { color: black; } /* 鼠标按下还未弹起的时候变换的特殊颜色 */ a:active { color: blue; }&lt;/style&gt; 注意： 为保证样式生效，按照上面的顺序定义 浏览器中都有默认样式，一般单独给a标签指定样式 focus选择器 12345&lt;style&gt; input:focus { background-color: aqua; }&lt;/style&gt; 被选中的input输入框显示特殊颜色 css元素显示模式块元素常见的块元素有 &lt;div&gt; &lt;ul&gt; &lt;ol&gt; 等 块元素的特点： 自己独占一行 高度，宽度，外边距，内边距都可以控制 宽度默认时容器的100% 是一个容器及盒子，可以放行内或者块元素 注意：文字类元素中不能放置块元素，例如 h和p标签中不能放置div标签 行内元素常见的行内元素有&lt;a&gt; &lt;strong&gt; &lt;em&gt;等 行内元素的特点： 相邻行泪元素在一行上，一行可以显示多个 高宽设置无效 默认宽度就是本身内容的宽度 行内元素只能容纳文本或者其他行内元素 注意： 链接里不能放链接 链接里可以放块元素，给&lt;a&gt;转换一下块模式更安全 行内块元素常见行内块元素有&lt;img&gt; &lt;input&gt; &lt;td&gt;等，兼具行内元素和块元素的特点： 和相邻的行内元素在一行上，但是之间会有空隙，一行可以显示多个（行内元素特点） 默认宽度就是内容宽度 高度 行高 外边距 内边距可以控制（块元素特点） 元素显示模式的转换（行内和块）比如想增加链接&lt;a&gt;的触发范围 12345678910111213141516&lt;style&gt; a { /* 把行内元素转换为块级元素 */ display: block; width: 150px; height: 50px; } div { /* 把块级元素转换为行内元素 */ display: inline; } span { /* 把行内元素转换为行内块元素 */ display: inline-block; }&lt;/style&gt; css背景背景颜色12/*默认颜色为 transparent 透明*/background-color: 颜色值; 背景图片实际常用于logo和一些装饰性的小图片 1234567&lt;style&gt; div { width: 400px; height: 400px; background-image: url(); }&lt;/style&gt; 背景平铺123456789&lt;style&gt; div { width: 4000px; height: 4000px; background-image: url(); /* repeat:纵向和横向都平铺 repeat-x:横向平铺 repeat-y:纵向平铺 no-repeat:不平铺 */ background-repeat: repeat-x; }&lt;/style&gt; 同时添加背景颜色和背景图片，图片的图层高于颜色 🌟背景图片位置1background-position: x y; x,y坐标可以是具体参数，也可以是方位名词 参数 描述 length 百分数/浮点数和单位组成的长度值 position top|center|bottom|left|center|right x,y还可以是混合单位，即具体值和方位词混用 背景固定例子qq网页I’m QQ - 每一天，乐在沟通,在拖动滚轮的时候，网页内容移动，但是网页背景 12/* fixed:背景固定 scroll:背景随内容滚动 */background-attachment: fixed; 背景属性复合写法按顺序填写 1background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置 背景半透明1background: rgba(0, 0, 0, 0.3) css的三特性层叠性相同选择器设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。层叠性的主要解决冲突的问题 层叠性原则： 样式冲突，遵循就近原则，那个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 继承性css中子标签会继承父标签的某些样式，如文本颜色和字号。 优先级 相同选择器，遵循层叠原则 不同选择器，按照权重来 ​ 选择器 权重 继承 0，0，0，0 元素标签选择器 0，0，0，1 类/伪类选择器 0，0，1，0 id选择器 0，1，0，0 行内样式表 1，0，0，0 important ∞ 1background-color: rgba(0, 0, 0, 0.3) !important; 使用important声明的属性优先级最高 注意： 如果继承的优先级为0，如果标签定义有样式表，则优先级高于其继承父标签的样式表 1234567891011121314 &lt;style&gt; #father { color: aqua; } p { color: azure; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 权重的叠加：定义范围更小的优先级高，如li的权重低于 ul li 盒子模型盒子模型组成 边框boreder 属性 描述 border-width 边框的粗细，单位px border-style 边框样式 solid 实线 dashed dotted 点线 border-color 边框颜色 1边框的复合写法 123456789&lt;style&gt; /* 边框的复合写法 */ #ll { border: 5px solid red; /* 上边框定义为蓝色 */ border-top: blue; }&lt;/style&gt; 2表格细线边框 12345678&lt;style&gt; table, td,th { border: 1px solid blue; /* 相邻边框合并 */ border-collapse: collapse; }&lt;/style&gt; 边框影响盒子的实际大小 内边距padding 属性 描述 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 Padding-bottom 下内边距 复合属性 值的个数 描述 padding: 5px 上下左右的内边距 padding: 5px 10px 上下5px 左右10px padding: 5px 10px 20px 上5px 左右10px 下20px padding: 5px 10px 20px 30px 上右下左的顺序 内边距影响盒子的实际大小 内边距不影响盒子实际大小的情况： ​ 定义的的属性中未声明宽度/高度 外边距margin 属性 描述 margin-left 左外边距 margin-right 有外边距 margin-top 上外边距 margin-bottom 下外边距 margin简写方式和padding方式一样 1-外边距让块级盒子水平居中 盒子必须指定宽度 盒子左右外边距设置为auto 12345678&lt;style&gt; div { width: 200px; background-color: aqua; margin: 20px auto; }&lt;/style&gt; 2-嵌套块元素的外边距塌陷问题 1234567891011121314&lt;style&gt; #father { background-color: aqua; width: 400px; height: 400px; margin-top: 20px; } #son { background-color: black; width: 200px; height: 200px; margin-top: 20px; }&lt;/style&gt; 外边距塌陷（子标签中的上边距没有作用） 解决方案： 定义父元素上边框 为父元素定义上内边框 为父元素添加overflow:hidden 3-清除内外边距 网页元素可能带有默认的内外边距，不同浏览器默认不同 1234567&lt;style&gt; /* 清除所有元素的内外边距 */ * { margin: 0; padding: 0; }&lt;/style&gt; 行内元素尽量只设置左右边距 案例：小米商品介绍 css3新加属性圆角边框123456789&lt;style&gt; div { width: 300px; height: 150px; background-color: aqua; /* 通过添加border-radius改变曲度 */ border-radius: 50%; }&lt;/style&gt; 呈现效果： 圆角的各个角的曲率可以设置 1border-radius: 50% 75% 30% 25%; 🌟盒子阴影1box-shadow: h-shadow v-shadow blur spread color inset 属性 描述 h-shadow 必需 水平阴影位置 可以负值 v-shadow 必需 垂直阴影位置 可以负值 blur 可选 模糊距离 spread 可选 阴影尺寸 color 可选 阴影颜色 Inset 可选 外部阴影改为内部阴影 文字阴影1text-shadow: h-shadow v-shadow blur color 属性 描述 h-shadow 必需 水平阴影位置 可以负值 v-shadow 必需 垂直阴影位置 可以负值 blur 可选 模糊距离 color 可选 阴影颜色 浮动 传统网页的三种布局：文档流，浮动流，定位流 为什么需要浮动：文档流不能改变元素的原有排列方式 网页布局第一准则：多个块级元素纵向排列找文档流，多个块级元素横向排列找浮动流 什么是浮动：创建一个浮动框，将声明元素移动到一边，直到左边缘或右边缘触及包含块或者另一浮动框的边缘。 1选择器 {float: 属性值 ;} 属性值 描述 none 元素不浮动（默认） left 元素向左浮动 right 元素向右浮动 🌟浮动特性 脱标，脱离标准普通流的控制，浮动到指定位置 浮动的盒子不在保留原先的位置 如果多个盒子都设置了浮动，那么他们会按照属性值一行显示并且顶端对齐排列 任何元素都可以浮动，不管原来是什么元素，添加浮动后都具有行内块元素相似的特性 浮动元素经常和标准流父级搭配使用先使用标准流的副元素排列上下位置，然后内部子元素采用浮动排列左右位置 一个元素浮动了，理论上其余的兄弟元素也要浮动，但是其未浮动兄元素不会被弟元素浮动所覆盖 浮动清除由于父盒子很多情况下不方便给高度，但是盒子浮动又不占位置，最后父级盒子高度为0时候，就会影响下面的标准流盒子。 如果父级盒子有高度，则不需要清除浮动 语法： 1选择器 {clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素 right 不允许右侧有浮动元素 both 同时清除两侧浮动影响 清除浮动方法1-额外标签法 在浮动元素和其后的标准流标签之间添加一个清除浮动的标签。（添加标签必须是块级元素） 2-overflow 1overflow: hidden 3-after伪类元素 12345.box1::after{ content: ''; display: block; clear: both;} 在clearfix后添加一个after的消除浮动的元素 4-双伪元素 12345678910.clearfix:before,.clearfix:after { content:&quot;&quot;; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 前后都进行消除浮动 定位 浮动可以让多个块级盒子没有缝隙排列显示，经常用于横向排列盒子 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子 定位 = 定位模式 + 边偏移 定位模式用于之指定一个元素在文档中的定位方式，边偏移则决定啦该元素的最终位置 定位模式通过css的position属性来设置 属性值 描述 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 边偏移 边偏移属性 实例 描述 top top: 80px 顶端偏移量，定义元素相对与其父元素上边线的距离 bottom bottom: 80px 底部偏移量，定义元素相对与其父元素下边线的距离 left left: 80px 左侧偏移量，定义元素相对与其父元素左边线的距离 right right: 80px 右侧偏移量，定义元素相对与其父元素右边线的距离 静态定位（很少用到）静态定位就是元素的默认定位方式，无定位的意思 静态定位按照标准流特性摆放位置，没有边偏移 相对定位（重要）相对位置是元素子啊移动位置的时候，是相对于它原来的位置来说的 1选择器 {position: relative;} 原来在标准流位置的位置继续占有，后面的盒子仍然以标准流的方对待 绝对定位（重要）绝对定位是元素在移动位置的时候，是相对于它的祖先元素来说的 1选择器 {position: absolute;} 绝对定位的特点： 如果没有祖先元素或者祖先元素没有定位，则以网页文档为定位（浏览器） 如果祖先元素有定位（相对，绝对，固定），则以最近一级有定位的祖先元素为参考移动位置 绝对定位不再占有原来的位置 子绝父相（重要）子级是绝对定位，父级要用相对定位 子级绝对定位，不会占有位置，可以放到父级盒子的任意位置，不会影响其他兄弟盒子 父级盒子需要加定位限制盒子在父级盒子内显示 父级盒子布局时，需要占有位置，父级盒子只能是相对定位 子绝父相案例： hot模块 固定定位（重要）固定定位是元素固定于浏览器可视区的位置，应用场景：浏览器页面滚动圆度的位置不会改变 1选择器 { position: fixed} 固定定位的特点： 以浏览器的可视窗口为参照点移动移动元素 跟父元素没有任何关系 不随滚动条滚动 固定定位不炸浓郁原先的位置（可以看作是一种特殊的绝对定位） 粘性定位（了解）粘性定位可以认为是相对定位和固定定位的混合 1选择器 { position: sticky;top: 10px} 粘性定位的特点： 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位的特点） 偏移值至少带上一个才会生效 跟页面关东搭配使用，兼容性较差，IE不支持 定位叠放次序在使用定位布局的时候，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序 1选择器 {z-index: 1;} 属性值可以是正数，负数或者0，默认是auto，数值越大盒子越往上； 如果属性值相同，则按照书写顺序，后来居上 只有定位的盒子才有z-index属性 定位补充绝对定位的盒子居中绝对定位的盒子不能通过 margin：auto水平居中的，但是可以通过定位的方式来居中 123456789101112&lt;style&gt; .box { position: absolute; /* 水平定位到父元素中线以右 */ left: 50%; /* 用外边距向右移动自身宽度的一半 */ margin-left: -100px; width: 200px; height: 200px; background-color: aqua; }&lt;/style&gt; 定位的特殊性绝对定位i和固定定位也和浮动相似 行内元素添加绝对或者固定定位，可以直接设置高度和宽度 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 绝对定位（固定定位）会完全压住盒子 浮动元素不同，只会压住他下面的标准流盒子，不会压住下面标准流盒子里的文字和图片 绝对定位（固定定位）会压住标准流所有的内容 浮动之所以不会压住文字，是因为浮动产生目的是创造文字环绕 元素的显示和隐藏1-display属性用于设置一个元素如何显示12- display: none; 隐藏对象- display:block; 除了转换为块级元素外，同时还有显示元素的意思 display隐藏元素后，不在占有原来的位置，应用极其广泛，搭配js可以做很多网页特效 2-visibility可见性visibility属性用于指定一个元素应可见还是隐藏 12- visibility：visible；元素可见- visibility：hidden；元素隐藏 visibility隐藏元素后，继续占有原来的位置 3-overflow溢出overflow属性指定了如果内容溢出一个元素的框时，会发生什么 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏 scroll 不管是否超出内容，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示 一般情况下，我们都不想让溢出部分显示，但是如果有定位的盒子，慎用，会隐藏多余的内容","link":"/2022/05/08/css%E8%BF%9B%E9%98%B6/"},{"title":"Git","text":"Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理 Git概述Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 Linus对新的系统制定了若干目标： 速度 简单的设计 对分线性开发模式的强力支持（允许成千上万并行开发的分支） 完全分布式 有能力高效管理类似LInux内核一样超大规模项目（速度和数据量） Git和SVN相比SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。 集中式版本控制工具缺点： 服务器单点故障 容错性差 GIT（Distributed Version Control System）即分布式版本控制系统，有两种类型的仓库,本地仓库和远程仓库。 本地仓库：是开发人员自己电脑上的GIT仓库 远程仓库：是远在服务器上的GIT仓库 Clone：克隆，将远程仓库复制到本地 Push：推送，将本地仓库代码上传到远程仓库 Pull：拉取，将远程仓库代码下载到本地仓库 Git工作流程 从远程仓库中克隆代码到本地仓库 从本地仓库中checkout代码然后进行代码修改 在提交代码前先将代码提交到暂存区 提交到本地仓库。本地仓库中保存修改的各个历史版本 修改完成后，需要和团队成员共享代码的时候，将代码push到远程仓库 GIT常用命令环境配置12345678设置用户配置信息git config --global user.name &quot;username&quot;git config --global user.email &quot;user@.com&quot;查看配置信息git config --listgit config user.name通过上面命令设置的信息会保存在~/.gitconfig文件中 获取GIT仓库使用git init命令新建一个本地仓库 使用git clone命令从远程仓库进行克隆，将远程仓库克隆到本地 库的概念和文件状态版本库：.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等 工作目录（工作区）：包含.git文件夹的目录就是工作目录，主要用于存放开发的代码 暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方 未跟踪（Untracked)：文件没有加入到git库中，不参与本本控制，使用git add变为暂存 已暂存（Staged）：标识对已经修改文件的当前版本做了标记，使之包含在下次提交的列表 已修改（Modified）：标识修改了文件，但没有将修改的结果放到暂存区 已提交（Unmodified）：标识文件已经安全保存在本地Git仓库中 查看文件状态12345678910111213141516查看文件状态git statusgit status -s 可以让输出结果更加简洁将未跟踪的文件添加到暂存区git add将暂存区中的文件取消暂存git reset将暂存区中文件修改提交到本地仓库git commit 删除文件 git rm 将文件添加到忽略列表： 有些文件无需纳入Git管理，在工作目录中创建一个.gitignore文件，列出忽略的文件模式 123456789101112#不跟踪所有以a结尾文件*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf 远程仓库操作查看远程仓库1如果想查看已经配置的远程仓库服务器，可以运行 `git remote`，会列出没有远程服务器的简写 添加远程仓库12添加一个新的远程仓库，同时指定一个可以引用的简写（shortname）git remote add &lt;shortname&gt; &lt;url&gt; 克隆仓库1git clone [url] 移除无效的远程仓库1git remote rm [name] 此命令只是从本地删除远程仓库记录，不会影响远程仓库 远程仓库抓取和拉取12345从远程仓库中获取最新版本到本地仓库，不会自动mergegit fetch从远程仓库中获取最新版本到本地仓库，自动mergegit pull 如果当前仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库中拉取文件会报错（fatal: refusing to merge unrelated histories ），解决问题：git pull –allow-unrelated-histories 推送到远程仓库1git push [remote_name] [branch_name] Git分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。 查看分支123456列出所有的分支git branch列出所有的远程分支git branch -r列出所有的本地和远程分支git branch -a 创建分支1git branch [branch_name] 切换分支1git checkout [branch_name] 推送分支去远程仓库分支1git push origin [branch_name] 合并分支12在进入master后，执行后于master合并git merge [branch_name] 有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决 删除分支1234git branch -d [branch_name]如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-Dgit branch -D [branch_name] Git标签像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2等）。标签指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。 1234567891011121314151617181920212223列出已有标签git tag查看tag信息git show [tag]创建标签# 新建一个标签git tag [tagName]将标签推送到远程仓库# 提交指定taggit push [remote] [tag]#检出标签git checkout -b [branch] [tag]删除标签#删除本地taggit tag -d [tag]#删除远程taggit push origin :refs/tags/[tag]","link":"/2023/02/26/git/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/01/17/hello-world/"},{"title":"flask","text":"环境python环境 保证python在3.6以上 flask安装 1pip3 install flask 基础配置项目文件结构 FlaskDemo （项目文件名） statc（静态文件存储） template（html代码存储） app.py（主程序代码） 基础代码12345678910111213141516# 从flask这个包中导入Flask类from flask import Flask# 使用Flask类创建一个app对象# __name__: 代表app.py这个模块# 作用1:以后出现bug可以帮助进行快速定位# 作用2:对于寻找模板文件,有一个相对路径app = Flask(__name__)# 创建一个路由和视图函数的映射@app.route('/')def hello_world(): return 'hello world'if __name__ == '__main__': app.run() 项目配置123456789#开启debug模式if __name__ == '__main__': app.run(debug=True) #修改host使得同局域网主机可以访问#修改端口当默认端口被占用的时候可以更改 URL与视图（参数传递）1234567891011121314151617# 访问 /second/123 返回 the netcode is 123# int:netcode 强制netcode为整型@app.route('/second/&lt;int:netcode&gt;')def secondcode(netcode): return 'the netcode is %s' % netcode# 查询字符串方式传参@app.route('/book/list')def book_list(): # arguments:参数 # requset.args:类字典类型 page = request.args.get('page',default=1,type=int) return f&quot;你获取的是第{page}页的数据&quot;# http://127.0.0.1:5000/book/list?page=3 返回 你获取的是第3页的数据# 没有输入page默认返回1 后续有get post请求 模板渲染（jinja2）12345后端@app.route(&quot;/blog/&lt;blog_id&gt;&quot;)def blog_detail(blog_id): # 返回渲染的blog_detail文件同时将路径中传入的参数blog_id从后端传入前端 return render_template(&quot;blog_detail.html&quot;,blog_id =blog_id,userName=&quot;mk&quot;) 12345前端&lt;!-- 通过双花括号引用后端传入的数据 --&gt;&lt;title&gt;This is my blog&lt;/title&gt;&lt;h1&gt;your blog_id is {{blog_id}}&lt;/h1&gt;&lt;h1&gt;your userName is {{userName}}&lt;/h1&gt; 模板访问对象属性1234567891011121314后端# 通过创建一个类来实例一个对象传参class User: def __init__(self,username,email): self.username = username self.email = email@app.route('/')def hello_world(): # 创建一个user对象 user = User(username=&quot;mk310&quot;,email = &quot;xxxx@qq.com&quot;) # 返回渲染后的index超文本文件,和创建好的user return render_template(&quot;index.html&quot;,user = user) 1&lt;h1&gt;用户名是{{user.username}},邮箱是{{user.email}}&lt;/h1&gt; 123456同时还可以使用字典来传参person = { &quot;username&quot;:&quot;mk&quot;, &quot;email&quot;:&quot;xxx@qq.com&quot;}&lt;div&gt;{{person['username']}}&lt;/div&gt; 过滤器的使用123 &lt;!-- 通过管道符号 | 来实现 --&gt;&lt;h1&gt;用户名{{user.username}}的长度是{{user.username|length}}&lt;/h1&gt;返回用户名mk310的长度是5 常用过滤器【Flask框架】——12 Jinja2模板-过滤器_jinja2 自定义过滤器-CSDN博客 控制语句12345678910if语句{% if age &gt;10 %}&lt;div&gt;宁的年龄已满18&lt;/div&gt;{% else %}&lt;div&gt;宁的年龄不满18&lt;/div&gt;{% endif %}for语句{% for book in books %}{% endfor %} jinja2中没有break语句,循环必须有限 模板继承子模板从父模板中继承绝大数样式,同时可以通过block语句自定义需要的样式 文件： template father.html child1.html 1234567891011121314father.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- 在父模板中定义主要的样式同时留出自定义的空间block title为可定义的名称 --&gt; &lt;title&gt;{% block title %} {% endblock %}&lt;/title&gt; &lt;h1&gt;父亲模板的文字&lt;/h1&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 123456789child1.html&lt;!--从父模板中继承主要的样式--&gt;{% extends &quot;father.html&quot; %}&lt;!--在子模版中自定义标题--&gt;{% block title %}子模板的title{% endblock %} jinja2中加载静态文件 flask中静态文件默认放在static文件夹中 12同时可以对样式表和js使用同种方式&lt;img src=&quot;{{url_for('static',filename='2.jpg')}}&quot; &gt; 数据库连接123456#首先给pip换成豆瓣源pip config set global.index-url https://pypi.douban.com/simple/#设置后若返回 https://pypi.douban.com/simple/ 则设置成功pip config get global.index-url 复习一下数据库 12345安装pymysqlpip install pymysql安装Flask-SQLAlchemypip install flask-sqlalchemy 连接数据库： 1234567891011121314151617181920212223242526272829303132from flask_sqlalchemy import SQLAlchemyfrom sqlalchemy import textapp = Flask(__name__)# MySQl所在的主机名HOSTNAME = &quot;127.0.0.1&quot;#MySQl监听的端口号PORT = &quot;3306&quot;#连接MySQl的用户名是用户自己设置的USERNAME = &quot;root&quot;#连接数据库的密码PASSWORD = &quot;1111&quot;# 数据库中创建的数据库名称DATABASE = &quot;database_learn&quot;app.config['SQLALCHEMY_DATABASE_URI'] = f&quot;mysql+pymysql://{USERNAME}:{PASSWORD}@{HOSTNAME}:{PORT}/{DATABASE}?charset=utf8mb4&quot;# 在app.config中设置好连接数据库的信息# 使用SQlAlchemy(app)创建一个对象# SQlAlchemy会自动读取信息db = SQLAlchemy(app)# 测试连接代码 无实际意义# 获取引擎连接with app.app_context(): with db.engine.connect() as conn: # 执行语句 rs = conn.execute(text(&quot;select 1&quot;)) # 查看返回值,若为1连接成功 print(rs.fetchone()) ORM模型对象关系映射（Object Relationship Mapping）python面向对象的方式来操作关系型数据库的技术,一个ORM模型和数据库中的一个表相对应,ORM模型中的每个类属性分别对应表的每个字段.ORM模型的每个实例对象对应表中的每个记录,ORM技术提供了面向对象和SQL交互的桥梁. 优势: 开发效率高,几乎不用写原生sql语句 安全性高 灵活性强,跟换数据库只需小改少量代码 创建表和基本字段 12345678910111213# 继承属性class User(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) # 定义字段,字符型,不可为空 username = db.Column(db.String(100),nullable=False) password = db.Column(db.String(100), nullable=False)# user = User(username=&quot;张三&quot;,password=&quot;1111&quot;)# 把表同步到数据库中去with app.app_context(): db.create_all() CRUD（Create Read Update Delete）123456789101112131415161718192021222324252627282930313233343536373839Create添加数据# 在打开网页后数据库中才会添加数据@app.route(&quot;/user/add&quot;)def add_user(): user = User(username=&quot;张三&quot;,password=&quot;1111&quot;) db.session.add(user) db.session.commit() # 防止报错 没有可用的response对象 添加返回 return &quot;添加用户成功&quot;Read查询@app.route(&quot;/user/query&quot;)def query_user(): # 1.get查找 根据主键查找 user = User.query.get(1) print(f&quot;{user.id}:{user.username}-{user.password}&quot;) # 2.filter_by查找 # users是Query类型 是类数组 users = User.query.filter_by(username=&quot;张三&quot;) for user in users: print(user.username) # 另外看一下其他查找操作 return(&quot;查找成功&quot;)Update该@app.route(&quot;/user/update&quot;)def update_user(): user = User.query.filter_by(username=&quot;张三&quot;).first() user.password = &quot;2222&quot; db.session.commit() return &quot;数据修改成功&quot;Delete删除@app.route(&quot;/user/delete&quot;)def delete_user(): user = User.query.get(2) db.session.delete(user) db.session.commit() return &quot;数据删除成功&quot; 表关系关系型数据库一个强大的功能，就是多个表之间可以建立关系。 通过给Article添加外键，建立和User之间的关系 1234567891011121314class Article(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(200),nullable=False) content = db.Column(db.Text,nullable=False) # 添加外键 数据类型和被引用表中的数据类型保持一致 author_id = db.Column(db.Integer,db.ForeignKey(&quot;user.id&quot;)) # relationship相当于 返回article.author = User.query.get(&quot;article.author_id&quot;) author = db.relationship(&quot;User&quot;)artical = Article(title=&quot;Flask_study&quot;,content=&quot;flaskxxxxxxxxxx&quot;) 12345678910111213141516171819202122232425262728class User(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) # 定义字段,字符型,不可为空 username = db.Column(db.String(100),nullable=False) password = db.Column(db.String(100), nullable=False) articles = db.relationship(&quot;Article&quot;,back_populates = &quot;author&quot;)class Article(db.Model): __tabalename__ = &quot;user&quot; # 定义字段,整型,主键,自增 id = db.Column(db.Integer,primary_key=True,autoincrement=True) title = db.Column(db.String(200),nullable=False) content = db.Column(db.Text,nullable=False) # 添加外键 数据类型和被引用表中的数据类型保持一致 author_id = db.Column(db.Integer,db.ForeignKey(&quot;user.id&quot;)) # relationship相当于 返回article.author = User.query.get(&quot;article.author_id&quot;) # back_populates指数据从User表中的author传入 author = db.relationship(&quot;User&quot;,back_populates = &quot;articles&quot;) 此时可以通过这种方法查找到一个人的所有文章@app.route(&quot;/article/query&quot;)def article_query(): user = User.query.get(4) for article in user.articles: print(article.title) 数据库的更新create_all不能识别模型中的变化,只能识别新增模型,弃用 使用migrate更新数据库,首先pip安装之后引入 1234567migrate = Migrate(app,db)# ORM模型映射三步骤# 1.flask db init:这步只要做一次# 2.flask db migrate:识别ORM模型变化,生成迁移脚本# 3.flask db upgrade:将变化同步到数据库中","link":"/2023/01/18/flask/"},{"title":"hexo问题和使用","text":"在hexo中添加图片 hexo + typora 粘贴上传图片到指定目录 - 简书 (jianshu.com) 安装hexo-renderer-marked插件 安装插件 1cnpm install hexo-renderer-marked 在source文件夹下创建images文件夹用来存放文件 ​ 设置typora偏好设置，设置完成后，在typora中粘贴图片会在images文件夹中创建文件名相同的文件夹来存放文章图片 设置图片根目录 “格式 –&gt; 图像 –&gt; 设置图片根目录”，将source目录设置为根目录","link":"/2022/01/18/hexo%E9%97%AE%E9%A2%98%E5%92%8C%E4%BD%BF%E7%94%A8/"},{"title":"html","text":"超文本标记语言（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 html文档基本格式12345678910111213&lt;!DOCTYPE html&gt; &lt;!--声明html5文档 --&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!-- 声明语言 --&gt;&lt;head&gt; &lt;!-- 声明字符集 --&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html &gt; 基本标签 序号 标签 解释 1 html 定义HTML文档 2 &lt;body&gt; 定义文档的主体 3 &lt;h1&gt;-&lt;h6&gt; 定义文档中的标题 4 &lt;hr&gt; 定义水平线 5 &lt;!----&gt; 定义注释 6 &lt;p&gt; 段落 7 &lt;br&gt; 换行 8 &lt;img&gt; 图像 文本格式化HTML 文本格式化 | 菜鸟教程 (runoob.com) 链接标签1&lt;a href=&quot;超链接地址&quot; target=&quot;_self当前网页打开 _blank新建标签打开&quot; &gt;&lt;/a&gt; 外部标签 内部标签 空标签 下载标签 1&lt;a href=&quot;document.pdf&quot; download&gt;下载文档&lt;/a&gt; 网页元素标签 锚点标签 12&lt;a href=&quot;two&quot;&gt;跳转到网页的第二段&lt;/a&gt;&lt;h1 id=&quot;two&quot;&gt;网页第二段文字&lt;/h1&gt; 从另一个网页跳转到tips 123&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;&lt;a href=&quot;https://www.runoob.com/html/html-links.html#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 头部标签&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 &lt;title&gt;:定义文档的标题 &lt;base&gt;:标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接 &lt;link&gt;:标签通常用于链接到样式表 &lt;style&gt;:元素中你也可以直接添加样式来渲染 HTML 文档 &lt;meta&gt;:标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。 12345搜索引擎定义关键词&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;网页描述内容&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt; &lt;script&gt;:标签用于加载脚本文件 表格标签123456789101112&lt;table&gt; &lt;!-- 表格标签 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头便签&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;!-- 行标签--&gt; &lt;td&gt;&lt;/td&gt; &lt;!-- 单元格标签 --&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 表格属性 表格属性 描述 boder 边框 align 对齐方式 cellpadding 边框和内容之间的间距 cellpacking 单元格之间的空白 width 表格的宽度 合并单元格（实际是设置单元格的宽度长度） 跨行合并单元格 rowspan 跨列合并单元格 colspan 代码 123456789101112131415161718192021&lt;table align=&quot;center&quot; border=&quot;2&quot; &gt; &lt;thead &gt; &lt;tr&gt; &lt;th&gt;a&lt;/th&gt; &lt;!-- 第一行的第二个单元格的宽度为2 --&gt; &lt;th colspan=&quot;2&quot;&gt;b&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody &gt; &lt;tr&gt; &lt;!-- 第一列的第二个单元格的长度为2 --&gt; &lt;td rowspan=&quot;2&quot;&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; HTML区块 HTML 区块 | 菜鸟教程 (runoob.com) 12&lt;div&gt;&lt;/div&gt; division分割 大盒子 一个占一行&lt;span&gt;&lt;/span&gt; span跨度 小盒子 一行可以放多个span 列表标签 无序列表 有序列表 自定义列表 123456&lt;!-- 无序列表 --&gt;&lt;ul&gt; &lt;!-- ul里只可以嵌套li元素 li中可以嵌套其他元素 --&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 123456&lt;!-- 有序列表 --&gt;&lt;ol&gt; &lt;!-- ol里只可以嵌套li元素 li中可以嵌套其他元素 --&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 12345&lt;!-- 自定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;名词解释&lt;/ddd&gt;&lt;/dl&gt; 表单标签表单域123&lt;form action = &quot;url&quot; method = &quot;提交方式&quot; name = &quot;表单域名称&quot;&gt; 表单控件&lt;/form&gt; 常用属性 属性 属性值 作用 action url地址 指定接受处理表单数据的服务器程序的地址 method get/post 设置表单提交方式 name 名称 表单名称。区分一个页面中的多个表单域 表单元素1&lt;input type = &quot;&quot;/&gt; type属性设置不同可以用来指定不同的空间类型 属性 属性值 描述 text 单行输入字段，默认宽度为20 submit 定义提交按钮，提交按钮会把表单中数据发送到服务端 password 密码字段，输入的字符被隐藏 radio 定义单选按钮 checkbox 定义复选框 Button 定义可点击按钮（用于通过javaScript启动脚本） file 供上传文件 image 上传图像 reset 重置按钮，恢复表单默认状态 hidden 隐藏输入字段 标签属性 属性 属性值 描述 name 自定义 input元素的名称 value 自定义 input的值 checked checke 默认选中 maxlength 正整数 输入字符的最大长度 例子 12345&lt;form align = &quot;center&quot; &gt; 用户： eat &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked = &quot;checked&quot; value = &quot;eat&quot;&gt; sleep &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value = &quot;sleep&quot;&gt; jump &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;jump&quot;&gt; &lt;/form&gt; Label标签标签用于绑定一个表单元素，点击lable中文本的时候，浏览器自动将光标转到对应的表单元素上，增加用户体验 下拉表单1234567&lt;select&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt; &lt;option&gt;选项&lt;/option&gt;&lt;/select&gt; 文本域元素（留言评论）12&lt;textarea cols = &quot;50&quot; rows= &quot;5&quot;&gt;文本内容&lt;/textarea&gt;&lt;!-- 一般使用css来控制文本域的大小 --&gt; CSS样式表 内联样式 内联样式表 外联样式表 阶段测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=`, initial-scale=1.0&quot;&gt; &lt;title&gt;网站标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;青春不再&lt;/h4&gt; &lt;table width = '500' border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;生日:&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择年份--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2001&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2002&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2003&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择月份--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择日期--&lt;/option&gt; &lt;option value=&quot;&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;杭州&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;yihun&quot;&gt; &lt;label for=&quot;yihun&quot;&gt;已婚 &lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;weihun&quot;&gt; &lt;label for=&quot;weihun&quot;&gt;未婚 &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第武行 --&gt; &lt;tr&gt; &lt;td&gt;学历&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;博士&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;喜欢的类型&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;1 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;2 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;3 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot;&gt;4 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;个人简介&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第九行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;check&quot;&gt;同意条款 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第十行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;我是会员,登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第十一行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;ul&gt; &lt;h5&gt;我承诺&lt;/h5&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/03/25/html/"},{"title":"macOS软件","text":"软件下载网站 精品MAC应用分享 (xclient.info) Appstorrent - Игры и программы для macOS typoramd编辑软件 备份 homebrew参考安装教程Homebrew国内如何自动安装（国内地址）（Mac &amp; Linux） - 知乎 (zhihu.com) pap.er壁纸软件 备份 visual-stdio-codeide homebrew下载 edge浏览器microsoft-edge 浏览器 homebrew下载 Snipaste截图软件brew下载 cheatsheet长按显示command显示所有的快捷键 brew下载 rectangle分屏软件 brew下载 senseimacos综合管理工具 含状态栏监视器 备份 aDrive阿里云盘备份文件 brew下载 motrix下载工具 brew下载 geekbench跨平台跑分软件 备份 Keka压缩软件 brew下载","link":"/2022/01/18/macOS%E8%BD%AF%E4%BB%B6/"},{"title":"poem","text":"临江仙·夜饮东坡醒复醉 宋-苏轼 夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声 长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生 唐崔道融《梅花》 数萼初含雪，孤标画本难。 香中别有韵，清极不知寒。 横笛和愁听，斜枝依病看。 朔风如解意，容易莫摧残。 唐珙（gǒng）《题龙阳县青草湖》 西风吹老洞庭波，一夜湘君白发多。 醉后不知天在水，满船清梦压星河。 白居易《问刘十九》 绿蚁新醅酒，红泥小火炉。 晚来天欲雪，能饮一杯无？ 《梦微之》 夜来携手梦同游，晨起盈巾泪莫收。 漳浦老身三度病，咸阳宿草八回秋。 君埋泉下泥销骨，我寄人间雪满头。 阿卫韩郎相次去，夜台茫昧得知不？ 温庭筠《新添声杨柳枝词二首》 一尺深红胜曲尘，天生旧物不如新。 合欢桃核终堪恨，里许元来别有人。 井底点灯深烛伊，共郎长行莫围棋。 玲珑骰子安红豆，入骨相思知不知。 宋苏轼《西江月》 世事一场大梦，人生几度秋凉？夜来风叶已鸣廊，看取眉头鬓上。 酒贱常愁客少，月明多被云妨。中秋谁与共孤光，把盏凄凉北望。 陆游陆游《沈园二首·其一》 城上斜阳画角哀，沈园非复旧池台。 伤心桥下春波绿，曾是惊鸿照影来。 明施耐庵《鲁智深坐化诗》 平生不修善果，只爱杀人放火。 忽地顿开金枷，这里扯断玉锁。 咦！钱塘江上潮信来，今日方知我是我。 《西江月》 宋江反诗 自幼曾攻经史，长成亦有权谋。恰如猛虎卧荒丘，潜伏爪牙忍受。 不幸刺文双颊，那堪配在江州。他年若得报冤仇，血染浔阳江口! 心在山东身在吴，飘蓬江海谩嗟吁。他时若遂凌云志，敢笑黄巢不丈夫! 清曹雪芹《自题一绝》 满纸荒唐言，一把辛酸泪！ 都云作者痴，谁解其中味？ 石达开《入川题壁》 大盗亦有道，诗书所不屑。黄金若粪土，肝胆硬如铁。 策马渡悬崖，弯弓射胡月。人头作酒杯，饮尽仇雠血。 钱彩《说岳全传》>《风云》 金麟岂是池中物，一遇风云便化龙。 九霄龙吟惊天变，风云际会浅水游。 现代毛泽东《七律·和郭沫若同志》 一从大地起风雷，便有精生白骨堆。僧是愚氓犹可训，妖为鬼蜮必成灾。 金猴奋起千钧棒，玉宇澄清万里埃。今日欢呼孙大圣，只缘妖雾又重来。","link":"/2023/01/16/poem/"},{"title":"python_Excel操作","text":"python操作Excel 基本操作12345678910111213# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbook#如果没有文件创建文件wb = Workbook()#如果有文件读取文件wb = load_workbook(r'.\\test.xlsx')# 返回激活的sheetws = wb.activeprint(ws.title)# 保存文件wb.save(r'.\\test.xlsx') 工作表操作12345678#创建工作表（表名，表顺序位置）ws2 = wb.create_sheet('Sheet2',1)#打印文件中所有的工作表名print(wb.sheetnames)# 移动表的顺序wb.move_sheet(ws2,-1)# 删除工作表del wb[&quot;Sheet2&quot;] 访问单元格123456789101112131415161718192021222324252627282930# 访问单元格，以二位坐标形式（第几行，第几列，内容）cell = ws.cell(6,2,'coceef')#打印单元格内容print(cell.value)# 打印坐标print(cell.coordinate)# 打印行print(cell.row)# 打印列print(cell.column)# 打印列的字母print(cell.column_letter)x = 1for i in range(1,11): for j in range(1,6): ws.cell(i,j,x) x= x+1# 按列访问，返回从双层元组print(ws['a:c'])# 按行访问print(ws[1:5])# 自定义遍历print(ws['a1:c4'])# 遍历当行/列print(ws[1][2])# 遍历所有的行/列print(ws.iter_rows())print(ws.iter_cols()) 操作单元格1234567891011121314151617# 指定单元格 第一行到第二行，第二列到第六列print(ws.iter_rows(1,2,2,6))# 合并单元格(合并a1和b1)ws.merge_cells('a1:b1')# 取消合并ws.unmerge_cells('a1:b1')# 插入行/列ws.insert_rows(1,2)ws.insert_cols(1,2)# 删除行/列ws.delete_cols(1,2)ws.delete_rows(1,2)# 移动单元格(要移动的单元格，行移动，列移动)ws.move_range(&quot;a1:c4&quot;,4,4) 使用公式12345678910111213141516171819# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbookfrom openpyxl.utils import FORMULAEfrom openpyxl.formula.translate import Translatorwb = Workbook()ws = wb.activews.append(['价格1','价格2','求和','平均'])ws.append([12,33])ws.append([12,44])# 使用求和和平均值函数ws['c2'] = '=SUM(A2:B2)'ws['d2'] = '=AVERAGE(A2:B2)'ws['c3'] = Translator(formula='=SUM(A2:B2)',origin='c2').translate_formula('c3')ws['d3'] = Translator(formula='=AVERAGE(A2:B2)',origin='d2').translate_formula('d3')wb.save('test.xlsx') 设置样式12345678910111213141516# 从open引入workbook 指excel文件from openpyxl import Workbook,load_workbookfrom openpyxl.styles import Fontwb = Workbook()ws = wb.activews[&quot;a1&quot;] = 'fefefe'f= Font(name='微软雅黑',size=15,color='0000FF',bold=True,italic=True,strike=False,underline='double')ws['a1'].font = f# 第二行的高ws.row_dimensions[2].height = 30# 第二列的宽度ws.column_dimensions['B'].width = 30wb.save('test.xlsx')","link":"/2023/05/21/python-Excel%E6%93%8D%E4%BD%9C/"},{"title":"python","text":"​ Python是一种广泛使用的解释型、高级和通用的编程语言。 预备变量变量的命名规则： 变量名只能包含字母、数字和下划线。变量名能以字母或下划线打头，但不能以数字打头。例如，可将变量命名为message_1但不能将其命名为1_message 。 变量名不能包含空格，但能使用下划线来分隔其中的单词。例如,变量名greeting_message 可行，但变量名greeting message 会 引发错误。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print 。 变量名应既简短又具有描述性。例如，name 比n好，student_name 比s_n好，name_length 比length_of_persons_name 好。 慎用小写字母l 和大写字母O ，因为它们可能被人错看成数字1 和0 常量1在代码中特定变量视为常量，可将其字母全部大写 注释单行注释 注意在#后有一个小空格 123# 这是注释print('hello world') #单行注释 两个小空格 多行注释 123''''''多行注释'''''' 标识符（命名规则） 标识符就是程序员定义的变量名，函数名 标识符可以由字母下划线和数字组成 不能以数字开头 不能与关键字重名 标识符区分大小写 局部变量和全局变量 局部变量：在函数内部定义的变量，只能在函数内部使用 全局变量：在函数外部定义的变量，所有函数内部都可以使用这个变量 在其他开发语言中，不推荐使用全局变量，可变范围太大，程序不方便维护 可变和不可变类型 不可变数据类型：是一旦定义，内存中的数据不可修改 可变数据类型：变量名引用的内存地址不变，内存中的数据可以修改 局部变量的生命周期： 所谓生命周期就是变量从被创建到被系统回收的过程 局部变量在函数执行时候创建 函数执行结束后局部变量被系统回收 局部变量在生命周期内，可以用来存贮函数内部临时使用到的数据 基本数据结构 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number（数字） 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 python中的数字包括 int float 和 complex 整数 浮点数 整数和浮点数 任意两个数相除时候，结果总是浮点数(其他情况下没有浮点数结果都是整数) 其他操作中，如果一个操作数是整数，另一个操作数是浮点数，结果也总是浮点数 数中的下划线 更好识别位数长的数 1234num = 14_0000_000&gt;&gt;print(num) 1400000000 常用函数 Python3 数字(Number) | 菜鸟教程 (runoob.com) String（字符串）python中字符串使用单引号'或者双引号”括起来，一般使用双引号 字符串截取1变量[头下表:尾下表] 字符串运算 操作符 描述 + 字符串链接 * 重复输出字符串 [] 通过索引获取字符串中字符 [:] 截取字符串中的一部分，遵循左闭右开的原则 in 成员运算符，如果运算符中包含所给的字符返回True not in 成员运算符，如果运算符中不包含所给的字符返回True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 % 格式化字符串 字符串格式化1234567print('my name is %s this year %d'%('liu',10))print('this is float %.2f' % float_num)#输出浮点数保留两位小数print('this is code %06d')#输出格式为六位整数 不足使用0占位print('the scale is %.2f%%' % scale)#输出百分号 字符串常用函数 12345#统计字符串长度 len函数#统计某一个小字符串出现的次数str.count(&quot;查询的字符串&quot;)# 某一个子字符串出现的索引位置str.index(&quot;查询的字符串&quot;) 判断类型（9个） 方法 解释 isspace() 如果string包含空格（或者是空字符\\t,\\r），返回True isalnum() string之后有一个字符，并且所有字符都是字母或者数字返回True isalpha() string至少有一个字符并且所有字符是字母返回True isdecimal() string只包含数字，全角数字返回True isdigit() string只包含数字，全角数字，（1）或者转义的Unicode字符\\u00b2返回True isnumeric() string只包含数字，全角数字，汉字数字返回True istitle() 如果string是标题化的（每个单词的首字母大写）返回True islower() 如果string中至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，返回True isupper() 如果string中包含字少一个区分大小写的字符，都是大写返回True 查找和替换（7个） 方法 解释 startswith(str) 检查字符是否已str开头，是则返回True endswith 检查字符串是否已str结束，是则返回True find(str,start=0,end=len(string)) 检查str是否包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果返回是返回开始的索引值，反则返回-1 index(str,start=0,end=len(string)) 跟find方法类似，只不过不会报错 rfind(str,start=0,end=len(string)) 跟find方法类似，只不过从右边开始查找 rindex(str,start=0,end=len(string)) 跟index方法类似，只不过从右边开始查找 replace(old_str,new_str,num=string.count(old)) 把string中替换，num若指定，则替换次数不超过num次，返回修改后的字符串，不会修改原有的字符串 文本对齐（3个） 方法 解释 ljust(width) 返回一个原字符串左对齐，并使用空格填充值长度width的新字符串 rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度width的新字符串 center(width) 返回一个原字符串居中，并使用空格田中至长度width的新字符串 应用：打印一首诗 去除空白字符（3个） 方法 解释 string.lstrip() 裁掉string左边的空白字符 string.rstrip() 裁掉string右边的空白字符 string.strip() 裁掉string左右的空白字符 字符串拆分连接（5个） 方法 解释 string.partition(str) 把字符串string分成一个三元素的元组（str前，str，str后） string.rpartition(str) 类似于partition()方法，不过是从右边开始 string.split(str = ‘’,num) 以str为分隔符拆分string,如果num有指定值，则仅分隔num+1个子字符串,str默认包含\\r,\\t,\\n和空格 string.splitlines() 按照行(\\r,\\n,\\r\\n)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以string作为分隔符，将seq中所有元素合并为一个新的字符串 bool（布尔） List（列表）1list1 = ['Google', 'Runoob', 1997, 2000] 列表方法 查询元素： 第一种方法是使用下标直接访问； 第二种方法是使用切片： 切片： list[0:3]前三个元素 list[-3:0]最后三个元素 list_copy = list[:]复制元素（待补充：python的赋值原理） index('value')根据关键字得到索引 下标修改列表中元素，访问元素 添加元素： appen()在列表末尾追加元素 insert()在列表中某个索引位置插入元素 extend()：末尾追加一个列表 1234list1 = [1,2,3]list2 = [4,5,6]lsit1.extend(list2)#list = [1,2,3,4,5,6] 删除元素： del list[index]使用索引直接删除，从内存中删除,一般不使用 pop()默认删除列表尾部元素，传递删除元素,可以删除指定下标元素 remove('value')以关键字删除元素，若重复则删除第一个 clear()清空列表 排序： sort()永久排序 sorted()暂时排序 reverse()永久翻转列表 list = [i*2 for i in range(1,11)]列表解析（创建10以内数的平方） 列表迭代遍历123nums = [1,2,3,4]for num in nums: print(num) 应用场景 即使python的列表可以存储不同类型的数据 在实际开发中： 列表存储相同类型的数据 通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 Tuple（元组）定义Python 的元组与列表类似，不同之处在于元组的元素不能修改,元组中通常保存不同类型的数据。 列表使用方括号 []，元组使用小括号 ()。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可 123tup = ('Google', 'Runoob', 1997, 2000)#定义只含一个元素的元组one_thing = (1,) 方法 元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用 访问：元组可以相list一样通过下标访问，使用索引时候用[] 修改：元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 删除：元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组 截取：元组同样可以通过[:]方法来截取 元组中能用的方法和列表差不多 1del tup #删除整个元组 应用场景 函数的参数和返回值，一个函数可以接受任意多个参数，或者一次返回多个数据 格式化字符串，格式化字符串后面的()，类如：print('this is %s he is %d'%(name,age))，本质上是一个元组 让列表不可修改，保护数据安全 Set（集合）集合（set）是一个无序的不重复元素序列。 123parame = {value01,value02,...}或者set(value) 添加：add() 移除：remove() 清空：clear() 12345s.add(x) #添加，如果元素已经存在，不进行任何操作s.update(x) #同样是添加元素s.remove(x) #元素不存在发生错误s.discard(x) #删除，不存在不会法生错误 集合函数 Python3 集合 | 菜鸟教程 (runoob.com) Dictionary（字典）123tinydict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} 方法 123456789101112131415161718192021222324252627282930#取值,使用键值获取对应的值dic['key']# 添加dic = {} # 创建一个空字典dic['first'] = '1'# 修改键值对中的值dic['first'] = '一' #以关键字来访问# 删除键值对del dic['first'] #以关键字来访问删除dic.pop('key') #使用pop方法dic.clear() #清空字典# 遍历字典## 遍历字典键值对for key,value in dic.items()## 遍历所有的键for key in dic.keys()## 遍历所有值for value in dic.values()#合并字典##如果被合并的字典中含有已经存在的键值对，会覆盖原有的键值对temp_dict = {'height':1.75}now_dict.update(temp_dict) 字典特性 字典可以用来存储多个数据，通常用于存储描述一个物体的相关信息 和列表的区别是： 列表是有序的对象集合 字典是无序的对象集合 字典使用键值对存储数据，键值对之间用,分隔： 字典用{}定义 键key是索引 值value是数据 键和值之间使用:分隔 键必须是唯一的 值可以是任何数据类型，但键只能是字符串，数字或者元组（不可变类型） 在python中，设置字典的键值对时候，首先会对key进行hash决定在内存中如何保存字典中的数据，以便后续对字典的操作 应用场景 使用多个键值对时候，存储描述一个物体相关信息–描述更复杂的数据信息 将多个字典放在同一个列表中，在进行遍历，在循环体内部正对每一个字典进行相同的处理 公共方法运算符 逻辑结构程序的三大结构： 顺序 分支 循环 条件控制（if）if 123456if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 match case 123456789match subject: case &lt;pattern_1&gt;: &lt;action_1&gt; case &lt;pattern_2&gt;: &lt;action_2&gt; case &lt;pattern_3&gt;: &lt;action_3&gt; case _: &lt;action_wildcard&gt; case 12345678910111213mystatus=400print(http_error(400))def http_error(status): match status: case 400: return &quot;Bad request&quot; case 404: return &quot;Not found&quot; case 418: return &quot;I'm a teapot&quot; case _: return &quot;Something's wrong with the internet&quot; 循环语句（while for）while 12while 判断条件(condition)： 执行语句(statements)…… 经典用例 1234567891011121314151617181920212223242526272829303132# 列表之间移动元素sandwich_orders = ['rose','lily','maria']finished_sandwichs = []while sandwich_orders: concurrent_sandwich = sandwich_orders.pop() print(f'I make your {concurrent_sandwich}') finished_sandwichs.append(concurrent_sandwich)print(f'we have finieshed {finished_sandwichs}')#删除特定元素pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']print(pets)while 'cat' in pets: pets.remove('cat')print(pets)#填充字典qa = {}flag = Trueprint(type(flag))while flag: name = input('whats your name?') place = input('where would want to go someday?') qa[name] = place repeat = input('would want to talk more?(Yes/No) ') if repeat == 'No': flag = Falseprint(qa) for 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; range() 12345&gt;&gt;&gt;for i in range(5): #打印（0，5）... print(i)&gt;&gt;&gt;for i in range(5,9) : #前开后闭 print(i) break continue pass 12&gt;&gt;&gt;while True:... pass # 等待键盘中断 (Ctrl+C) python推导式列表推导式123456[表达式 for 变量 in 列表 if 条件]res = [x for x in range(1,10) if x%2==0] #迭代偶数列表print(res) [2, 4, 6, 8] 字典推导式1234567{ key_expr: value_expr for value in collection if condition }listdemo = ['Google','Runoob', 'Taobao']# 将列表中各字符串值为键，各字符串的长度为值，组成键值对&gt;&gt;&gt; newdict = {key:len(key) for key in listdemo}&gt;&gt;&gt; newdict{'Google': 6, 'Runoob': 6, 'Taobao': 6} 集合推导式12345{ expression for item in Sequence if conditional }&gt;&gt;&gt; setnew = {i**2 for i in (1,2,3)}&gt;&gt;&gt; setnew{1, 4, 9} 元组推导式12345678(expression for item in Sequence if conditional )&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象&gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9) 迭代器和生成器 15分钟彻底搞懂迭代器、可迭代对象、生成器【python迭代器】_哔哩哔哩_bilibili 迭代器 1234567891011121314151617181920212223242526272829303132#迭代器类型的定义 1.当类中定义了_iter和_next_两个方法 2._iter_方法需要返回对象本身，即self 3._next_方法，返回下一个数据，如果没有数据了，即要抛出一个StopIteration的异常 #创建迭代器类型 class IT(object): def _init_(self): self.count = 0 def _iter_(self): return self def _next_(self): self.count+=1 if self.count==3: raise StopIteration() return self.count #根据类实例创建一个迭代器对象 obj1 = IT() v1 = obj._next_()#执行类中的函数 v1 = next(obj1)#相当于执行上个代码 obj2 = IT() for item in obj2: #首先会执行迭代对象的_iter_方法并获取返回值，一直区反复执行next（对象）,每执行一次将返回值传递给item print(item) #迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration#for循环内部循环时候，先执行_iter_方法，获取一个迭代器对象，然后不断执行next取值 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 1234567891011121314# 创建生成器函数 def func(): yield 1 yield 2 #创建生成器对象（内部是更具生成器类generator创建的对象），生成器类的内部也声明了:__iter__,__next__方法 obj1= func() for item in obj1: print(item) #如果迭代器的规定来看，其实生成器也是一种特殊的迭代器类（生成器是一种特殊的迭代器） 可迭代对象 123456789101112131415161718192021#创建迭代器类型class IT(object): def _init_(self): self.count = 0 def _iter_(self): return self def _next_(self): self.count+=1 if self.count==3: raise StopIteration() return self.count class Foo(object): def __iter__(self): return IT() #返回迭代器对象 obj = Foo() #可迭代对象 for item in obj: #循环可迭代对象时候，内部限制性obj.__iter__并获取迭代器对象，不断执行迭代对象的__next__方法 print(item) 1234567891011121314151617181920212223242526#基于可迭代对象和迭代器实现：自定义rangeclass IterRange(object): def __init__(self,num): self.num = num self.counter = -1 def __iter__(self): return self self __next__(self): self.counter += 1 if self.counter ==self.num； raise StopIteration() return self.counter class Xrange(object): def __inint__(self,max_num): self.max_num = max_num def __iter__(self.max_num) obj = Xrange(100)for item in obj: print(item) python函数语法1234def greet_user(username): &quot;&quot;&quot;显示简单的问候语。&quot;&quot;&quot; print(f&quot;Hello, {username.title()}!&quot;)greet_user('jesse') 函数编写指南： 函数命名遵循使用小写加下划线表示意思 给形参指定默认值时候，等号两边不要有空格（同样对 使用关键字传递实参的时候） 参数过多时候，换行显示 形参实参上述定义函数greet_user()时，要求给变量username指定一个值。调用这个函数并提供这种信息的时候，它将打印相应的问候语。 在函数greet_user()的定义中，变量username是一个形参(parameter)，即函数完成工作所需要的信息。在调用函数greet_user(‘jesse’)中，值’jesse’是一个实参(argument)，即调用函数时候传递给函数的信息。调用函数时候，将要让函数使用的信息放在圆括号中。在函数greet_user(),这个值被赋给形参username。 ·参数传递 123a = [1,2,3]a = 'Runoob' 上述代码中[1,2,3]是list类型，’Runoob’是String类型，但是变量a是没有类型的，仅仅是一个对象的引用（指针），可以指向list或者String类型对象 可更改和不可更改对象 在python中，strings, tuples,和numbers是不可更改的对象，而list dict等则是可以修改的对象。 可变类型:变量赋值a=5后再赋值a=10,这里实际是新生成-个int值对象10.再让a指向它,而5被丢弃，不是改变a的值,相当于新生成了a. 可变类型:变量赋值la=[1,2,3,4] 后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改 python函数的参数传递: 可变类型:类似C++的值传递，如整数、字符串、元组。如fun(a),传递的只是a的值,没有影响a对象本身。如果在fun(a)内部修改a的值，则是新生成一个a的对象。 可变类型:类似C++的引用传递，如列表，字典。如fun(la),则是将la真正的传过去，修改后fun外部的la也会受影响python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 传递实参必须参数（位置参数）必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。（传入实参时候的顺序必须和定义形参时候的顺序一样） 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 123456def describe_pet(animal_type, pet_name): &quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot; print(f&quot;\\nI have a {animal_type}.&quot;) print(f&quot;My {animal_type}'s name is {pet_name.title()}.&quot;)# 调用时候直接声明实参类型describe_pet(animal_type='hamster', pet_name='harry') 让实参变为可选的 1234567891011 def get_formatted_name(first_name, last_name, middle_name=''): &quot;&quot;&quot;返回整洁的姓名。&quot;&quot;&quot; ❷ if middle_name: full_name = f&quot;{first_name} {middle_name} {last_name}&quot; ❸ else: full_name = f&quot;{first_name} {last_name}&quot; return full_name.title()musician = get_formatted_name('jimi', 'hendrix')print(musician)❹ musician = get_formatted_name('john', 'hooker', 'lee')print(musician) 默认参数调用函数时，如果没有传递参数，则会使用默认参数。 12345def describe_pet(pet_name, animal_type='dog'): &quot;&quot;&quot;显示宠物的信息。&quot;&quot;&quot; print(f&quot;\\nI have a {animal_type}.&quot;) print(f&quot;My {animal_type}'s name is {pet_name.title()}.&quot;)describe_pet(pet_name='willie') 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数 第一种方法是使用*的方法引入 123456789101112131415161718192021def functionname([formal_args,]*var_args_tuple) “函数文档字符串” function_suite return [expression]加星号的参数会以元组的形式导入，存放所有未命名的变量参数def printInfo(arg1,*vartuple): print(arg1) print(vartuple) #调用函数print(70,60,50)#输出结果70(60, 50) 如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 第一种方法是使用**的方法引入，参数以字典的形式导入 1234567891011121314151617def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression] # 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 输出: 1{'a': 2, 'b': 3} 禁止函数修改列表： 1unprinted_designs[:] #表示unprinted_designs的副本，表示不想改变原来的数据 使用任意数量的关键字实参 123456789def build_profile(first, last, **user_info):&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切。&quot;&quot;&quot;❶ user_info['first_name'] = firstuser_info['last_name'] = lastreturn user_infouser_profile = build_profile('albert', 'einstein',location='princeton',field='physics')print(user_profile) 匿名函数Python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 1lambda [arg1 [,arg2,.....argn]]:expression 函数注释123def say_hello(): '''这是函数注释''' print('hello') 在使用函数时候通过热键CTRL+Q查看注释 python模块python提供一种方法，把定义的所有方法和变量都存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块的引入 模块的命名也要遵循标识符规则 import引入 在文件头部使用import引入库 123456#!/usr/bin/python3# Filename: support.py def print_func( par ): print (&quot;Hello : &quot;, par) return 12345678#!/usr/bin/python3# Filename: test.py # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func(&quot;Runoob&quot;) 这样做并没有把直接定义在库中的print_func写入到当前符号表中，只是把模块support写到了那里，可以把它赋给一个本地的名称 12print_func = support.ptint_func#之后调用函数直接使用print_func()就好了 from ...import 让你从模块中导入一个指定的部分到当前命令空间中： 1from modname import name1,name2 这个生命不会把整个模块导入到当前的命名空间中，只会把函数引入 from … import * 把一个模块的所有内容全都导入到当前的命名空间也是可行的 引入库的最佳做法： 只导入需要使用的函数 导入整个模块使用句点表示法 标准模块Python 本身带着一些标准的模块库，有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。 包包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。 就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。 这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。 python面向对象面向对象基本概念 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 创建和使用对象创建Dog类123456789101112131415dog.py❶ class Dog: ❷ &quot;&quot;&quot;一次模拟小狗的简单尝试。&quot;&quot;&quot; ##init函数是构造函数 在实例化对象的时候会自动执行 ❸ def __init__(self, name, age): ## self是实例对象，self位置必须是第一个（dog = Dog() self 就是实例对象dog） &quot;&quot;&quot;初始化属性name和age。&quot;&quot;&quot; ❹ self.name = name self.age = age ❺ def sit(self): &quot;&quot;&quot;模拟小狗收到命令时蹲下。&quot;&quot;&quot; print(f&quot;{self.name} is now sitting.&quot;) def roll_over(self): &quot;&quot;&quot;模拟小狗收到命令时打滚。&quot;&quot;&quot; print(f&quot;{self.name} rolled over!&quot;) 类中的函数称为方法 根据类创建实例1my_dog = Dog(&quot;Willie&quot;,6) 使用句点法访问实例的属性和方法 继承编写类时，并非总是要从空白开始。如果要编写的类是另一个现成 类的特殊版本，可使用继承 。一个类继承 另一个类时，将自动获 得另一个类的所有属性和方法。原有的类称为父类 ，而新类称为 子类 。子类继承了父类的所有属性和方法，同时还可以定义自己 的属性和方法。 子类的__init__()1234❸ def __init__(self, make, model, year):&quot;&quot;&quot;初始化父类的属性。&quot;&quot;&quot; ❹ super().__init__(make, model, year) #super()是一个特殊函数，能够调用父类的方法 父类必须包含在当前的文件中，且位于子类前面 给子类定义属性和方法1234567891011121314class ElectricCar(Car): &quot;&quot;&quot;电动汽车的独特之处。&quot;&quot;&quot; def __init__(self, make, model, year): &quot;&quot;&quot; 初始化父类的属性。 再初始化电动汽车特有的属性。 &quot;&quot;&quot; super().__init__(make, model, year) #定义电车的电池属性 ❶ self.battery_size = 75 #定义电车的展示点亮方法 ❷ def describe_battery(self): &quot;&quot;&quot;打印一条᧿述电瓶容量的消息。&quot;&quot;&quot; print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;) 重写父类方法直接根据父类的方法名重新定义子类的方法 将实例用作属性当类添加细节过多时候，可以将一类细节提取出来作为一个类，这种条件下，类的层次会更加的清晰 1234567891011121314151617181920class Car:--snip--❶ class Battery:&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试。&quot;&quot;&quot; ❷ def __init__(self, battery_size=75): &quot;&quot;&quot;初始化电瓶的属性。&quot;&quot;&quot; self.battery_size = battery_size ❸ def describe_battery(self): &quot;&quot;&quot;打印一条᧿述电瓶容量的消息。&quot;&quot;&quot; print(f&quot;This car has a {self.battery_size}-kWh battery.&quot;)class ElectricCar(Car):&quot;&quot;&quot;电动汽车的独特之处。&quot;&quot;&quot; def __init__(self, make, model, year): &quot;&quot;&quot; 初始化父类的属性。 再初始化电动汽车特有的属性。 &quot;&quot;&quot; super().__init__(make, model, year) #直接在电车类中将电池类实例化 ❹ self.battery = Battery() 导入类像库一样存储类，但是使用类的时候要注意：如类的名称是car.py那么调用类的文件名为my_car.py，引入类的方法和库一样 。 文件从文件中读取数据读取全部数据12345with open('shutdown.bat') as file_obj: #open 打开文件，返回一个表示文件的对象，with表示在不需要文件后关闭 contents = file_obj.read()#末尾读到空内容时候返回一个空行，使用rstrip()清除空格print(contents) 逐行读取使用for循环逐行读取 创建一个包含文件各行内容的列表123filename = 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines() 数据写入文件写入空白文件12345filename = 'programming.txt'#以写模式打开文件 with open(filename, 'w') as file_object: file_object.write(&quot;I love programming.&quot;)#如果写入文件不存在 会自动创建 注意默认没有换行符，输入时候如有需要要添加换行符 模式 解释 w 写入模式（全覆盖） r 读取模式 a 追加模式 r+ 读写模式 异常处理不能被除以零的异常1234try: print(5/0)except ZeroDivisionError: print(&quot;You can't divide by zero!&quot;) else代码1234567891011while True:--snip--if second_number == 'q': break❶ try:answer = int(first_number) / int(second_number)❷ except ZeroDivisionError:print(&quot;You can't divide by 0!&quot;)# 依赖try代码成功执行的代码应该放到else中❸ else:print(answer) 测试代码","link":"/2023/03/23/python/"},{"title":"史纲","text":"政治 通读 背景 大事件考点 土地法 会议 著作","link":"/2023/10/11/%E6%94%BF%E6%B2%BB%E5%8F%B2%E7%BA%B2/"},{"title":"马原","text":"政治 哲学 物质观意识观 物质观 物质：物质是标志客观实在的哲学范畴，物质的唯一特性是客观实在性，它存在于人的意识外，为人的意识所反映 抽象维度：物质无非是各种物的总和，而这个概念就是从这一总和中抽象出来的-归纳了各种具体物质形态的共性 客观实在维度：从万千具体事物形态抽象出来的共性就是客观实在性，是物质的唯一特性（运动是物质的根本属性）、 物质和运动 运动是物质的存在方式和根本属性 物质是一切运动变化和发展过程的主题和承担者 物质运动互相不可以分隔-无运动的物质：形而上学，没有物质的运动：唯心主义 运动和静止 静止是特殊的运动，包括空间位置和根本性质 运动是无条件的绝对的，而静止是有条件的，相对的 静止是运动的衡量尺度，运动和静止相互依赖渗透和包含 物质运动和时空 时间特点：一维性 空间特点：三维性 时空特点： 时间空间是物质运动的存在形式，物质运动与时空的不可分割证明了时间空间的客观性。 具体物质形态的时空是有限的，整个物质世界的时空是无限的 物质运动的时空的客观实在性是绝对的，物质运动的时空的具体特性是相对的（一方面，时间和空间的具体特性随着物质形态的不同而不同；另一方面，时间和空间具体特性随物质运动速度的变化而变化-相对论。）。 世界的物质统一性 物质是世界的本原，世界的本原只有这一个 世界的统一性在于它的物质性 物质世界的统一性是多样性的统一，不是单一的，无差别的统一 世界的物质统一性体现在人类社会统一与物质： 人类社会是物质世界的组成部分 人们谋取物质资料的时间活动虽然有意识指导，但任然是以物质力量改造物质力量的活动，即物质性的活动 物质资料的生产方式是人类社会存在和反战的基础，体系那人类社会的物质性 意识观意识的本质：是客观世界的主管印象，内容上是客观的，形式上是主观的，是客观内容和主管现实的统一。意识是特殊的物质，人脑的机能和属性，意识是物质的产物，但又不是物质本身。 意识产生的因素： 劳动是决定性因素 语言是重要因素也是意识的物质外壳 意识的能动作用 意识活动具有目的性和计划性 意识活动具有创造性 意识具有指导时间改造客观世界的作用 意识具有调控人的行为和生理活动的作用 意识是人类所独有的，不等于物质本身 物质和意识的作用 物质决定意识，意识对物质具有反作用-能动作用，这种作用可以是超前的，滞后的，同步的？ 意识和人工智能 人工智能是对人脑组织结构和思维运行机制的模仿 不能超过，替代人类智能： 人类意识是知情意的统一体，AI只是对人类的理性智能的模拟，不具备情感信念意志等人类意识形式 社会性是人的意识所固有的本质属性 人类的自然语言是思维的物质外壳和意识的现实形式，AI难以理解自然语言的真实含义 发挥主观能动性和尊重客观规律相统一 尊重客观规律是发挥主观能动性的前提 实践是客观规律性和主管能动性统一的基础，是发挥人的主观能动性的基本途径 只有充分发挥主观能动性，才能正确认识和利用客观规律 人于自然关系 唯物辩证法 事物得联系和发展 联系的四个特点（多条扑克） 客观性：事物的联系是事物本省所固有的，不是主观臆想 普遍性： 任何事物内部的不同部分和要素相互联系 任何事物不是独立存在 整个世界是互相联系的整体 事物的普遍联系是通过中介来实现的，通过中间性的联系和过度环节实现的 多样性： 条件性： 条件对事物发展和人的活动具有支持或者制约作用 条件是可以改变的，人们通过努力可以创造出事物发展所需要的条件 改变和创造条件不是任意的，必须尊重事物的发展的客观规律 联系发展的基本环节 原因和结果：解释事物引起和被引起的关系 的区分即使确定又是不确定的 相互作用互为因果 原因结果相互渗透，结果在原因之中，原因表现在结果之中 复杂多样 现象本质：解释事物的内在联系和外在表现 现象：是事物的外部联系和表面特征，人们可以通过感官感知 本质：事物内在联系和根本性质 本质决定现象：现象表现本质，本质藏在事物内部，只有通过理性思维才能把握 必然偶然：解释事物产生发展和衰亡的不同趋势 必然： 偶然： 区别：必然产生于事物内部的根本矛盾，稳定一般；偶然产生于非根本矛盾外部条件，不稳定个别的 联系：必然存在偶然之中，通过大量的偶然表现出来，是必然的表现形式和补充，两者一定情况下可以互相转化 现实可能：反映事物的过去现在和将来的关系 现实：当下事物的客观存在，标志事物的当前情况 可能：事物的潜在趋势 现实可能可以相互转化 内容和形式：内部要素和结构及表现方式的关系 内容决定形式，形式反作用于内容 内容和形式相互依赖，不可分割 可能性和不可能性：在现实中是否有依据 现实可能性和抽象可能性：根据是否充分 事物的发展和变化（新事物旧事物） (1)发展的概念： 前进的、上升的运动。 (2)发展的实质：新事物的产生和旧事物的灭亡。 (3)新事物不可战胜的原因： ① 新事物有新的要素、结构和功能，适应已经变化了的环境和条件。 ② 新事物是在旧事物的“母体”中孕育成熟的， 对旧事物进行了辩证否定和扬弃。 ③在社会历史领域内，新事物符合人民群众的利益和要求。 (4)事物发展的过程性：一切事物都有其产生、发展和转化为其他事物的历史，都有它的过去、现在和未来。“世界不是既成事物的集合体，而是过程的集合体”。 三大规律对立统一规律 矛盾同一性与斗争性及其在事物发展中的作用 同一性和斗争性是矛盾的两种基本属性。 同一性：矛盾双方相互依存、相互贯通的性质和趋势。相互依存是指矛盾着的对立面相互依存，互为存在的前提， 并共处于一个统一体中；相互贯通是指矛盾着的对立面相互贯通，在一定条件下可以相互转化。 斗争性： 矛盾着的对立面相互排斥、相互分离的性质和趋势。可以分为对抗性矛盾和非对抗性矛盾两种基本形式。 同一性对于事物发展的作用： 矛盾双方利用对方的发展使自己获得发展。 矛盾双方相互吸取有利于自身的因素而得到发展。 矛盾双方向着对立面转化而得到发展。 斗争性在事物发展中的作用： 促使矛盾双方力量对比发生变化，为对立面的转化、事物的质变创造条件。 是一种矛盾统一体向另一种矛盾统一体过渡的决定力量。 矛盾的同一性和斗争性的关系： 矛盾着的对立面又斗争、又同一，由此推动事物的发展。有条件的、相对的同一和无条件的、绝对的斗争相结合， 构成了事物的矛盾运动，推动着事物的发展。 矛盾的普遍性和特殊性及其相互关系 矛盾的普遍性:矛盾存在于一切事物发展过程的始终,即“矛盾无处不在,矛盾无时不有”。 矛盾的特殊性:具体事物在其运动中的矛盾及每一矛盾的各个方面都有其特点。具体问题具体分析是马克思主义活的灵魂。 矛盾的普遍性和特殊性是辩证统一的:矛盾的共性是无条件的、绝对的,矛盾的个性是有条件的、相对的。任何现实存在的事物的矛盾都是共性和个性的有机统一,**共性寓于个性之中,**没有离开个性的共性,也没有离开共性的个性。 矛盾的不平衡性 矛盾不平衡性原理是指是矛盾特殊性原理的延申。 内部和外部矛盾的关系：内因是事物存在和发展的根据，外因是事物发展变化的条件，外因通过内因起作用 主要矛盾:矛盾体系中处于支配地位、对事物发展起决定作用的矛盾。 次要矛盾:矛盾体系中处于从属地位、对事物发展起次要作用的矛盾。 矛盾的主要方面:一对矛盾中处于支配地位,起着主导作用的一方,事物的性质是由主要矛盾的主要方面所决定的。 矛盾的次要方面:处于被支配一方。 两点论和重点论的统一:看问题既要全面地看,又要看主流、大势、发展趋势。 量变质变规律 质:一事物区别于其他事物的内在规定性。 量:事物的规模、程度、速度等可以用数量关系表示的规定性。 度:保持事物质的稳定性的数量界限,即事物的限度、幅度和范围。度的两端叫关节点或临界点,超出度的范围,此物就转化为他物。 量变与质变: 量变体现了事物发展的渐进性和连续性。 质变体现了事物发展的渐进性和连续性的中断。 量变和质变的辩证关系: 量变是质变的必要准备。 质变是量变的必然结果。 量变和质变是相互渗透的。量变质变规律体现了事物发展的渐进性和飞跃性的统一。 量变必然引起质变 量变过程中的部分质变还是量变，质变过程中量的扩张本质上还是质变 否定之否定规律 肯定因素:维持现存事物存在的因素。 否定因素:促使现存事物灭亡的因素。 辩证否定观: 否定是事物的自我否定,是事物内部矛盾运动的结果。 否定是事物发展的环节,是旧事物向新事物的转变,是从旧质到新质的飞跃。只有经过否定,旧事物才能向新事物转变。 否定是新旧事物联系的环节,新事物孕育产生于旧事物,新旧事物是通过否定环节联系起来的。 辩证否定的实质是“扬弃”,即新事物对旧事物既批判又继承,既克服其消极因素又保留其积极因素。 主客观辩证法 客观辩证法:是客观事物或客观存在的辩证法。 主观辩证法:是指人类认识和思维运动的辩证法。 两者关系:客观辩证法与主观辩证法在本质上是统一的,但在表现形式上却是不同的。主观辩证法是客观辩证法的反映。它们不是决定与被决定的关系,也不是源与流的关系。唯物辩证法既包括客观辩证法也包括主观辩证法,体现了唯物主义、辩证法、认识论的统一。 认识论 实践观 实践的本质：人类能动的改造世界的客观物质性活动 实践的基本特征：客观实在性，自觉能动性和社会历史性 实践的基本结构： 主体客体中介三基本要素 实践主体和客体相互作用关系-实践认识价值关系 实践是最基本关系 两个子系统：物质性工具系统，语言符号系统 实践的基本类型： 物质生产实践 社会政治实践 科学文化实践 实践对认识的决定作用 实践是认识的来源 实践是认识发展的动力 实践是认识的目的 实践是检验真理性的唯一标准 认识观 认识的本质：在实践基础上主体对客体的能动反映 两个对立路线： 物到感觉到思想：唯物主义反映论 思想感觉到物：唯心主义先验论 旧唯物主义和辩证唯物主义： 直观反映论 能动反映论 认识的过程和规律 第一次飞跃：实践到认识 感性认识：感官直接感受到的，认识的初级阶段，直接性，有不深刻的局限性 理性认识：借助抽象思维，关于事物本质，全体内部联系和事物自身规律认识，高级阶段，抽象和间接性特点 感性和理性认识的辩证关系： 感性认识有待发展和深化为理性认识 理性认识依赖于感性认识，感性认识是理性认识的基础 感性认识和理性认识相互渗透和包含 感性认识向理性认识飞跃的条件： 获得丰富的感性材料 对感性材料进行加工，由表及里 第二次飞跃：认识到实践 重要性： 认识世界的目的是改造世界 认识的真理性只有在事件中才能检验和发展 实践：从实际出发，理论和实际相结合，将理论转化为改造社会和自然的物质力量 实践中非理性因素的作用 非理性因素：主体的情感和一直，对于人的然是有激活驱动和控制作用 理性因素：指人的理性只管，理性思维能力 真理观 真理是标志者主观和客观相符合的哲学范围，对客观事物和规律的正确反映 真理的特征 客观性：首要问题，真理的本质属性：内容是客观的标准是客观（真理是认识，主观范畴-内容客观，形式主观） 一元性：真理只有一个，客观性决定了一元性 绝对性（正确的无限性）：真理标志主客观统一，是绝对的，承认客观性就是承认绝对性 相对性（具体认识正确的有限性）：正确认识有限度，不完善，任何真理都是主观对客观事物近似正确即相对正确的反映 真理的绝对性和相对性的辩证统一 相互依存 相互包含：真理的而绝对性寓于真理的相对性之中，真理的相对性包含表现绝对性。无数相对真理的总和构成绝对真理；真理永远处于相对到绝对转化的过程中。 真理和谬误 谬误：是对客观事物及其发展规律的歪曲反映 真理谬误关系：真理谬误在一定范围的对立是绝对的，超出一定范围两者会相互转化。真理总是同谬误相比较而存在，相斗争而发展。 真理和谬误是绝对对立的 [x] 在确定的对象和范围内，真理和谬误的对立是绝对的 实践标准的的确定性和不确定性 实践是检验真理的唯一标准： 是由真理的本性和实践的特点决定的。真理的本性要求主观和客观相符合。实践具有直接现实性的特点，能够把一定的认识、理论变成直接的、实实在在的现实，把主观的东西变为客观的东西，并看其是否符合客观 实践检验标准的确定性与不确定性：实践标准的确定性即绝对性是指实践作为检验真理标准的唯一性。实践标准的确定性或绝对性，由实践标准的客观性和唯一性所决定。实践标准的不确定性即相对性是指一定历史阶段上的具体实践具有局限性，实践检验真理是一个过程，而不是一次完成的。 实践是检验真理的唯一标准，并不排斥逻辑证明的作用。逻辑证明是对实践标准的重要补充，但不是检验真理的标准。逻辑证明中使用的逻辑法则，也是在实践中产生的，必须经过实践的检验才能获得真理性。 真理和价值 价值：体现的是主体和客体之间的一种特定关系， 表现为人与满足其某种需要的客体之间的意义关系。 价值的基本特性：主体性、客观性、多维性和社会历史性。 价值评价及其特点： 其一， 评价以主客体的价值关系为认识对象；其二， 评价结果与评价主体直接相关；其三， 评价结果的正确与否依赖于对客体状况和主体需要的认识。价值评价有科学与非科学之别，评价具有主观性， 但并不是一种主观随意的认识活动，只有正确反映价值关系的评价才是正确的评价。 价值观与核心价值观： 马克思主义价值观以绝大多数人的利益为是非、善恶、美丑的评价标准，归根结底以社会的进步和人类的彻底解放为标准。 真理与价值在实践中的辩证统一： 任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。一方面， 价值尺度必须以真理为前提。另一方面，人类自身需要的内在尺度， 推动着人们不断发现新的真理。基于实践的具体性和历史性，真理尺度与价值尺度的统一也是具体的和历史，真理尺度和价值尺度是辩证统一的 唯物史观 ​ 社会存在和社会意识社会存在社会存在是社会生活的物质方面,主要包括: 物质生产方式一社会历史发展的决定力量,是生产力和生产关系的统一。 地理环境一社会发展的影响因素。自然地理环境是人类社会生存和发展永恒的、必要的条件,是人们生活和生产的自然基础。 人口因素一社会发展的影响因素。坚持人与自然和谐共生。其一,当今世界出现的生态问题,并不单纯是自然系统内平衡关系的严重破坏,而是人与自然关系的严重失衡。其二,只有尊重自然规律,才能有效防止在开发利用自然时走弯路 社会意识社会意识是社会生活的精神方面,是社会存在的反映。在社会意识形式,存在社会意识形态和非意识形态的区分: 社会意识形态一道德、政治法律思想、艺术、哲学、宗教等。 非意识形态一自然科学、语言学等 辩证统一 社会存在决定社会意识:社会存在是社会意识内容的客观来源,社会意识是社会物质生活过程及其条件的主观反映;社会意识是人们进行社会物质交往的产物;随着社会存在的发展,社会意识也相应地或早或迟地发生变化和发展。 社会意识依赖于社会存在,又有其相对独立性。其一,社会意识与社会存在发展的不完全同步性和不平衡性。其二,社会意识内部各种形式之间的相互影响及各自具有的历史继承性。其三,社会意识对社会存在的能动的反作用,这是社会意识相对独立性的突出表现。 社会发展的动力历史发展的两大根本动力 第一大根本动力:生产力与生产关系及其矛盾运动。 生产力:是人类社会生活和全部历史的基础,具有客观现实性和社会历史性。 生产力三要素:劳动资料、劳动对象、劳动者。其中,劳动资料中的生产工具,是区分社会经济时代的客观依据。而劳动者是生产力中最活跃的因素,所以,人才资源是第一资源。 科学技术是生产力中的重要因素:科学技术是知识形态的生产力。在现代,科学技术对于生产发展的作用越来越大,日益成为生产发展的决定性因素。 生产关系:人们在物质生产过程中形成的不以人的意志为转移的经济关系。生产关系是社会关系中最基本的关系,政治关系、家庭关系、宗教关系等其他社会关系,都受生产关系的支配和制约。在生产关系中,生产资料所有制(即生产资料归谁所有)是最基本的、决定性的,它构成全部生产关系的基础。它是区分不同生产方式、判定社会经济结构性质的客观依据。 生产力与生产关系辩证统一:生产力决定生产关系,而生产关系又反作用于生产力。 第二大根本动力:经济基础与上层建筑及其矛盾运动。 经济基础:由社会一定发展阶段的生产力所决定的生产关系的总和,是制度化的生产关系。 上层建筑:包括政治上层建筑(国家政权、军队、警察等)和观念上层建筑(即意识形态)。在整个上层建筑中,政治上层建筑居于主导地位,国家政权是它的核心。 经济基础与上层建筑辩证统一:经济基础决定上层建筑,上层建筑反作用于经济基础,二者相互影响、相互作用。 历史发展的其他动力 阶级斗争:社会基本矛盾在阶级社会中的直接表现,是阶级社会发展的直接动力。阶级斗争根源于社会经济关系的冲突。 革命:阶级斗争的最高形式,是社会形态的质变。革命的根本问题是国家政权问题。 改革:是在同一社会形态内,实现该社会形态的自我发展和自我完善。改革是解决社会主义社会基本矛盾的根本手段。 科学技术:科技革命是推动经济和社会发展的强大杠杆。科技革命会引起生产方式、生活方式和思维方式的深刻变革。但注意,科学技术像一把双刃剑,既能通过促进经济社会发展造福人类,同时也可能会带来一些消极后果,有时会“表现为异己的、敌对的和统治的权力”。因此要正确认识和运用科学技术。 社会形态的更替 社会形态：社会形态包括社会的经济形态、政治形态和意识形态,是三者历史的、具体的统一。 社会形态更替的统一性和多样性 统一性:社会形态按总体历史进程(五大社会形态)依次更替。 多样性:不同的民族可以超越一种或几种社会形态而跳跃式地向前发展。 社会形态更替的必然性和人们的历史选择性 必然性:社会形态依次更替的过程和规律是客观的,是社会基本矛盾运动的结果。 人们的历史选择性:第一,社会发展的客观必然性造成了一定历史阶段社会发展的基本趋势,为人们的历史选择提供了基础、范围和可能性空间。第二,社会形态更替的过程也是一个主观能动性与客观规律性相统一的过程。第三,人们的历史选择性归根结底是人民群众的选择性。 社会形态更替的前进性与曲折性革 前进性:五种社会形态依次演进的基本趋势,其历史过程是一个“扬弃”的过程。 曲折性:社会前进过程中所出现的反复、停滞和倒退现象。但历史车轮前进的总趋势是不可改变的,它所呈现的曲折,必将以社会的巨大进步来补偿。 人类普遍交往与世界历史的形成和发展 交往是人类实践活动的重要组成部分,对社会生活有着重要的影响。第一,促进生产力的发展。第二,促进社会关系的进步。第三,促进文化的发展与传播。 唯物史观视域中的“世界历史”是指各民族、国家通过普遍交往,打破孤立隔绝的状态,进入相互依存、相互联系的世界整体化的历史。生产方式的发展变革是世界历史形成和发展的基础。普遍交往是世界历史的基本特征。“人类命运共同体”的提出,是我们党站在世界历史的高度思考人类的未来与前途取得的成果。 人的观点唯物史观考察历史创造者的原则 立足于现实的人及其本质来把握历史的创造者。 现实的人:基于自身需要和社会需要而从事一定实践活动的、处于一定社会关系中的、具有能动性的人。 人的本质:人的本质是社会关系的总和。 立足于整体的社会历史过程来探究谁是历史的创造者。 从社会历史发展的必然性入手来考察和说 从人与历史关系的不同层次来考察谁是历史的创造者。坚持“人们自己创造自己的历史”的观点。与唯心史观划分了界限。 人民群众 人民群众是一个历史范畴 人民群众(质):一切对社会历史发展起推动作用的人。 人民群众(量):社会人口中的绝大多数。 最稳定的主体部分:始终是从事物质资料生产的劳动群众及其知分子。(特定时期可以包含剥削阶级) 人民群众创造历史 人民群众是社会物质财富的创造者。 人民群众是社会精神财富的创造者。 人民群众是社会变革的决定力量。 人民群众是历史的创造者,人民群众的总体意愿和行动代表了历史发展的方向,人民群众的社会实践最终决定历史发展的结局。但是,人民群众创造历史的活动受到一定社会历史条件的制约。经济条件对于人民群众创造历史的活动有着首要的、决定性的影响。一定历史阶段所达到的生产力水平是人民群众创造历史的物质基础和前提。精神文化条件也是制约人民群众创造历史活动的重要因素。 个人在社会历史中的作用 历史人物:一定历史事件的主要倡导者、组织领导者或思想理论、科学文化的重要代表人物。历史人物对历史发展有着深刻影响,甚至有时能够决定个别历史事件的结局,从而导致历史发生这样或那样的重大变化。从其发挥作用的性质来看,历史人物有些起推动历史前进的进步作用,有些起阻碍历史前进的反动作用 杰出人物:是历史人物中对推动社会历史发展作出重要贡献或起重要作用的人。新的历史任务往往是由杰出人物首先发现或提出来的。先进阶级的政治代表人物,特别是无产阶级的领袖人物所提出的思想能够成为社会变革的先导。杰出人物会因其智慧、性格因素对社会进程产生影响,但这些作用仅仅是历史进程中的偶然现象。 普通个人:属于人民群众范畴,对社会发展有或大或小的贡献,其总和构成了人民群众创造历史的活动。 群众、阶级、政党、领袖的关系正确认识和处理群众、阶级、政党、领袖的关系。首先,群众是划分为阶级的。其次,阶级通常是由政党领导的。最后,政党是由领袖来主持的。群众、阶级、政党、领袖环环相扣、相互依存,构成一个有机整体,任何时候都不应该把它们割裂开来。坚持“两个确立”,做到“两个维护”。 政治经济学 科学社会主义社会主义的发展和规律 科学社会主义的直接思想来源：","link":"/2023/08/24/%E6%94%BF%E6%B2%BB%E9%A9%AC%E5%8E%9F/"},{"title":"数据结构和算法","text":"学习笔记脑图：阿里云盘分享 (aliyundrive.com) 绪论数据结构（三要素） 逻辑结构 存储结构 数据的运算 数据的运算：施加在数据的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。 五个特征 有穷性：执行有穷步后结束，每一步都在有穷时间内完成 确定性：算法必须具备明确定义的运算，每一一步都有确切的定义，不会有二义性 可行性：有效执行，得到确定结果 输出：算法产生的一个或者多个特定关系的量 输入：零个或者多个输入 效率的度量时间复杂度： 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法所花费的时间与其中语句的执行次数成正比例， 空间复杂度： 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少bytes的空间，因为这个也没大大意义，所以空间复杂度算的是变量的个数。例如：一个动态分配开辟的一个动态数组为O(N)，一个变量的空间复杂度O(1)。 线性表线性表的定义：线性表是具有相同数据类型的n个数据元素的有限数列。","link":"/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"title":"数学","text":"math 高等数学预备知识函数概念和特性 函数 反函数（xy对调关系） 单调函数必有反函数（有反函数的函数不一定是单调函数） 反函数和原函数关于y=x对称 复合函数 函数四种特性和重要结论 有界性 单调性 奇偶性 周期性 若f是可导偶函数，其导数为奇函数 若f是可导奇函数，其导数为偶函数 若f是可导周期为T的周期函数，其导数为同周期的周期函数 连续的基函数一切原函数都是偶函数 连续的偶函数的原函数中只有一个原函数是奇数函数 若f以T为周期，且其在0到T上的定积分为0，则f的一切原函数也是以T为周期 若f在ab内可导且导数有界，则f在ab内有界 函数图像直角坐标下图像 常见图像：常数函数，幂函数（x^n），指数函数，对数函数，三角函数（正弦余弦正切），反三角 取整函数：x−1&lt;[x]≤x 图像变换 左加右减，上加下减 对称变化 伸缩变换，变大k倍，图像变1/k 极坐标图像心形线 玫瑰线 阿基米德螺线 使用直角系观点画极坐标参数方程摆线 心形线 常用基础知识数列等差数列 通项 通项和 等比数列 通项 通项和 常见数列前n项和 三角函数三角函数基本关系诱导公式（奇变偶不变符号看象限：把a看成锐角，变化后落在变化前函数的象限的奇偶） 特殊函数值重要公式倍角公式 半角公式 和差公式 积化和差 和差化积 指数运算相乘指数相加 次方指数相乘 对数运算积的对数 = 对数的和 一元二次方程基础 因式分解 ⭐常用不等式 数列极限数列极限定义 数列收敛和子数列的关系 收敛数列的性质 唯一性 有界性 保号性 夹逼准则单调有界函数极限和连续性函数极限邻域函数极限的定义 函数极限性质 唯一性 局部有界性 局部保号性 极限运算规则夹逼准则洛必达法则⭐泰勒公式 展开原则： 上下同阶 AB分别展开到他们稀疏不相等的x的最低次幂为止 海涅定理（归结原则）？ 无穷小比阶无穷小的运算： 有限个无穷小的和是无穷小 有界函数和无穷小的乘积还是无穷小 有限个无穷小的乘积还是无穷小 无穷小的运算 常用等价无穷小： 连续和间断间断点的定义和分类 可去间断点 跳越间断点 无穷间断点 振荡间断点 题型七种未定式 化简： 提出极限不为0的因式 等价无穷小替换 恒等变形 判断类型 选择方法 已知一极限求另一极限已知极限反求参数一元函数微分学的概念和计算概念 导数的概念（函数变化率） 可导条件（左右可导，导数相等） 可导必定连续，连续不一定可导 微分概念（化曲为直）可微判别 导数微分计算四则运算 和差的导数 积的导数 商的导数 分段函数的导数 分段点出用定义求导 非分段点处用公式求导 复合函数的导数和微分形式不变性 反函数的导数 参数方程的导数 隐函数求导法对数求导法对于多项相称相除开方乘方的式子，先取对数再求导 幂指函数求导法化为指数求导 高阶导数求导 归纳法 用高阶求导公式 泰勒公式 变限积分求导⭐基本求导公式 一元函数微分学的几何应用极值最值概念 极值定义d 最值定义 极值点不一定是最值点，最值点不一定是极值点 单调性和极值的判断 单调性判断（导数） 一阶可导点是极值点的必要条件（驻点） 判断极值的第一充分条件（一阶导数判断） 判断极值的第二充分条件（二阶导数判断） 判断极值的第三充分条件（偶数阶导数判断） 凹凸性和拐点的概念 凹凸性定义（直线中点大于曲线） 拐点定义（凹凸转换） 判断凹凸性（二阶导） 二阶导数是拐点的必要条件（二阶导） 判断拐点的第一充分条件（二阶导异号） 判断拐点的第二充分条件（二阶导数判断） 判断拐点的第三充分条件（奇数阶导数判断） 渐近线 铅锤渐近线 水平渐近线 斜渐近线 最值或者取值范围 求闭区间[a,b]上连续函数f的最大值和最小值 求开区间(a,b)上连续函数f的最值和取值范围 做函数图形曲率半径 🚗中值定理构造函数 涉及函数的中值定理 有界和最值定理（直接就是求函数的最大值和最小值） 介值定理（介于函数两个之间的函数值，函数的连续性） 平均值定理（多个自变量的介值定理） 零点定理（两个函数值异号得零） 涉及导数的中值定理 费马定理（可导取极值的驻点）！费马定理的证明 罗尔定理（三个条件，1闭区间上连续 2开区间上可导 3端点函数值相等 得 端点间一值导数为0） 构造函数 拉格朗日中值定理（闭区间连续，开区间可导） 柯西中值定理（两个函数之间的定理） 泰勒公式 带拉格朗日余项的泰勒公式 带佩亚诺余项的泰勒公式 麦克劳林公式 积分中值定理（拉格朗日的变种） 新加 导数介值定理 🚗零点问题和微分不等式零点问题 零点定理（用于证明根的存在性） 单调性（用于证明根的唯一性） 罗尔原话（n阶方程至多有k个根，则f=0至多有k+n的根） 实系数奇次方程至少有一个实根 微分不等式 用函数性态（单调性，凹凸性，最值） 用常数变量化证明不等式 用中值定理（主要是拉格朗日和泰勒公式） 一元函数积分学的概念和计算不定积分 原函数和不定积分（不定积分没有上下限） 原函数（不定积分存在定理） 连续函数必有原函数 含有第一类间断点和无穷间断点的函数在包含该间断点的区间内没有原函数（含有震荡间断点的函数也不一定有原函数） 定积分 定积分的概念（将不规则图形划分为规则的梯形） 积分区间有限 被积函数有界 定积分存在定理 定积分存在的充分条件 f在闭区间a,b上连续，原函数存在 f在闭区间上单调，原函数存在 f在闭区间上有界，且有有限个间断点（可以从间断点处拆开），原函数存在 定积分存在的必要条件 若定积分存在，其在上下界上有界 定积分的性质 求区间长度 积分中的常数可以提到积分符号之前 积分可加/拆分性 积分的保号性（积分的绝对值小于绝对值的积分） 估值定理（积分的介值定理） 积分中值定理 变限积分 变限积分的定义 变限积分的性质 f在a,b上可积，则f的积分在a,b上连续（积分区域的增加是连续的） f在a,b上连续，则f的积分在a,b上可导（积分区域的增加是平滑的） 变限积分的求导公式 反常积分 反常积分的概念（1 积分区间无线，2 被积函数无界） 被积函数越小，反常函数通常越容易收敛 被积区间无线的反常函数收敛，其被积函数不一定收敛于0，可能是被积函数的无穷小程度超过了高的无穷大程度 无穷区间上反常函数的概念和敛散性 上积分区间无限 下积分区间无限 上下都无限 无界函数的反常积分概念和敛散性 积分后从被积函数的瑕点趋近 题型： 反常积分判敛公式 积分计算不定积分的积分法 基本积分公式 凑微分法（将被积函数中的一部分提取到积分最右） 换元法（当被积函数不容易积分的时候（反对幂函指三）） 三角函数代换（三种平方形式） 恒等变形后做三角变换（先化成三角函数代换方式在代换） 根式代换（根式内无法凑平方的，直接将整个根式代换） 倒代换（被积函数分母的幂次比分子高两次或者以上的时候） 复杂函数直接代换（反对幂函指三） 分部积分法（分部积分的推广公式） 在积分中凑出于前式一样相减消去 有理函数的积分（拆分为若干有理项之和） 定积分的计算 不定积分 凑微分法 换元法 分部积分法 有理函数积分 定积分 区间再现公式 华理士公式 常用含三角函数积分公式 区间化简公式 对称性 分部积分 分段函数 变限积分一元积分学的几何应用定积分表达和计算平面图形的面积 上下两个函数包围的面积 极坐标表达式包围的成的扇形面积（理解公式） 用定积分表达和计算旋转体的体积 曲边梯形绕x轴旋转一周所得到的旋转体的体积 曲边梯形绕y轴旋转一周所得到的旋转体的体积 平面曲线弧长 旋转曲面的表面积 平面曲边提醒的坐标公式 一元积分的物理应用总路程变力沿直线做功提取物体做功 静水压力 细杆质心 🚗积分不等式积分不等式 中值定理 夹逼准则 积分法 积分不等式 函数单调性 拉格朗日中值定理 泰勒公式 积分法 多元微分法基本概念 平面点集的基本概念 内点 外点 边界点 极限（函数从任意方向趋近，目前只用来证明不可导） 连续 偏导数（偏导数的定义） 可微（可微的公式） 偏导数的连续性（在瑕点处定义法求，在非瑕点处公式求） 多元函数求导规则 链式求导规则 隐函数存在定理（一元函数和二元函数） 题型 复合函数求偏导问题 隐函数求偏导（隐函数求导后能确定变量关系问题） 逆问题（由偏导逆求原函数） 多元函数的极最值 概念 无条件极值 二元函数取极值的必要条件（一阶偏导存在且取极值，导数为0） 二元函数取极值的充分条件（对函数求三个偏导，记住公式） 条件极值和拉格朗日乘数法（记住公式） 题型 无条件极值（只给出了变量关系式，没有其他关系） 闭区域边界上的最值（变量关系式，和其他关系式） 闭区域上的最值（边界内为无条件极值，边界上为条件极值） 二重积分概念 几何背景（曲顶柱体的体积） 性质 求区域面积 可积函数必有界 积分的线性性质（积分拆开） 积分的可加性 积分的保号性（积分的绝对值小于绝对值的积分） 二重积分的估值定理（积分的介值定理） 二重积分的中值定理 对称性 普通对称性（被积函数值在对称区间抵消） 轮换对称性（积分值和用什么字母表示无关，时常互换后前后相加） 计算 直角坐标系下的计算法 上下型（从上往下画直线，先交写上限，后交写下限） 左右型（从左往右画直线，先交写上限，后交写下限） 极坐标下的计算（在划定范围的时候可以直接将xy转换为rcos，rsin） 极点在区域之外 极点在区域边界上 极点在区域内部 极坐标系和直角坐标系的选择（满足以下使用极坐标） 是否为f(x^2+y^2)f(y/x)等形式 看积分区域是否为圆或者圆的一部分 极直互化 积分次序（当先求积分中存在不可积分时候，画图交换积分次序） 用二重积分处理一元积分的问题（累次积分和乘积：利用积分符号不变性） 常微分方程微分方程的概念 微分方程（导数和自变量关系方程） 常微分方程（位置函数是一元函数） 微分方程的阶（方程中所含导数阶数） 微分方程的解（带入方程是方程成立的函数） 微分方程的通解（独立常数的个数等于微分方程的阶数） 初始条件和特解（确定常数的通解） 一阶微分方程的求解 可分离变量型（xy的微分可以直接移动到等式两边） 可化为变量可分离型 dy/dx=f(ax+by+c) 齐次微分方程（可化为y/x） 一阶线性微分方程（y`+py=q）有通解公式，记住推导过程 伯努利方程 二阶可降阶微分方程的求解（y的二阶导，一阶导，y，x） 缺少y（替换一阶导，二阶导） 缺少x 一阶导替换，二阶导数替换为含p导数（变形为一阶线性微分方程） 通过通解公式求解得到一阶导 再对一阶导积分 高阶线性微分方程的求解 概念 二阶变系数线性微分方程，非齐次方程 二阶常系数微分方程 解的结构（二阶） 齐次方程的两个解线性组合为齐次方程的通解 非齐次方程的特解和齐次方程的通解组合为非齐次方程的通解 二阶常系数齐次线性微分方程的通解（记住公式） 二阶常系数非齐次线性微分方程的特解 n阶常系数齐次线性微分方程的解 其他技巧 把y的微分方程化为x的微分方程 变换方程把微分变量化为复合函数 特解中指数系数和特征方程的关系","link":"/2023/01/17/%E6%95%B0%E5%AD%A6/"},{"title":"日语","text":"五十音 声调 第一个音和第二个音不会是同音 出现降音就不会升回去","link":"/2023/12/22/%E6%97%A5%E8%AF%AD/"},{"title":"测试","text":"软件测试（英语：Software Testing），描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。换句话说，软件测试是一种实际输出与预期输出之间的审核或者比较过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 测试基础软件是控制计算机硬件的工具 软件产生过程： 软件测试：使用技术手段验证软件是否满足使用需求 软件测试目的：减少软件缺陷，保证软件质量 主流技术 功能测试：测试主要验证程序的功能是否满足需求 自动化测试：使用代码或者工具代替手工，对项目进行测试 接口测试：使用代码或者工具验证程序中的接口是否访问正常 性能测试：模拟多人使用软件，查找服务器缺陷 常见的测试分类按照测试阶段划分： 按照代码可见度划分： 模型质量模型：衡量一个优秀软件的维度 功能： 功能数量 功能能否正确实现 错误处理情况 性能： ​ 兼容性： 易用性： 简介 友好 流畅 美观 可靠性： 安全性： 传输加密 存储加密 可移植性： 数据迁移 可维护性 测试流程 测试用例为测试项目而设计的执行文档 测试用例的作用： 防止漏测 实施测试的标准 用例设计编写格式 用例编号 用例标题 项目/模块 优先级 前置条件 测试步骤 测试数据 预测结果 用例编号：项目_模块_编号 用例标题：预测结果（测试点） 模块：所属项目或者模块 优先级：表示用例的重要程度或者影响力p9——p4（p0最高） 前置条件：要执行此条用例，有哪些前置条件 测试步骤：描述操作步骤 测试数据：操作用的数据，没有的话为空 预测结果：期望得到的结果 联系： 测试设计等价类划分法 解决穷举场景 实例：账号限制为6-10位自然数 步骤 描述 描述 明确要求 限制为6-10位自然数 限制为6-10位自然数 划分有效等价和无效等价 有效8位自然数 无效3位自然数，12位自然数，8位非自然数，空 提取数据编写用例 12345678 123，123456789012 案例 ： 要求： 区号：空号或者是三位数字 前缀码：非0且非1开头的三位数字 后缀码：四位数字 适用场景针对：需要有大量数据测试输入，但是美哦有办法穷举测试的地方 输入框 下拉列表 单选复选框 典型代表：页面的输入框类测试 边界值分析法 解决边界限制问题 边界范围节点 上点：边界上的点（正好等于） 离点：距离上点最近的点（刚好大于，刚好小于） 内点：范围内的点（区间范围内的数据） 有关范围限制，最多7条用例 边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类） 优化后的： 步骤 明确要求 确定有效和无效等价（类型） 确定边界范围值 提取数据编写测试用例 总结 单个输入框，常用的方式：等价类+边界 123在等价类的基础上对有边界范围的测试数据输入的地方（重点关注边界）常见词语描述：大小，尺寸,重量，，最大，最小，至多，至少典型代表：有边界范围的输入框类测试 判定表法 条件依赖关系 定义：是一种以表格形式表达条件逻辑判断的工具 组成： 条件桩：列出问题中的所有条件，列出条件的次序无关紧要 动作桩：列出 问题中可能采取的操作，操作的排列顺序没有约束 条件项：列出条件对应的取值，所有可能情况下的真假值 动作项：列出条件项的，各种取值情况下应该采取的动作结果 案例： 验证：若用户欠费或者关机，则不允许主被叫功能的测试 规则: 判定表中贯穿条件项和动作项的一列就是一条规则 假设有n个条件, 每个条件的取值有两个(0,1),全组合有2的n次方种规则 步骤 明确需求 分析条件桩，动作桩，画判定表 提取数据，编写用例 案例： 使用场景 有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖关系 判定表一般适用于条件组合数量比较少的情况（比如4个条件以下） 123456提示:多条件之间有依赖关系，使用判定表来进行测试覆盖。判定表一般适合4个以内条件依赖关系如果条件超过4个，就不适合覆盖所有条件，应采用(正交法)来解决 场景法 根据实际的应用场景，来测试业务用例，可以使用场景法 1234561、开始-&gt;验证银行不成功-&gt;结束2、开始-&gt;验证银行卡成功-&gt;密码错误3次-&gt;结束3、开始-&gt;验证银行卡成功-&gt;密码验证成功-&gt;账户余额不足-&gt;结束4、开始-&gt;验证银行卡成功-&gt;密码验证成功&gt;账户余额验证成功-&gt;取款金额不正确-&gt;结束5、开始-&gt;验证银行卡成功-&gt;密码验证成功&gt;账户余额验证成功-&gt;取款金额正确-&gt;ATM机余额不足-&gt;结束6、开始-&gt;验证银行卡成功-&gt;密码验证成功-&gt;账户余额验证成功-&gt;取款金额正确-&gt;ATM机余额充足-&gt;取款成功-&gt;结束 错误推荐法 当项目用例执行完毕，且BUG修复完成，离上线还有一段时间，在那段时间中可使用错误推荐法复测主要业务或者未覆盖的功能 缺陷管理用例执行 说明：执行结果与用例的的期望结果不一致，为缺陷 缺陷介绍✔定义软件在使用过程中存在的任何问题都叫软件的缺陷，简称bug ✔判定标准 软件未实现需 求(规格)说明书中明确要求的功能-少功能 软件 出现了需求(规格)说明书中指明不应该出现的错误-功能错误 软件实现的功 能超出需求(规格)说明书指明的范围多功能 软件未实现需 求(规格)说明书中虽未明确指明但应该实现的要求-隐性功能错误 软件难以理解， 不易使用，运行缓慢,用户体验不好-不易使用 缺陷核心内容 缺陷提交要素 缺陷类型 用例 ✔缺陷编写缺陷报告实例： 缺陷的跟踪流程： 编写 验证 关闭 提交缺陷的注意事项： 可重现：缺陷可以复现、 唯一性：一个缺陷上报一个问题 规范性：符合公司或者项目要求 ✔缺陷管理工具禅道 地址：https://demo.zentao.net/ 流程图 特点 使用流程： 禅道管理缺陷登录软件 创建缺陷： 验证和关闭缺陷： 缺陷标题分析描述测试数据+实际结果（预测结果） 输入不正确的取款金额 结果取款成功（预期：取款失败，提示：不是正确金额） web常用标签HTML:https://smashdog1.gitee.io/2022/03/25/html/ CSS:css进阶 - Hexo (gitee.io) JavaScript:JavaScript - Hexo (gitee.io) 项目实战项目介绍 项目背景 传智作为一个IT教育机构，拥有子级开发实际运营的产品 将开发和运营的技术作为授课的内容，对于学院而言学到的都是一手的真是案例和实际经验 产品定位 一款汇集科技咨询，技术文章和回答交流的用户移动终端产品 用户通过该产品，可以获取最新的科技资讯，发表或者学习技术文章，讨论交流技术问题 项目目标 研发并上线运营头条产品 从实际的产品技术中孵化Python人工智能，Python数据分析，PythonWeb，测试，运维等课程案例 产品功能架构 用户端：APP，用户可以查询资料，文章内容，进行回答讨论交流 自媒体运营平台：PC网站，自媒体用户可以管理文章，评论，查看分析粉丝数据 系统后台：PC网，内部运营管理系统 ⭐发项目功能测试 测试对象 完成黑马头条web登录功能测试 完成黑马头条web发布文章功能测试 登录需求-1 输入正确的中国手机号(11位) 当文本框失去焦点的时候验证， 红色为失败，绿色为成功 点击发送验证码 如果手机号文本框状态为绿色， 弹出“点击按钮进行验证”; 如果手机号文本框为红色， 提示手机号不正确 点击按钮进行验证 拖拽图形 到指定位置,按钮消失; 拖拽图形未到指定位置， 晃动提醒，滑块回到初始位置; 超过5次, 提示尝试过多,请点击重试; 登录需求-2 输入验证码 正确的验证码, 并“勾选我已阅读并同意”,点击登录，进入系统; 错误的验证码， 并“勾选我已阅读并同意’”,点击登录,提示验证码错误; 正确的验证码, 未“勾选我已阅读并同意”,点击登录,提示请勾选; 点击登录 手机号、 验证码都为绿色，勾选“我已阅读并同意”，登录成功 开始测试 分析需求跳转到分析 提取测试点 设计用例 登录 滑块 非功能 用例评审执行用例缺陷管理测试报告","link":"/2023/01/26/%E6%B5%8B%E8%AF%95/"},{"title":"线性代数","text":"math 行列式行列式的基本概念和性质基本概念 逆序和逆序数 余子式和代数余子式 特殊高阶行列式 对角 上三角 下三角 逆三角 范德蒙行列式 分块行列式 行列式计算性质 行列式降阶 行列式等于行列式某行元素与对应的代数余子式之极的和 行列式一样的元素和另一行的代数余子式之积的和为0 行列式化简 行列式和其转置行列式相等 对调两行行列式行列式改变符号 某行有公因子可以提到行列式外 可以拆分 行列式某行倍数加到另一行，行列式不变 行列式计算矩阵矩阵的基本概念和特殊矩阵 矩阵就是一个列表 同型矩阵（m，n相对）矩阵相等（所有元素都一样） 伴随矩阵 特殊矩阵 矩阵的运算和性质 αβ的计算 初等变换求逆矩阵 矩阵转置逆矩阵 ⭐矩阵的秩 r（ab） = r（a）b是可逆的矩阵 矩阵等价AB 两个同型矩阵，A经过有限次初等变换后变换为B，称AB等价 定理1 等价的充分必要条件条件是秩相等 定理2 同型的充分必要条件是存在可逆矩阵PQ，PAQ= B 题型 矩阵运算和矩阵行列式运算（注意向量计算） 矩阵的幂矩阵 相似对角化 利用零幂矩阵 将矩阵化成向量形式 分块矩阵 归纳法 初等变化和初等矩阵（初等矩阵的变化就是对矩阵的行列操作） 逆矩阵的计算和证明 判断矩阵可逆的方法 定义 行列式不为0 求逆矩阵 公式 伴随矩阵 初等变换 向量向量概念运算 向量（有大小又有方向的量） 向量的单位化（向量除以向量的模） 向量的内积 向量的运算 三则运算 内积运算 零向量和任何向量都正交 线性相关和线性表示 线性相关（向量组中至少有一个向量可以由其他向量线性表示） 线性表示（向量可由其他向量表示） 等价 线性无关组和秩等价两个同阶向量组的每个向量可以相互线性表示则等价 极大线性无关组向量组中秩的个数个无关向量组成的向量组 秩 矩阵的秩=列（行）向量组的秩 维数相同的向量组ab，a可以由b表示，则a的秩不大于b的秩（a的自由向量要小于b的） 等价的向量组秩相等，反之不对（等价矩阵要求同型） 矩阵和向量的关系 题型向量组的相关性向量的线性表示向量组等价和向量组的秩 求向量组的一个极大线性无关组，并用无关组表示 线性方程组齐次线性方程组线性方程组的解的定理 方程组的解的结构 线性方程组的通解 方程组的解的扩展理论 题型方程组的理论证明 线性方程组的解的结构和性质 齐次线性方程组的解 非齐次线性方程组的通解 线性方程组的理论证明 方程组的公共解和方程组同解 特征向量和特征方程特征值和特征向量基本概念 施密特正交 特征值和特征向量 相似的矩阵 特征值相等 特征向量为p^-1a 任何特征值都对应无数个特折向量，但其线性无关的特征向量不超过其重数 实对称矩阵的重根特征向量可以正交也可以不正交 矩阵对角化 题型 求矩阵的特征值和特征向量 公式法 定义法 关联矩阵 逆矩阵 伴随矩阵 特征值和特征向量的性质 矩阵相似的判断 先判断特征方程是否相等，不相等则相似 进行判断 都可相似对角化，则相似 一个可以相似对角化，不相似 都不可以相似对角化，看重根对应的线性无关特征向量 非实对称矩阵的对角化 实对称矩阵的对角化 矩阵的幂次 特征值法求未知矩阵 已知两特征向量，利用不同特征值特征向量正交，得另一特征向量 特征值特征向量的命题证明 “绝境之下”，如何求解矩阵的特征值？ - 知乎 (zhihu.com) 二次型二次型基本概念和基本型 正定矩阵和正定二次型 题型 二次型概念 二次型的标准型 使用配方法时候如果只有x1x2这种可以使用平方差 含参二次型问题 正定二次型的判别和证明","link":"/2023/09/22/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"网络协议","text":"q前端学习路线: 前端学习路线 (gitee.io) 【干货】前端学习路线分享！写了个网站帮助你学习前端！_哔哩哔哩_bilibili http协议http基本知识HTTP（HyperText Transfer Protocol）超文本传输协议 超文本：文本指图片，视频，压缩包等，超文本指文字，图片，视频等的混合体最关键有超链接，能从一个超文本跳转到另一个超文本。HTML就是最常见的超文本。 HTTP常见状态码： 1xx：提示信息，协议处理的中间状态，实际使用少 2xx：表示服务器成功处理了客户端的请求 3xx：表示客户端的请求资源发生了变动，需要客户端用新的URL从新发送请求获取资源，重定向。 4xx：表示客户端请求的报文有错误，错误码。 5xx：表示客户端请求报文正确，但是服务器处理内部发生了错误，属于服务端的错误码。 http报文 Host：客户端发送请求时，用来指定服务器的域名 Content-Length:服务器返回数据时候,表名回应的数据长度 Connection:常用于客户端要求服务器使用TCP持久连接,一边其他请求复用 Content-Type:用于服务器回应时候,告诉客户端,本次数据是什么格式 Content_Encoding:表示服务器返回的数据使用了什么压缩格式 请求方法: 序号 方法 描述 1 GET 请求指定页面讯息,并返回 2 HEAD 类似get,不过返回的响应中没有具体的内容,用于获取报头 3 POST 向指定资源提交数据进行处理请求(提交表单或者上传文件),数据被包含在请求体中. 4 PUT 从客户端想服务器传送的数据取代指定的文档内容 5 DELETE 请求服务器删除指定的页面 6 CONNECT 7 OPTIONS 允许客户端查看服务器的性能 8 TRACE 回显服务器收到的请求,用于测试或者判断 GET和POST都是安全等幂吗 安全指请求方法会破坏服务器上的资源 幂等指多次执行相等的操作,结果都是相同的 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。","link":"/2023/12/02/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"title":"计算机网络","text":"","link":"/2022/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"软件工程","text":"​ 采用工程的概念、原理、技术和方法来开发与维护软件,把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，经济的开发出高质量的软件并维护它。 软件工程概述软件工程概念：​ 采用工程的概念、原理、技术和方法来开发与维护软件,把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，经济的开发出高质量的软件并维护它。 软件生命周期： 软件过程 阶段间具有顺序性和依赖性。 推迟实现的观点。 质量保证的观点每个阶段必须完成规定的文档;每个阶段结束前完成文档审查，及早改正错误。 ![改进后的瀑布模型](../images/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/image-20230228100926099.png 增量模型优缺点:优点: 短时间内可提交完成部分功能 逐渐增加产品功能, 用户适应产品快。 缺点: 增量构件划分以及集成困难。 容易退化为边做边改模型。 螺旋模型优缺点: .优点: 利于把软件质量作为软件开发目标。 减少测试 维护和开发不分开 缺点: 风险估计困难 可行性研究可行性研究目的​ 用最小的代价在最小的时间内确定问题是否能够解决。(5%-10%) 可行性研究内容和目的可行性研究步骤： 复查系统规模和目标。对问题定义阶段初步确定的规模和目标进行肯定或改正并列出对目标系统的约束和限制。 研究目前正在使用的系统。了解现有系统能做什么，而不花费过多时间分析怎么实现这些功能。 导出新系统的高层逻辑模型。现有物理系统》现有逻辑模型》目标逻辑模型》目标物理系统 进一步定义问题。分析员和用户一起再次复查系统。前四个步骤构成一个循环。 导出和评价供选择的解法技术角度排除不可行方案操作可行性排除用户不能接受方案经济可行估算成本和收益 推荐行动方针。给出是否继续的结论 草拟开发计划。制定进度表开发人员、计算机资源分析估计每阶段成本、下阶段详细分析 书写文档提交审查。 数据流图系统流程图： 是一种描绘物理系统的图，用图形符号以黑盒子形式描绘物理系统的各部件，表达数据在系统各部件之间流动的情况。而不是对数据进行加工处理的控制过程。 常用符号： 数据流图(DFD)： 描述信息流和数据从输入到输出过程所经受的变换。没有任何具体物理部件,只是描绘数据在软件中流动和被处理的逻辑过程。 常用符号： 数据流图画法: 确定系统输入输出、源点以及终点 画系统顶层数据流图用加工将输入输出数据连接起来，给加工、数据等命名. 自顶向下分解，画出分层数据流图将加工细分，细分成几个数据流图表示. 数据字典数据字典： 是关于数据的信息集合，即对数据流图中包含的所有元素定义的集合。 1.数据字典的内容:数据流、数据流分量(数据元素)、数据存储、处理。 2.定义数据的方法:由数据元素组成数据的方式:顺序、选择、重复、可选 数据字典例题: 1234567891011电话号码= [校内电话|校外电话]校内电话=非零数字+三位数字非零数字=[1|2|3|4|5|6|7|8|9]三位数字= 3{数字}3数字=[0|1|2|3|4|5|6|7|8|9]校外电话=[本市电话|外地电话]本市电话=0 +八位非零开头数字八位非零开头数字=非零数字+七位数字七位数字= 7{数字}7外地电话=0+三位区码+八位非零开头数字三位区码=三位数字 需求分析 需求分析的任务和阶段需求分析任务： 确定对系统的综合要求 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 其中综合要求有： E-R图绘制分析建模 模型是指为了理解事物二队十五做出的一种抽象的，对事物的一种无歧义的书面描述 模型分类： 数据模型: (实体-联系图) :描绘数据对象及数据对象之间的关系。 功能模型: ( 数据流图):描绘数据在系统中流动时被处理的逻辑过程，指明系统具有的变换数据的功能。 行为模型: (状态转换图) :描绘系统的各种行为模式在不同状态间转换的方式。 实体联系图(E-R图) 实体:描述数据对象。 属性:描述数据对象的性质。 联系:描述数据对象之间的交互方式。 对一联系1:1 对多联系1:M 多对多联系M:N 表示方式 ​ 实例： 状态转换图 状态:系统的行为模式，包括初态、终态、中间状态。 事件:是指在某个特定时刻发生的事情， 即对系统从一个状态转换到另一个状态的事件抽象。 表示方式 初态:实心圆在一张状态图中只能有一个初态 终态:同心圆，内为实心●而终态可以有0至多个。 状态:圆角矩形 其他图形工具 层次方框图：表示方式:用树形结构的一系列矩形描绘数据的层次结构。 优点:随着结构的逐步精细对数据结构的描绘也越来越详细。 Warnier图表示方式:用树形结构描绘信息的层次结构。 优点:可以表明信息的逻辑组织。可以表明某类信息出现的条件或是否重复出现。 IPO图表示方式:是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。 优点:简略描绘系统主要算法。 总体设计 设计过程设计过程包括系统设计阶段和结构设计阶段： 系统设计阶段： 设想供选择的方案: 数据流图出发，将处理分组抛弃行不通分组。 选取合理的方案:上一步方案选取低、中、高成本三种方案 推荐最佳方案:推荐最佳方案，制定详细实现计划 结构设计阶段： 功能分解:对数据流图进一步细化，进行功能分解。可以用IPO图等工具描述细化后每个处理的算法。 设计软件结构:层次图或结构图描绘软件结构。或数据流图导出软件结构。 设计数据库 制定测试计划 书写文档 审查和复审 设计原理 模块化：模块:能够单独命名，由边界元素限定的程序元素的序列，是构成程序的基本构件。模块化:把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。 抽象:抽出事务的本质特性而暂时不考虑它们的细节。 逐步求精:逐步揭露出底层细节。Miller法则:注意力集中在(7+2)上 信息隐藏与局部化：信息隐藏:指一个模块内包含的信息对于不需要这些信息的模块来说，是不能访问的。主要是指模块的实现细节。局部化:指把一些关系密切的软件元素物理地放得彼此靠近，它有助于实现信息隐藏。 模块独立：模块独立性:是模块化、抽象、信息隐蔽和局部化概念的直接结果。模块独立是好设计的关键，设计是决定软件质量的关键环节。度量标准:耦合、内聚 耦合是对一个软件结构内不同模块之间互连程序的度量。耦合强度取决于模块接口的复杂程度、通过接口的数据等耦合性越高，模块独立性越弱。耦合分类(程度从低-&gt;高):无直接耦合=》数据耦合=》标记耦合(特征耦合)=》控制耦合=》外部耦合=》公共耦合 内聚是用来度量一个模块内部各个元素彼此结合的紧密程度的。.内聚分类(程度从低-&gt;高):偶然内聚=》逻辑内聚=》时间内聚=》过程内聚=》通信内聚=》顺序内聚=》功能内聚 同其它模块强耦合的模块意味着弱内聚;强内聚模块意味着与其它模块间松散耦合 软件设计目标:高内聚、低耦合 启发规划 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇入和扇出应适当深度:表示软件结构中控制的层数。宽度:软件结构内同一个层次上的模块总数的最大值。扇出:一个模块直接控制(调用)的模块数目，扇出过大意味着模块过分复杂。一般一个设计的好的典型系统的平均扇出是3或4，扇出的上限是5到9。扇入:指有多少上级模块调用它，扇入大说明上级模块共享该模块的数目多。好的软件结构顶层扇出比较高，中层扇出比较少，底层扇入到公共的实用模块中，即底层模块有高扇入。 模块的作用域应该在控制域之内作用域:指受该模块内一个判定影响的所有模块的集合。控制域:是这个模块本身以及所有直接或间接从属于它的模块的集合。 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 结构设计图形工具 层次图：用方框和连线表示，连线表示上下层的调用关系 HIPQ图：层次图加编号 结构图：不仅描述调用关系，还描述传递的信息和调用的方式 箭头代表调用过程中传递的信息，尾部空心代表数据，实心代表控制信息 结构化设计方法（面向数据流设计方法） 交换流:由输入，变换中心和输出三部分组成 事物流： ​ 详细设计详细设计的任务目的目的： 确定怎样具体的实现所要求的系统。得出对目标的精确描述 详细设计任务: 过程设计:即设计软件体系结构中所包含的每个模块的实现算法。 数据设计:设计软件数据结构。 接口设计:设计软件内部各模块之间的接口 结构程序设计只使用三种基本的控制结构就能够实现任何单入口单出口的程序 扩充的控制结构： Do-case多分支和Do-UNRTIL循环 人机界面设计人机界面设计:是接口设计的一个重要的组成部分。 设计人机界面过程常遇到的4个问题: 系统响应时间重要属性:长度和易变性 用户帮助设施 出错信息处理 命令交互 人机界面设计指南： 一般交互指南 信息显示指南 数据输入指南 过程设计工具程序流程图： 盒图（N-S）：出于要有一种不允许违背就够程序设计精神的图形工具的考虑 PAD图：它用二位树形结构的图来显示程序的控制流，将这种图翻译成车光绪代码比较容易 判定表：当算法中包含多重嵌套的条件选择时判定表却能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。 组成: 左上部列出所有条件，左下部是所有可能的动作。右上部是表示各种条件组合，右下部是和每种条件组合相对应的动作。 判定树： 是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。 PDL:过程语言也叫伪代码 程序复杂度的定量度量 程序复杂度定量度量:定量的度量详细设计模块的质量。 McCabe方法将程序图转化为程序流程图再计算复杂度。 计算方法: 流图中的区域数等于环形复杂度 流图G的环形复杂度V(G)=E-N+2， E是流图中边的条数，N是结点数。 流图G的环形复杂度V(G)=P+1,其中，P是流图中判定结点的数目。 V(G)","link":"/2022/11/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"title":"黑苹果使用","text":"黑苹果显卡温度检测（配合sensei使用）【黑苹果】让AMD显卡正常显示温度 | 给A卡添加温度传感器驱动_哔哩哔哩_bilibili 黑苹果下amd显卡关闭显卡智能启停高温夏天 显卡风扇不转怎么办？双系统（windows+macOS）下给显卡降降温_哔哩哔哩_bilibili oc引导更换机型三码OC引导快速更换三码和机型教程_哔哩哔哩_bilibili oc引导屏蔽不支持的硬盘黑苹果屏蔽三星981或者镁光2200等不支持的硬盘方法_哔哩哔哩_bilibili 黑苹果cpu睿频（配合cpus使用）黑苹果下CPU睿频，让黑苹果更加完美黑苹果CPU变频睿频日志，一招解决CPU频率不正确，无法变频-CPU黑苹果睿频解决卡顿现象黑果CPU变频日志睿频教程_哔哩哔哩_bilibili","link":"/2023/01/18/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"css基础","slug":"css基础","link":"/tags/css%E5%9F%BA%E7%A1%80/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"javascript基础","slug":"javascript基础","link":"/tags/javascript%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQl","slug":"MySQl","link":"/tags/MySQl/"},{"name":"Hexo搭建配置","slug":"Hexo搭建配置","link":"/tags/Hexo%E6%90%AD%E5%BB%BA%E9%85%8D%E7%BD%AE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"hexo主题配置","slug":"hexo主题配置","link":"/tags/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"cactus","slug":"cactus","link":"/tags/cactus/"},{"name":"css实战","slug":"css实战","link":"/tags/css%E5%AE%9E%E6%88%98/"},{"name":"css进阶","slug":"css进阶","link":"/tags/css%E8%BF%9B%E9%98%B6/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo使用","slug":"hexo使用","link":"/tags/hexo%E4%BD%BF%E7%94%A8/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"poems","slug":"poems","link":"/tags/poems/"},{"name":"Excel操作","slug":"Excel操作","link":"/tags/Excel%E6%93%8D%E4%BD%9C/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"政治","slug":"政治","link":"/tags/%E6%94%BF%E6%B2%BB/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"日语","slug":"日语","link":"/tags/%E6%97%A5%E8%AF%AD/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"线性代数","slug":"线性代数","link":"/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"study","slug":"study","link":"/categories/study/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"tech","slug":"tech","link":"/categories/tech/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"flask","slug":"后端/flask","link":"/categories/%E5%90%8E%E7%AB%AF/flask/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"网络协议","slug":"前端/网络协议","link":"/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"python","slug":"计算机基础/python","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/python/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"软件工程","slug":"计算机基础/软件工程","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"pages":[{"title":"about","text":"this is my blog","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"","text":"Document /* 网页中所有元素的边距置为0 */ * { margin: 0; padding: 0; } body { background-color: #f5f5f5; } a { text-decoration: none; color: #333; } .box { width: 298px; height: 415px; background-color: #fff; /* 让块级盒子水平居中对齐 */ margin: 100px auto; } /* 插入图片和盒子一样宽 */ .box img { width: 100%; height: 52%; } .review{ height: 70px; font-size: 14px; /* 这个段落，没有width属性，所以padding不会撑开盒子的宽度 */ padding: 0 28px; margin-top: 30px; } .appraise { font-size: 12px; color: #b0b0b0; margin-top: 20px; padding: 0 28px; } .info { font-size: 14px; margin-top: 15px; padding: 0 28px; } .info h4 { display: inline-block; font-weight: 400; } .info span { color: orange; } em { font-style: normal; color: #ebe4e0; margin: 0 6px 0 15px; } wow its good from England xiaomi bike... | 129yuan","link":"/images/css%E8%BF%9B%E9%98%B6/xiaomiProduct.html"},{"title":"","text":"Document body { font: 16px/28px 'Microsoft Yahei'; } h1 { /* 文字不加粗 */ font-weight: normal; /* 文字水平居中 */ text-align: center; } .grey { color: #888888; font-size: 12px; text-align: center; } a { text-decoration: none; } p { /* 首行缩进两个单位 */ text-indent: 2em; } .footer { color: #888888; font-size: 12px; } 一只特立独行独行的猪 文章来源：百度百科 作者 |王小波 插队的时候，我喂过猪、也放过牛。假如没有人来管，这两种动物也完全知道该怎样生活。它们会自由自在地闲逛，饥则食渴则饮，春天来临时还要谈谈爱情；这样一来，它们的生活层次很低，完全乏善可陈。 人来了以后，给它们的生活做出了安排：每一头牛和每一口猪的生活都有了主题。就它们中的大多数而言，这种生活主题是很悲惨的：前者的主题是干活，后者的主题是长肉。 我不认为这有什么可抱怨的，因为我当时的生活也不见得丰富了多少，除了八个样板戏，也没有什么消遣。 有极少数的猪和牛，它们的生活另有安排。以猪为例，种猪和母猪除了吃，还有别的事可干。 就我所见，它们对这些安排也不大喜欢。种猪的任务是交配，换言之，我们的政策准许它当个花花公子。 但是疲惫的种猪往往摆出一种肉猪（肉猪是阉过的）才有的正人君子架势，死活不肯跳到母猪背上去。母猪的任务是生崽儿，但有些母猪却要把猪崽儿吃掉。 总的来说，人的安排使猪痛苦不堪。但它们还是接受了：猪总是猪啊。 对生活做种种设置是人特有的品性。不光是设置动物，也设置自己。我们知道，在古希腊有个斯巴达，那里的生活被设置得了无生趣，其目的就是要使男人成为亡命战士，使女人成为生育机器，前者像些斗鸡，后者像些母猪。这两类动物是很特别的，但我以为，它们肯定不喜欢自己的生活。但不喜欢又能怎么样？人也好，动物也罢，都很难改变自己的命运。 以下谈到的一只猪有些与众不同。我喂猪时，它已经有四五岁了，从名分上说，它是肉猪，但长得又黑又瘦，两眼炯炯有光。这家伙像山羊一样敏捷，一米高的猪栏一跳就过；它还能跳上猪圈的房顶，这一点又像是猫——所以它总是到处游逛，根本就不在圈里呆着。所有喂过猪的知青都把它当宠儿来对待，它也是我的宠儿——因为它只对知青好，容许他们走到三米之内，要是别的人，它早就跑了。它是公的，原本该劁掉。不过你去试试看，哪怕你把劁猪刀藏在身后，它也能嗅出来，朝你瞪大眼睛，噢噢地吼起来。我总是用细米糠熬的粥喂它，等它吃够了以后，才把糠兑到野草里喂别的猪。其他猪看了嫉妒，一起嚷起来。这时候整个猪场一片鬼哭狼嚎，但我和它都不在乎。吃饱了以后，它就跳上房顶去晒太阳，或者模仿各种声音。它会学汽车响、拖拉机响，学得都很像；有时整天不见踪影，我估计它到附近的村寨里找母猪去了。我们这里也有母猪，都关在圈里，被过度的生育搞得走了形，又脏又臭，它对它们不感兴趣；村寨里的母猪好看一些。它有很多精彩的事迹，但我喂猪的时间短，知道得有限，索性就不写了。总而言之，所有喂过猪的知青都喜欢它，喜欢它特立独行的派头儿，还说它活得潇洒。但老乡们就不这么浪漫，他们说，这猪不正经。领导则痛恨它，这一点以后还要谈到。我对它则不止是喜欢——我尊敬它，常常不顾自己虚长十几岁这一现实，把它叫做“猪兄”。如前所述，这位猪兄会模仿各种声音。我想它也学过人说话，但没有学会——假如学会了，我们就可以做倾心之谈。但这不能怪它。人和猪的音色差得太远了。 后来，猪兄学会了汽笛叫，这个本领给它招来了麻烦。我们那里有座糖厂，中午要鸣一次汽笛，让工人换班。我们队下地干活时，听见这次汽笛响就收工回来。我的猪兄每天上午十点钟总要跳到房上学汽笛，地里的人听见它叫就回来——这可比糖厂鸣笛早了一个半小时。坦白地说，这不能全怪猪兄，它毕竟不是锅炉，叫起来和汽笛还有些区别，但老乡们却硬说听不出来。领导上因此开了一个会，把它定成了破坏春耕的坏分子，要对它采取专政手段——会议的精神我已经知道了，但我不为它担忧——因为假如专政是指绳索和杀猪刀的话，那是一点门都没有的。以前的领导也不是没试过，一百人也治不住它。狗也没用：猪兄跑起来像颗鱼雷，能把狗撞出一丈开外。谁知这回是动了真格的，指导员带了二十几个人，手拿五四式手枪；副指导员带了十几人，手持看青的火枪，分两路在猪场外的空地上兜捕它。这就使我陷入了内心的矛盾：按我和它的交情，我该舞起两把杀猪刀冲出去，和它并肩战斗，但我又觉得这样做太过惊世骇俗——它毕竟是只猪啊；还有一个理由，我不敢对抗领导，我怀疑这才是问题之所在。总之，我在一边看着。猪兄的镇定使我佩服之极：它很冷静地躲在手枪和火枪的连线之内，任凭人喊狗咬，不离那条线。这样，拿手枪的人开火就会把拿火枪的打死，反之亦然；两头同时开火，两头都会被打死。至于它，因为目标小，多半没事。就这样连兜了几个圈子，它找到了一个空子，一头撞出去了；跑得潇洒之极。以后我在甘蔗地里还见过它一次，它长出了獠牙，还认识我，但已不容我走近了。这种冷淡使我痛心，但我也赞成它对心怀叵测的人保持距离。 我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个原故，我一直怀念这只特立独行的猪。 编辑日期：2023-1-1","link":"/images/css/pink_test_css_news.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}